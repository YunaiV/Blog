title: JDK æºç è§£æ â€”â€” ç½‘ç»œ(ä¸€)ä¹‹ BIO
date: 2019-02-01
tags:
categories: JDK æºç 
permalink: JDK/net-1-bio
author: ä¸€å¶çŸ¥ç§‹
from_url: http://t.cn/Eq9t0FW
wechat_url:

-------

æ‘˜è¦: åŸåˆ›å‡ºå¤„ http://t.cn/Eq9t0FW ã€Œä¸€å¶çŸ¥ç§‹ã€æ¬¢è¿è½¬è½½ï¼Œä¿ç•™æ‘˜è¦ï¼Œè°¢è°¢ï¼

- [å¼•å…¥](http://www.iocoder.cn/JDK/net-1-bio/)
- [ServerSocketä¸­bindè§£è¯»](http://www.iocoder.cn/JDK/net-1-bio/)
- [ServerSocketä¸­acceptè§£è¯»](http://www.iocoder.cn/JDK/net-1-bio/)
- [é€šè¿‡Demoæ”¹é€ æ¥è¿›è¡Œacceptçš„éé˜»å¡å®ç°](http://www.iocoder.cn/JDK/net-1-bio/)
- [é€šè¿‡Demoæ”¹é€ æ¥è¿›è¡Œreadçš„éé˜»å¡å®ç°](http://www.iocoder.cn/JDK/net-1-bio/)
- [å¯¹accept()ä¸€äº›ä»£ç æ³¨æ„ç‚¹çš„æ€è€ƒ](http://www.iocoder.cn/JDK/net-1-bio/)

-------

![](http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg)

> ğŸ™‚ğŸ™‚ğŸ™‚å…³æ³¨**å¾®ä¿¡å…¬ä¼—å·ï¼šã€èŠ‹é“æºç ã€‘**æœ‰ç¦åˆ©ï¼š
> 1. RocketMQ / MyCAT / Sharding-JDBC **æ‰€æœ‰**æºç åˆ†ææ–‡ç« åˆ—è¡¨
> 2. RocketMQ / MyCAT / Sharding-JDBC **ä¸­æ–‡æ³¨é‡Šæºç  GitHub åœ°å€**
> 3. æ‚¨å¯¹äºæºç çš„ç–‘é—®æ¯æ¡ç•™è¨€**éƒ½**å°†å¾—åˆ°**è®¤çœŸ**å›å¤ã€‚**ç”šè‡³ä¸çŸ¥é“å¦‚ä½•è¯»æºç ä¹Ÿå¯ä»¥è¯·æ•™å™¢**ã€‚
> 4. **æ–°çš„**æºç è§£ææ–‡ç« **å®æ—¶**æ”¶åˆ°é€šçŸ¥ã€‚**æ¯å‘¨æ›´æ–°ä¸€ç¯‡å·¦å³**ã€‚
> 5. **è®¤çœŸçš„**æºç äº¤æµå¾®ä¿¡ç¾¤ã€‚

-------


# å¼•å…¥
æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªBIOçš„Demoæ¥å±•ç¤ºå…¶ç”¨æ³•:

``` java
//æœåŠ¡ç«¯
public class BIOServer {
    public void initBIOServer(int port)
    {
        ServerSocket serverSocket = null;//æœåŠ¡ç«¯Socket
        Socket socket = null;//å®¢æˆ·ç«¯socket
        BufferedReader reader = null;
        String inputContent;
        int count = 0;
        try {
            serverSocket = new ServerSocket(port);
            System.out.println(stringNowTime() + ": serverSocket started");
            while(true)
            {
                socket = serverSocket.accept();
                System.out.println(stringNowTime() + ": idä¸º" + socket.hashCode()+ "çš„Clientsocket connected");
                reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
                while ((inputContent = reader.readLine()) != null) {
                    System.out.println("æ”¶åˆ°idä¸º" + socket.hashCode() + "  "+inputContent);
                    count++;
                }
                System.out.println("idä¸º" + socket.hashCode()+ "çš„Clientsocket "+stringNowTime()+"è¯»å–ç»“æŸ");
            }
        } catch (IOException e) {
            e.printStackTrace();
        }finally{
            try {
                reader.close();
                socket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    public String stringNowTime()
    {
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        return format.format(new Date());
    }

    public static void main(String[] args) {
        BIOServer server = new BIOServer();
        server.initBIOServer(8888);

    }
}
// å®¢æˆ·ç«¯
public class BIOClient {

    public void initBIOClient(String host, int port) {
        BufferedReader reader = null;
        BufferedWriter writer = null;
        Socket socket = null;
        String inputContent;
        int count = 0;
        try {
            reader = new BufferedReader(new InputStreamReader(System.in));
            socket = new Socket(host, port);
            writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));
            System.out.println("clientSocket started: " + stringNowTime());
            while (((inputContent = reader.readLine()) != null) && count < 2) {
                inputContent = stringNowTime() + ": ç¬¬" + count + "æ¡æ¶ˆæ¯: " + inputContent + "\n";
                writer.write(inputContent);//å°†æ¶ˆæ¯å‘é€ç»™æœåŠ¡ç«¯
                writer.flush();
                count++;
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                socket.close();
                reader.close();
                writer.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    public String stringNowTime() {
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        return format.format(new Date());
    }

    public static void main(String[] args) {
        BIOClient client = new BIOClient();
        client.initBIOClient("127.0.0.1", 8888);
    }

}

```
é€šè¿‡ä¸Šé¢çš„ä¾‹å­ï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼Œæ— è®ºæ˜¯æœåŠ¡ç«¯è¿˜æ˜¯å®¢æˆ·ç«¯ï¼Œæˆ‘ä»¬å…³æ³¨çš„å‡ ä¸ªæ“ä½œæœ‰åŸºäºæœåŠ¡ç«¯çš„` serverSocket = new ServerSocket(port)` `serverSocket.accept()`ï¼ŒåŸºäºå®¢æˆ·ç«¯çš„`Socket socket = new Socket(host, port);` ä»¥åŠä¸¤è€…éƒ½æœ‰çš„è¯»å–ä¸å†™å…¥Socketæ•°æ®çš„æ–¹å¼ï¼Œå³é€šè¿‡æµæ¥è¿›è¡Œè¯»å†™ï¼Œè¿™ä¸ªè¯»å†™ä¸å…é€šè¿‡ä¸€ä¸ªä¸­é—´å­—èŠ‚æ•°ç»„bufferæ¥è¿›è¡Œã€‚
# ServerSocketä¸­bindè§£è¯»
äºæ˜¯ï¼Œæˆ‘ä»¬é€šè¿‡æºç æ¥çœ‹è¿™äº›ç›¸åº”çš„é€»è¾‘ã€‚æˆ‘ä»¬å…ˆæ¥çœ‹`ServerSocket.java`è¿™ä¸ªç±»çš„ç›¸å…³ä»£ç ã€‚
æˆ‘ä»¬æŸ¥çœ‹`ServerSocket.java`çš„æ„é€ å™¨å¯ä»¥çŸ¥é“ï¼Œå…¶æœ€åä¾ç„¶ä¼šè°ƒç”¨å®ƒçš„`bind`æ–¹æ³•:
``` java
//java.net.ServerSocket#ServerSocket(int)
public ServerSocket(int port) throws IOException {
    this(port, 50, null);
}
public ServerSocket(int port, int backlog, InetAddress bindAddr) throws IOException {
    setImpl();
    if (port < 0 || port > 0xFFFF)
        throw new IllegalArgumentException(
                    "Port value out of range: " + port);
    if (backlog < 1)
        backlog = 50;
    try {
        bind(new InetSocketAddress(bindAddr, port), backlog);
    } catch(SecurityException e) {
        close();
        throw e;
    } catch(IOException e) {
        close();
        throw e;
    }
}
```
æŒ‰ç…§æˆ‘ä»¬çš„Demoå’Œä¸Šé¢çš„æºç å¯çŸ¥ï¼Œè¿™é‡Œä¼ å…¥çš„å‚æ•°endpointå¹¶ä¸ä¼šä¸ºnullï¼ŒåŒæ—¶ï¼Œå±äº`InetSocketAddress`ç±»å‹ï¼Œbacklogå¤§å°ä¸º50ï¼Œäºæ˜¯ï¼Œæˆ‘ä»¬åº”è¯¥å…³æ³¨çš„ä¸»è¦ä»£ç é€»è¾‘ä¹Ÿå°±æ˜¯` getImpl().bind(epoint.getAddress(), epoint.getPort());`:
``` java
public void bind(SocketAddress endpoint, int backlog) throws IOException {
    if (isClosed())
        throw new SocketException("Socket is closed");
    if (!oldImpl && isBound())
        throw new SocketException("Already bound");
    if (endpoint == null)
        endpoint = new InetSocketAddress(0);
    if (!(endpoint instanceof InetSocketAddress))
        throw new IllegalArgumentException("Unsupported address type");
    InetSocketAddress epoint = (InetSocketAddress) endpoint;
    if (epoint.isUnresolved())
        throw new SocketException("Unresolved address");
    if (backlog < 1)
        backlog = 50;
    try {
        SecurityManager security = System.getSecurityManager();
        if (security != null)
            security.checkListen(epoint.getPort());
        // æˆ‘ä»¬åº”è¯¥å…³æ³¨çš„ä¸»è¦é€»è¾‘
        getImpl().bind(epoint.getAddress(), epoint.getPort());
        getImpl().listen(backlog);
        bound = true;
    } catch(SecurityException e) {
        bound = false;
        throw e;
    } catch(IOException e) {
        bound = false;
        throw e;
    }
}
```
è¿™é‡Œ`getImpl()`ï¼Œç”±ä¸Šé¢æ„é€ å™¨çš„å®ç°ä¸­ï¼Œæˆ‘ä»¬æœ‰çœ‹åˆ°`setImpl();`ï¼Œå¯çŸ¥ï¼Œå…¶`factory`é»˜è®¤ä¸ºnullï¼Œæ‰€ä»¥ï¼Œè¿™é‡Œæˆ‘ä»¬å…³æ³¨çš„æ˜¯`SocksSocketImpl`è¿™ä¸ªç±»ï¼Œåˆ›å»ºå…¶å¯¹è±¡ï¼Œå¹¶å°†å½“å‰`ServerSocket`å¯¹è±¡è®¾å®šå…¶ä¸­ï¼Œè¿™ä¸ªè®¾å®šçš„æºç è¯·åœ¨`SocksSocketImpl`çš„çˆ¶ç±»`java.net.SocketImpl`ä¸­æŸ¥çœ‹ã€‚
é‚£ä¹ˆgetImplä¹Ÿå°±æ˜äº†äº†ï¼Œå…¶å®å°±æ˜¯æˆ‘ä»¬Socketçš„åº•å±‚å®ç°å¯¹åº”çš„å®ä½“ç±»äº†ï¼Œå› ä¸ºä¸åŒçš„æ“ä½œç³»ç»Ÿå†…æ ¸æ˜¯ä¸åŒçš„ï¼Œä»–ä»¬å¯¹äºSocketçš„å®ç°å½“ç„¶ä¼šå„æœ‰ä¸åŒï¼Œæˆ‘ä»¬è¿™ç‚¹è¦æ³¨æ„ä¸‹ï¼Œè¿™é‡Œé’ˆå¯¹çš„æ˜¯winä¸‹é¢çš„ç³»ç»Ÿã€‚
``` java
/**
* The factory for all server sockets.
*/
private static SocketImplFactory factory = null;
private void setImpl() {
    if (factory != null) {
        impl = factory.createSocketImpl();
        checkOldImpl();
    } else {
        // No need to do a checkOldImpl() here, we know it's an up to date
        // SocketImpl!
        impl = new SocksSocketImpl();
    }
    if (impl != null)
        impl.setServerSocket(this);
}
/**
* Get the {@code SocketImpl} attached to this socket, creating
* it if necessary.
*
* @return  the {@code SocketImpl} attached to that ServerSocket.
* @throws SocketException if creation fails.
* @since 1.4
*/
SocketImpl getImpl() throws SocketException {
    if (!created)
        createImpl();
    return impl;
}
/**
* Creates the socket implementation.
*
* @throws IOException if creation fails
* @since 1.4
*/
void createImpl() throws SocketException {
    if (impl == null)
        setImpl();
    try {
        impl.create(true);
        created = true;
    } catch (IOException e) {
        throw new SocketException(e.getMessage());
    }
}

```
æˆ‘ä»¬å†çœ‹`SocksSocketImpl`çš„bindæ–¹æ³•å®ç°ï¼Œç„¶åå¾—åˆ°å…¶æœ€åæ— éæ˜¯è°ƒç”¨æœ¬åœ°æ–¹æ³•`bind0`ã€‚
``` java 
//java.net.AbstractPlainSocketImpl#bind
/**
* Binds the socket to the specified address of the specified local port.
* @param address the address
* @param lport the port
*/
protected synchronized void bind(InetAddress address, int lport)
    throws IOException
{
    synchronized (fdLock) {
        if (!closePending && (socket == null || !socket.isBound())) {
            NetHooks.beforeTcpBind(fd, address, lport);
        }
    }
    socketBind(address, lport);
    if (socket != null)
        socket.setBound();
    if (serverSocket != null)
        serverSocket.setBound();
}

//java.net.PlainSocketImpl#socketBind
@Override
void socketBind(InetAddress address, int port) throws IOException {
    int nativefd = checkAndReturnNativeFD();

    if (address == null)
        throw new NullPointerException("inet address argument is null.");

    if (preferIPv4Stack && !(address instanceof Inet4Address))
        throw new SocketException("Protocol family not supported");

    bind0(nativefd, address, port, useExclusiveBind);
    if (port == 0) {
        localport = localPort0(nativefd);
    } else {
        localport = port;
    }

    this.address = address;
}
//java.net.PlainSocketImpl#bind0
static native void bind0(int fd, InetAddress localAddress, int localport,
                             boolean exclBind)
        throws IOException;
```

è¿™é‡Œï¼Œæˆ‘ä»¬è¿˜è¦äº†è§£çš„æ˜¯ï¼Œä½¿ç”¨äº†å¤šçº¿ç¨‹åªæ˜¯èƒ½å¤Ÿå®ç°å¯¹"ä¸šåŠ¡é€»è¾‘å¤„ç†"çš„å¤šçº¿ç¨‹ï¼Œä½†æ˜¯å¯¹äºæ•°æ®æŠ¥æ–‡çš„æ¥æ”¶è¿˜æ˜¯éœ€è¦ä¸€ä¸ªä¸€ä¸ªæ¥çš„ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬ä¸Šé¢Demoä¸­è§åˆ°çš„acceptä»¥åŠreadæ–¹æ³•é˜»å¡é—®é¢˜ï¼Œå¤šçº¿ç¨‹æ˜¯æ ¹æœ¬è§£å†³ä¸äº†çš„ï¼Œé‚£ä¹ˆé¦–å…ˆæˆ‘ä»¬æ¥çœ‹çœ‹acceptä¸ºä»€ä¹ˆä¼šé€ æˆé˜»å¡ï¼Œacceptæ–¹æ³•çš„ä½œç”¨æ˜¯è¯¢é—®æ“ä½œç³»ç»Ÿæ˜¯å¦æœ‰æ–°çš„Socketå¥—æ¥å­—ä¿¡æ¯ä»ç«¯å£XXXå¤„å‘é€è¿‡æ¥ï¼Œæ³¨æ„è¿™é‡Œè¯¢é—®çš„æ˜¯æ“ä½œç³»ç»Ÿï¼Œä¹Ÿå°±æ˜¯è¯´Socketå¥—æ¥å­—IOæ¨¡å¼çš„æ”¯æŒæ˜¯åŸºäºæ“ä½œç³»ç»Ÿçš„ï¼Œå¦‚æœæ“ä½œç³»ç»Ÿæ²¡æœ‰å‘ç°æœ‰å¥—æ¥å­—ä»æŒ‡å®šç«¯å£XXXè¿æ¥è¿›æ¥ï¼Œé‚£ä¹ˆæ“ä½œç³»ç»Ÿå°±ä¼šç­‰å¾…ï¼Œè¿™æ ·acceptæ–¹æ³•å°±ä¼šé˜»å¡ï¼Œä»–çš„å†…éƒ¨å®ç°ä½¿ç”¨çš„æ˜¯æ“ä½œç³»ç»Ÿçº§åˆ«çš„åŒæ­¥IOã€‚

# ServerSocketä¸­acceptè§£è¯»

äºæ˜¯ï¼Œæˆ‘ä»¬æ¥åˆ†æä¸‹`ServerSocket.accept`æ–¹æ³•çš„æºç è¿‡ç¨‹:
``` java
public Socket accept() throws IOException {
    if (isClosed())
        throw new SocketException("Socket is closed");
    if (!isBound())
        throw new SocketException("Socket is not bound yet");
    Socket s = new Socket((SocketImpl) null);
    implAccept(s);
    return s;
}
```
é¦–å…ˆè¿›è¡Œçš„æ˜¯ä¸€äº›åˆ¤æ–­ï¼Œæ¥ç€åˆ›å»ºäº†ä¸€ä¸ªSocketå¯¹è±¡ï¼ˆä¸ºä»€ä¹ˆè¿™é‡Œè¦åˆ›å»ºä¸€ä¸ªSocketå¯¹è±¡ï¼Œåé¢ä¼šè®²åˆ°ï¼‰ï¼Œæ‰§è¡Œäº†implAcceptæ–¹æ³•ï¼Œæ¥çœ‹çœ‹implAcceptæ–¹æ³•ï¼š
``` java
/**
* Subclasses of ServerSocket use this method to override accept()
* to return their own subclass of socket.  So a FooServerSocket
* will typically hand this method an <i>empty</i> FooSocket.  On
* return from implAccept the FooSocket will be connected to a client.
*
* @param s the Socket
* @throws java.nio.channels.IllegalBlockingModeException
*         if this socket has an associated channel,
*         and the channel is in non-blocking mode
* @throws IOException if an I/O error occurs when waiting
* for a connection.
* @since   1.1
* @revised 1.4
* @spec JSR-51
*/
protected final void implAccept(Socket s) throws IOException {
SocketImpl si = null;
try {
    if (s.impl == null)
        s.setImpl();
    else {
        s.impl.reset();
    }
    si = s.impl;
    s.impl = null;
    si.address = new InetAddress();
    si.fd = new FileDescriptor();
    getImpl().accept(si);  // <1>
    SocketCleanable.register(si.fd);   // raw fd has been set

    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkAccept(si.getInetAddress().getHostAddress(),
                                si.getPort());
    }
} catch (IOException e) {
    if (si != null)
        si.reset();
    s.impl = si;
    throw e;
} catch (SecurityException e) {
    if (si != null)
        si.reset();
    s.impl = si;
    throw e;
}
s.impl = si;
s.postAccept();
}
```
ä¸Šé¢æ‰§è¡Œäº†<1>å¤„getImplçš„acceptæ–¹æ³•ä¹‹åï¼Œæˆ‘ä»¬åœ¨AbstractPlainSocketImplæ‰¾åˆ°acceptæ–¹æ³•ï¼š
``` java
//java.net.AbstractPlainSocketImpl#accept
/**
* Accepts connections.
* @param s the connection
*/
protected void accept(SocketImpl s) throws IOException {
acquireFD();
try {
    socketAccept(s);
} finally {
    releaseFD();
}
}
```
å¯ä»¥çœ‹åˆ°ä»–è°ƒç”¨äº†socketAcceptæ–¹æ³•ï¼Œå› ä¸ºæ¯ä¸ªæ“ä½œç³»ç»Ÿçš„Socketåœ°å®ç°éƒ½ä¸åŒï¼Œæ‰€ä»¥è¿™é‡ŒWindowsä¸‹å°±æ‰§è¡Œäº†æˆ‘ä»¬PlainSocketImplé‡Œé¢çš„socketAcceptæ–¹æ³•:
``` java
// java.net.PlainSocketImpl#socketAccept
@Override
void socketAccept(SocketImpl s) throws IOException {
    int nativefd = checkAndReturnNativeFD();

    if (s == null)
        throw new NullPointerException("socket is null");

    int newfd = -1;
    InetSocketAddress[] isaa = new InetSocketAddress[1];
    if (timeout <= 0) {  //<1>
        newfd = accept0(nativefd, isaa); // <2>
    } else {
        configureBlocking(nativefd, false);
        try {
            waitForNewConnection(nativefd, timeout);
            newfd = accept0(nativefd, isaa);  // <3>
            if (newfd != -1) {
                configureBlocking(newfd, true);
            }
        } finally {
            configureBlocking(nativefd, true);
        }
    } // <4>
    /* Update (SocketImpl)s' fd */
    fdAccess.set(s.fd, newfd);
    /* Update socketImpls remote port, address and localport */
    InetSocketAddress isa = isaa[0];
    s.port = isa.getPort();
    s.address = isa.getAddress();
    s.localport = localport;
    if (preferIPv4Stack && !(s.address instanceof Inet4Address))
        throw new SocketException("Protocol family not supported");
}
//java.net.PlainSocketImpl#accept0
 static native int accept0(int fd, InetSocketAddress[] isaa) throws IOException;
```
Â  è¿™é‡Œ<1>åˆ°<4>ä¹‹é—´æ˜¯æˆ‘ä»¬å…³æ³¨çš„ä»£ç ï¼Œ<2>å’Œ<3>æ‰§è¡Œäº†accept0æ–¹æ³•ï¼Œè¿™ä¸ªæ˜¯nativeæ–¹æ³•ï¼Œå…·ä½“æ¥è¯´å°±æ˜¯ä¸æ“ä½œç³»ç»Ÿäº¤äº’æ¥å®ç°ç›‘å¬æŒ‡å®šç«¯å£ä¸Šæ˜¯å¦æœ‰å®¢æˆ·ç«¯æ¥å…¥ï¼Œæ­£æ˜¯å› ä¸ºaccept0åœ¨æ²¡æœ‰å®¢æˆ·ç«¯æ¥å…¥çš„æ—¶å€™ä¼šä¸€ç›´å¤„äºé˜»å¡çŠ¶æ€ï¼Œæ‰€ä»¥é€ æˆäº†æˆ‘ä»¬ç¨‹åºçº§åˆ«çš„acceptæ–¹æ³•é˜»å¡ï¼Œå½“ç„¶å¯¹äºç¨‹åºçº§åˆ«çš„é˜»å¡ï¼Œæˆ‘ä»¬æ˜¯å¯ä»¥é¿å…çš„ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬å¯ä»¥å°†acceptæ–¹æ³•ä¿®æ”¹æˆéé˜»å¡å¼ï¼Œä½†æ˜¯å¯¹äºaccept0é€ æˆçš„é˜»å¡æˆ‘ä»¬æš‚æ—¶æ˜¯æ²¡æ³•æ”¹å˜çš„ï¼Œæ“ä½œç³»ç»Ÿçº§åˆ«çš„é˜»å¡å…¶å®å°±æ˜¯æˆ‘ä»¬é€šå¸¸æ‰€è¯´çš„åŒæ­¥å¼‚æ­¥ä¸­çš„åŒæ­¥äº†ã€‚
å‰é¢è¯´åˆ°æˆ‘ä»¬å¯ä»¥åœ¨ç¨‹åºçº§åˆ«æ”¹å˜acceptçš„é˜»å¡ï¼Œå…·ä½“æ€ä¹ˆå®ç°ï¼Ÿå…¶å®å°±æ˜¯é€šè¿‡æˆ‘ä»¬ä¸Šé¢socketAcceptæ–¹æ³•ä¸­åˆ¤æ–­timeoutçš„å€¼æ¥å®ç°ï¼Œåœ¨ç¬¬<1>å¤„åˆ¤æ–­timeoutçš„å€¼å¦‚æœå°äºç­‰äº0ï¼Œé‚£ä¹ˆç›´æ¥æ‰§è¡Œaccept0æ–¹æ³•ï¼Œè¿™æ—¶å€™å°†ä¸€ç›´å¤„äºé˜»å¡çŠ¶æ€ï¼Œä½†æ˜¯å¦‚æœæˆ‘ä»¬è®¾ç½®äº†timeoutçš„è¯ï¼Œå³timeoutå€¼å¤§äº0çš„è¯ï¼Œåˆ™ç¨‹åºä¼šåœ¨ç­‰åˆ°æˆ‘ä»¬è®¾ç½®çš„æ—¶é—´åè¿”å›ï¼Œæ³¨æ„è¿™é‡Œçš„newfdå¦‚æœç­‰äº-1çš„è¯ï¼Œè¡¨ç¤ºè¿™æ¬¡acceptæ²¡æœ‰å‘ç°æœ‰æ•°æ®ä»åº•å±‚è¿”å›ï¼›é‚£ä¹ˆåˆ°åº•timeoutçš„å€¼æ˜¯åœ¨å“ªè®¾ç½®ï¼Ÿæˆ‘ä»¬å¯ä»¥é€šè¿‡ServerSocketçš„setSoTimeoutæ–¹æ³•è¿›è¡Œè®¾ç½®ï¼Œæ¥çœ‹çœ‹è¿™ä¸ªæ–¹æ³•ï¼š

``` java
/**
* Enable/disable {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT} with the
* specified timeout, in milliseconds.  With this option set to a non-zero
* timeout, a call to accept() for this ServerSocket
* will block for only this amount of time.  If the timeout expires,
* a <B>java.net.SocketTimeoutException</B> is raised, though the
* ServerSocket is still valid.  The option <B>must</B> be enabled
* prior to entering the blocking operation to have effect.  The
* timeout must be {@code > 0}.
* A timeout of zero is interpreted as an infinite timeout.
* @param timeout the specified timeout, in milliseconds
* @exception SocketException if there is an error in
* the underlying protocol, such as a TCP error.
* @since   1.1
* @see #getSoTimeout()
*/
public synchronized void setSoTimeout(int timeout) throws SocketException {
if (isClosed())
    throw new SocketException("Socket is closed");
getImpl().setOption(SocketOptions.SO_TIMEOUT, timeout);
}
```
å…¶æ‰§è¡Œäº†getImplçš„setOptionæ–¹æ³•ï¼Œå¹¶ä¸”è®¾ç½®äº†timeoutæ—¶é—´ï¼Œè¿™é‡Œï¼Œæˆ‘ä»¬ä»AbstractPlainSocketImplä¸­æŸ¥çœ‹ï¼š
``` java
//java.net.AbstractPlainSocketImpl#setOption
public void setOption(int opt, Object val) throws SocketException {
    if (isClosedOrPending()) {
        throw new SocketException("Socket Closed");
    }
    boolean on = true;
    switch (opt) {
        /* check type safety b4 going native.  These should never
            * fail, since only java.Socket* has access to
            * PlainSocketImpl.setOption().
            */
    case SO_LINGER:
        if (val == null || (!(val instanceof Integer) && !(val instanceof Boolean)))
            throw new SocketException("Bad parameter for option");
        if (val instanceof Boolean) {
            /* true only if disabling - enabling should be Integer */
            on = false;
        }
        break;
    case SO_TIMEOUT: //<1>
        if (val == null || (!(val instanceof Integer)))
            throw new SocketException("Bad parameter for SO_TIMEOUT");
        int tmp = ((Integer) val).intValue();
        if (tmp < 0)
            throw new IllegalArgumentException("timeout < 0");
        timeout = tmp;
        break;
    case IP_TOS:
            if (val == null || !(val instanceof Integer)) {
                throw new SocketException("bad argument for IP_TOS");
            }
            trafficClass = ((Integer)val).intValue();
            break;
    case SO_BINDADDR:
        throw new SocketException("Cannot re-bind socket");
    case TCP_NODELAY:
        if (val == null || !(val instanceof Boolean))
            throw new SocketException("bad parameter for TCP_NODELAY");
        on = ((Boolean)val).booleanValue();
        break;
    case SO_SNDBUF:
    case SO_RCVBUF:
        if (val == null || !(val instanceof Integer) ||
            !(((Integer)val).intValue() > 0)) {
            throw new SocketException("bad parameter for SO_SNDBUF " +
                                        "or SO_RCVBUF");
        }
        break;
    case SO_KEEPALIVE:
        if (val == null || !(val instanceof Boolean))
            throw new SocketException("bad parameter for SO_KEEPALIVE");
        on = ((Boolean)val).booleanValue();
        break;
    case SO_OOBINLINE:
        if (val == null || !(val instanceof Boolean))
            throw new SocketException("bad parameter for SO_OOBINLINE");
        on = ((Boolean)val).booleanValue();
        break;
    case SO_REUSEADDR:
        if (val == null || !(val instanceof Boolean))
            throw new SocketException("bad parameter for SO_REUSEADDR");
        on = ((Boolean)val).booleanValue();
        break;
    case SO_REUSEPORT:
        if (val == null || !(val instanceof Boolean))
            throw new SocketException("bad parameter for SO_REUSEPORT");
        if (!supportedOptions().contains(StandardSocketOptions.SO_REUSEPORT))
            throw new UnsupportedOperationException("unsupported option");
        on = ((Boolean)val).booleanValue();
        break;
    default:
        throw new SocketException("unrecognized TCP option: " + opt);
    }
    socketSetOption(opt, on, val);
}
```
è¿™ä¸ªæ–¹æ³•æ¯”è¾ƒé•¿ï¼Œæˆ‘ä»¬ä»…çœ‹ä¸`timeout`æœ‰å…³çš„ä»£ç ï¼Œå³<1>å¤„çš„ä»£ç ã€‚å…¶å®è¿™é‡Œä»…ä»…å°±æ˜¯å°†æˆ‘ä»¬setOptioné‡Œé¢ä¼ å…¥çš„timeoutå€¼è®¾ç½®åˆ°äº†AbstractPlainSocketImplçš„å…¨å±€å˜é‡timeouté‡Œè€Œå·²ã€‚

è¿™æ ·ï¼Œæˆ‘ä»¬å°±å¯ä»¥åœ¨ç¨‹åºçº§åˆ«å°†acceptæ–¹æ³•è®¾ç½®æˆä¸ºéé˜»å¡å¼çš„äº†ï¼Œä½†æ˜¯readæ–¹æ³•ç°åœ¨è¿˜æ˜¯é˜»å¡å¼çš„ï¼Œå³åé¢æˆ‘ä»¬è¿˜éœ€è¦æ”¹é€ readæ–¹æ³•ï¼ŒåŒæ ·å°†å®ƒåœ¨ç¨‹åºçº§åˆ«ä¸Šå˜æˆéé˜»å¡å¼ã€‚
# é€šè¿‡Demoæ”¹é€ æ¥è¿›è¡Œacceptçš„éé˜»å¡å®ç°
åœ¨æ­£å¼æ”¹é€ å‰ï¼Œæˆ‘ä»¬æœ‰å¿…è¦æ¥è§£é‡Šä¸‹Socketä¸‹åŒæ­¥/å¼‚æ­¥å’Œé˜»å¡/éé˜»å¡:

Â Â Â åŒæ­¥/å¼‚æ­¥æ˜¯å±äºæ“ä½œç³»ç»Ÿçº§åˆ«çš„ï¼ŒæŒ‡çš„æ˜¯æ“ä½œç³»ç»Ÿåœ¨æ”¶åˆ°ç¨‹åºè¯·æ±‚çš„IOä¹‹åï¼Œå¦‚æœIOèµ„æºæ²¡æœ‰å‡†å¤‡å¥½çš„è¯ï¼Œè¯¥å¦‚ä½•å“åº”ç¨‹åºçš„é—®é¢˜ï¼ŒåŒæ­¥çš„è¯å°±æ˜¯ä¸å“åº”ï¼Œç›´åˆ°IOèµ„æºå‡†å¤‡å¥½ï¼›è€Œå¼‚æ­¥çš„è¯åˆ™ä¼šè¿”å›ç»™ç¨‹åºä¸€ä¸ªæ ‡å¿—ï¼Œè¿™ä¸ªæ ‡å¿—ç”¨äºå½“IOèµ„æºå‡†å¤‡å¥½åé€šè¿‡äº‹ä»¶æœºåˆ¶å‘é€çš„å†…å®¹åº”è¯¥å‘åˆ°ä»€ä¹ˆåœ°æ–¹ã€‚

Â Â Â é˜»å¡/éé˜»å¡æ˜¯å±äºç¨‹åºçº§åˆ«çš„ï¼ŒæŒ‡çš„æ˜¯ç¨‹åºåœ¨è¯·æ±‚æ“ä½œç³»ç»Ÿè¿›è¡ŒIOæ“ä½œæ—¶ï¼Œå¦‚æœIOèµ„æºæ²¡æœ‰å‡†å¤‡å¥½çš„è¯ï¼Œç¨‹åºè¯¥æ€ä¹ˆå¤„ç†çš„é—®é¢˜ï¼Œé˜»å¡çš„è¯å°±æ˜¯ç¨‹åºä»€ä¹ˆéƒ½ä¸åšï¼Œä¸€ç›´ç­‰åˆ°IOèµ„æºå‡†å¤‡å¥½ï¼Œéé˜»å¡çš„è¯ç¨‹åºåˆ™ç»§ç»­è¿è¡Œï¼Œä½†æ˜¯ä¼šæ—¶ä¸æ—¶çš„å»æŸ¥çœ‹ä¸‹IOåˆ°åº•å‡†å¤‡å¥½æ²¡æœ‰å‘¢ï¼›

Â Â Â æˆ‘ä»¬é€šå¸¸è§åˆ°çš„BIOæ˜¯åŒæ­¥é˜»å¡å¼çš„ï¼ŒåŒæ­¥çš„è¯è¯´æ˜æ“ä½œç³»ç»Ÿåº•å±‚æ˜¯ä¸€ç›´ç­‰å¾…IOèµ„æºå‡†å¤‡ç›´åˆ°okçš„ï¼Œé˜»å¡çš„è¯æ˜¯ç¨‹åºæœ¬èº«ä¹Ÿåœ¨ä¸€ç›´ç­‰å¾…IOèµ„æºå‡†å¤‡ç›´åˆ°okï¼Œå…·ä½“æ¥è®²ç¨‹åºçº§åˆ«çš„é˜»å¡å°±æ˜¯acceptå’Œreadé€ æˆçš„ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡æ”¹é€ å°†å…¶å˜æˆéé˜»å¡å¼ï¼Œä½†æ˜¯æ“ä½œç³»ç»Ÿå±‚æ¬¡çš„é˜»å¡æˆ‘ä»¬æ²¡æ³•æ”¹å˜ã€‚

Â Â Â æˆ‘ä»¬çš„NIOæ˜¯åŒæ­¥éé˜»å¡å¼çš„ï¼Œå…¶å®å®ƒçš„éé˜»å¡å®ç°åŸç†å’Œæˆ‘ä»¬ä¸Šé¢çš„è®²è§£å·®ä¸å¤šçš„ï¼Œå°±æ˜¯ä¸ºäº†æ”¹å–„acceptå’Œreadæ–¹æ³•å¸¦æ¥çš„é˜»å¡ç°è±¡ï¼Œæ‰€ä»¥å¼•å…¥äº†`Channel`å’Œ`Buffer`çš„æ¦‚å¿µã€‚

å¥½äº†ï¼Œæˆ‘ä»¬å¯¹æˆ‘ä»¬çš„Demoè¿›è¡Œæ”¹è¿›ï¼Œè§£å†³acceptå¸¦æ¥çš„é˜»å¡é—®é¢˜(ä¸ºå¤šä¸ªå®¢æˆ·ç«¯è¿æ¥åšçš„å¼‚æ­¥å¤„ç†ï¼Œè¿™é‡Œå°±ä¸å¤šè§£é‡Šäº†ï¼Œè¯»è€…å¯è‡ªè¡Œæ€è€ƒï¼Œå®åœ¨ä¸è¡Œå¯åˆ°æœ¬äººç›¸å…³è§†é¢‘ä¸­æ‰¾åˆ°å¯¹åº”è§£è¯»)ï¼š

``` java
public class BIOProNotB {

    public void initBIOServer(int port) {
        ServerSocket serverSocket = null;//æœåŠ¡ç«¯Socket
        Socket socket = null;//å®¢æˆ·ç«¯socket
        ExecutorService threadPool = Executors.newCachedThreadPool();
        ClientSocketThread thread = null;
        try {
            serverSocket = new ServerSocket(port);
            serverSocket.setSoTimeout(1000);
            System.out.println(stringNowTime() + ": serverSocket started");
            while (true) {
                try {
                    socket = serverSocket.accept();
                } catch (SocketTimeoutException e) {
                    //è¿è¡Œåˆ°è¿™é‡Œè¡¨ç¤ºæœ¬æ¬¡acceptæ˜¯æ²¡æœ‰æ”¶åˆ°ä»»ä½•æ•°æ®çš„ï¼ŒæœåŠ¡ç«¯çš„ä¸»çº¿ç¨‹åœ¨è¿™é‡Œå¯ä»¥åšä¸€äº›å…¶ä»–äº‹æƒ…
                    System.out.println("now time is: " + stringNowTime());
                    continue;
                }
                System.out.println(stringNowTime() + ": idä¸º" + socket.hashCode() + "çš„Clientsocket connected");
                thread = new ClientSocketThread(socket);
                threadPool.execute(thread);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public String stringNowTime() {
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS");
        return format.format(new Date());
    }

    class ClientSocketThread extends Thread {
        public Socket socket;

        public ClientSocketThread(Socket socket) {
            this.socket = socket;
        }

        @Override
        public void run() {
            BufferedReader reader = null;
            String inputContent;
            int count = 0;
            try {
                reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
                while ((inputContent = reader.readLine()) != null) {
                    System.out.println("æ”¶åˆ°idä¸º" + socket.hashCode() + "  " + inputContent);
                    count++;
                }
                System.out.println("idä¸º" + socket.hashCode() + "çš„Clientsocket " + stringNowTime() + "è¯»å–ç»“æŸ");
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                try {
                    reader.close();
                    socket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static void main(String[] args) {
        BIOProNotB server = new BIOProNotB();
        server.initBIOServer(8888);
    }


}
```
ä¸ºæˆ‘ä»¬çš„ServerSocketè®¾ç½®äº†timeoutæ—¶é—´ï¼Œè¿™æ ·çš„è¯è°ƒç”¨acceptæ–¹æ³•çš„æ—¶å€™æ¯éš”1sä»–å°±ä¼šè¢«å”¤é†’ä¸€æ¬¡ï¼Œè€Œä¸å†æ˜¯ä¸€ç›´åœ¨é‚£é‡Œï¼Œåªæœ‰æœ‰å®¢æˆ·ç«¯æ¥å…¥æ‰ä¼šè¿”å›ä¿¡æ¯ï¼›æˆ‘ä»¬è¿è¡Œä¸€ä¸‹çœ‹çœ‹ç»“æœï¼š
``` 
2019-01-02 17:28:43:362: serverSocket started
now time is: 2019-01-02 17:28:44:363
now time is: 2019-01-02 17:28:45:363
now time is: 2019-01-02 17:28:46:363
now time is: 2019-01-02 17:28:47:363
now time is: 2019-01-02 17:28:48:363
now time is: 2019-01-02 17:28:49:363
now time is: 2019-01-02 17:28:50:363
now time is: 2019-01-02 17:28:51:364
now time is: 2019-01-02 17:28:52:365
now time is: 2019-01-02 17:28:53:365
now time is: 2019-01-02 17:28:54:365
now time is: 2019-01-02 17:28:55:365
now time is: 2019-01-02 17:28:56:365 // <1>
2019-01-02 17:28:56:911: idä¸º1308927845çš„Clientsocket connected
now time is: 2019-01-02 17:28:57:913 // <2>
now time is: 2019-01-02 17:28:58:913
```
å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬åˆšå¼€å§‹å¹¶æ²¡æœ‰å®¢æˆ·ç«¯æ¥å…¥çš„æ—¶å€™ï¼Œæ˜¯ä¼šæ‰§è¡Œ`System.out.println("now time is: " + stringNowTime());`çš„è¾“å‡ºï¼Œè¿˜æœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„çš„å°±æ˜¯ï¼Œä»”ç»†çœ‹çœ‹ä¸Šé¢çš„è¾“å‡ºç»“æœçš„æ ‡è®°<1>ä¸<2>ï¼Œä½ ä¼šå‘ç°<2>å¤„æ—¶é—´å€¼ä¸æ˜¯17:28:57:365ï¼ŒåŸå› å°±åœ¨äºå¦‚æœacceptæ­£å¸¸è¿”å›å€¼çš„è¯ï¼Œæ˜¯ä¸ä¼šæ‰§è¡Œcatchè¯­å¥éƒ¨åˆ†çš„ã€‚
# é€šè¿‡Demoæ”¹é€ æ¥è¿›è¡Œreadçš„éé˜»å¡å®ç°
Â Â Â è¿™æ ·çš„è¯ï¼Œæˆ‘ä»¬å°±æŠŠacceptéƒ¨åˆ†æ”¹é€ æˆäº†éé˜»å¡å¼äº†ï¼Œé‚£ä¹ˆreadéƒ¨åˆ†å¯ä»¥æ”¹é€ ä¹ˆï¼Ÿå½“ç„¶å¯ä»¥ï¼Œæ”¹é€ æ–¹æ³•å’Œacceptå¾ˆç±»ä¼¼ï¼Œæˆ‘ä»¬åœ¨readçš„æ—¶å€™ï¼Œä¼šè°ƒç”¨
`java.net.AbstractPlainSocketImpl#getInputStream`:
``` java
/**
* Gets an InputStream for this socket.
*/
protected synchronized InputStream getInputStream() throws IOException {
synchronized (fdLock) {
    if (isClosedOrPending())
        throw new IOException("Socket Closed");
    if (shut_rd)
        throw new IOException("Socket input is shutdown");
    if (socketInputStream == null)
        socketInputStream = new SocketInputStream(this);
}
return socketInputStream;
}
```
è¿™é‡Œé¢åˆ›å»ºäº†ä¸€ä¸ª`SocketInputStream`å¯¹è±¡ï¼Œä¼šå°†å½“å‰`AbstractPlainSocketImpl`å¯¹è±¡ä¼ è¿›å»ï¼Œäºæ˜¯ï¼Œåœ¨è¯»æ•°æ®çš„æ—¶å€™ï¼Œæˆ‘ä»¬ä¼šè°ƒç”¨å¦‚ä¸‹æ–¹æ³•:
``` java
public int read(byte b[], int off, int length) throws IOException {
    return read(b, off, length, impl.getTimeout());
}

int read(byte b[], int off, int length, int timeout) throws IOException {
    int n;

    // EOF already encountered
    if (eof) {
        return -1;
    }

    // connection reset
    if (impl.isConnectionReset()) {
        throw new SocketException("Connection reset");
    }

    // bounds check
    if (length <= 0 || off < 0 || length > b.length - off) {
        if (length == 0) {
            return 0;
        }
        throw new ArrayIndexOutOfBoundsException("length == " + length
                + " off == " + off + " buffer length == " + b.length);
    }

    // acquire file descriptor and do the read
    FileDescriptor fd = impl.acquireFD();
    try {
        n = socketRead(fd, b, off, length, timeout);
        if (n > 0) {
            return n;
        }
    } catch (ConnectionResetException rstExc) {
        impl.setConnectionReset();
    } finally {
        impl.releaseFD();
    }

    /*
        * If we get here we are at EOF, the socket has been closed,
        * or the connection has been reset.
        */
    if (impl.isClosedOrPending()) {
        throw new SocketException("Socket closed");
    }
    if (impl.isConnectionReset()) {
        throw new SocketException("Connection reset");
    }
    eof = true;
    return -1;
}
private int socketRead(FileDescriptor fd,
                           byte b[], int off, int len,
                           int timeout)
        throws IOException {
        return socketRead0(fd, b, off, len, timeout);
}
```
è¿™é‡Œï¼Œæˆ‘ä»¬çœ‹åˆ°äº†socketReadåŒæ ·è®¾å®šäº†timeoutï¼Œè€Œä¸”è¿™ä¸ªtimeoutå°±æ˜¯æˆ‘ä»¬åˆ›å»ºè¿™ä¸ª`SocketInputStream`å¯¹è±¡æ—¶ä¼ å…¥çš„`AbstractPlainSocketImpl`å¯¹è±¡æ¥æ§åˆ¶çš„ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬åªéœ€è¦è®¾å®š`serverSocket.setSoTimeout(1000)`å³å¯ã€‚
æˆ‘ä»¬å†æ¬¡ä¿®æ”¹æœåŠ¡ç«¯ä»£ç (ä»£ç æ€»å…±ä¸¤æ¬¡è®¾å®šï¼Œç¬¬ä¸€æ¬¡æ˜¯è®¾å®šçš„æ˜¯ServerSocketçº§åˆ«çš„ï¼Œç¬¬äºŒæ¬¡è®¾å®šçš„å®¢æˆ·ç«¯è¿æ¥è¿”å›çš„é‚£ä¸ªSocketï¼Œä¸¤è€…ä¸ä¸€æ ·)ï¼š
``` java
public class BIOProNotBR {

    public void initBIOServer(int port) {
        ServerSocket serverSocket = null;//æœåŠ¡ç«¯Socket
        Socket socket = null;//å®¢æˆ·ç«¯socket
        ExecutorService threadPool = Executors.newCachedThreadPool();
        ClientSocketThread thread = null;
        try {
            serverSocket = new ServerSocket(port);
            serverSocket.setSoTimeout(1000);
            System.out.println(stringNowTime() + ": serverSocket started");
            while (true) {
                try {
                    socket = serverSocket.accept();
                } catch (SocketTimeoutException e) {
                    //è¿è¡Œåˆ°è¿™é‡Œè¡¨ç¤ºæœ¬æ¬¡acceptæ˜¯æ²¡æœ‰æ”¶åˆ°ä»»ä½•æ•°æ®çš„ï¼ŒæœåŠ¡ç«¯çš„ä¸»çº¿ç¨‹åœ¨è¿™é‡Œå¯ä»¥åšä¸€äº›å…¶ä»–äº‹æƒ…
                    System.out.println("now time is: " + stringNowTime());
                    continue;
                }
                System.out.println(stringNowTime() + ": idä¸º" + socket.hashCode() + "çš„Clientsocket connected");
                thread = new ClientSocketThread(socket);
                threadPool.execute(thread);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public String stringNowTime() {
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS");
        return format.format(new Date());
    }

    class ClientSocketThread extends Thread {
        public Socket socket;

        public ClientSocketThread(Socket socket) {
            this.socket = socket;
        }

        @Override
        public void run() {
            BufferedReader reader = null;
            String inputContent;
            int count = 0;
            try {
                socket.setSoTimeout(1000);
            } catch (SocketException e1) {
                e1.printStackTrace();
            }
            try {
                reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
                while (true) {
                    try {
                        while ((inputContent = reader.readLine()) != null) {
                            System.out.println("æ”¶åˆ°idä¸º" + socket.hashCode() + "  " + inputContent);
                            count++;
                        }
                    } catch (Exception e) {
                        //æ‰§è¡Œåˆ°è¿™é‡Œè¡¨ç¤ºreadæ–¹æ³•æ²¡æœ‰è·å–åˆ°ä»»ä½•æ•°æ®ï¼Œçº¿ç¨‹å¯ä»¥æ‰§è¡Œä¸€äº›å…¶ä»–çš„æ“ä½œ
                        System.out.println("Not read data: " + stringNowTime());
                        continue;
                    }
                    //æ‰§è¡Œåˆ°è¿™é‡Œè¡¨ç¤ºè¯»å–åˆ°äº†æ•°æ®ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è¿™é‡Œè¿›è¡Œå›å¤å®¢æˆ·ç«¯çš„å·¥ä½œ
                    System.out.println("idä¸º" + socket.hashCode() + "çš„Clientsocket " + stringNowTime() + "è¯»å–ç»“æŸ");
                    sleep(1000);
                }
            } catch (IOException e) {
                e.printStackTrace();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                try {
                    reader.close();
                    socket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static void main(String[] args) {
        BIOProNotBR server = new BIOProNotBR();
        server.initBIOServer(8888);
    }


}
```
æ‰§è¡Œå¦‚ä¸‹:
```
2019-01-02 17:59:03:713: serverSocket started
now time is: 2019-01-02 17:59:04:714
now time is: 2019-01-02 17:59:05:714
now time is: 2019-01-02 17:59:06:714
2019-01-02 17:59:06:932: idä¸º1810132623çš„Clientsocket connected
now time is: 2019-01-02 17:59:07:934
Not read data: 2019-01-02 17:59:07:935
now time is: 2019-01-02 17:59:08:934
Not read data: 2019-01-02 17:59:08:935
now time is: 2019-01-02 17:59:09:935
Not read data: 2019-01-02 17:59:09:936
æ”¶åˆ°idä¸º1810132623  2019-01-02 17:59:09: ç¬¬0æ¡æ¶ˆæ¯: ccc // <1>
now time is: 2019-01-02 17:59:10:935
Not read data: 2019-01-02 17:59:10:981 // <2>
æ”¶åˆ°idä¸º1810132623  2019-01-02 17:59:11: ç¬¬1æ¡æ¶ˆæ¯: bbb
now time is: 2019-01-02 17:59:11:935
Not read data: 2019-01-02 17:59:12:470
now time is: 2019-01-02 17:59:12:935
idä¸º1810132623çš„Clientsocket 2019-01-02 17:59:13:191è¯»å–ç»“æŸ
now time is: 2019-01-02 17:59:13:935
idä¸º1810132623çš„Clientsocket 2019-01-02 17:59:14:192è¯»å–ç»“æŸ
```
 å…¶ä¸­ï¼ŒNot read dataè¾“å‡ºéƒ¨åˆ†è§£å†³äº†æˆ‘ä»¬çš„readé˜»å¡é—®é¢˜ï¼Œæ¯éš”1sä¼šå»å”¤é†’æˆ‘ä»¬çš„readæ“ä½œï¼Œå¦‚æœåœ¨1så†…æ²¡æœ‰è¯»åˆ°æ•°æ®çš„è¯å°±ä¼šæ‰§è¡Œ`System.out.println("Not read data: " + stringNowTime())`ï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬å°±å¯ä»¥è¿›è¡Œä¸€äº›å…¶ä»–æ“ä½œäº†ï¼Œé¿å…äº†é˜»å¡ä¸­å½“å‰çº¿ç¨‹çš„ç°è±¡ï¼Œå½“æˆ‘ä»¬æœ‰æ•°æ®å‘é€ä¹‹åï¼Œå°±æœ‰äº†<1>å¤„çš„è¾“å‡ºäº†ï¼Œå› ä¸ºreadå¾—åˆ°è¾“å‡ºï¼Œæ‰€ä»¥ä¸å†æ‰§è¡Œcatchè¯­å¥éƒ¨åˆ†ï¼Œå› æ­¤ä½ ä¼šå‘ç°<2>å¤„è¾“å‡ºæ—¶é—´æ˜¯å’Œ<1>å¤„çš„æ—¶é—´ç›¸å·®1sè€Œä¸æ˜¯å’Œä¹‹å‰çš„17:59:09:936ç›¸å·®ä¸€ç§’ï¼›

Â Â  è¿™æ ·çš„è¯ï¼Œæˆ‘ä»¬å°±è§£å†³äº†acceptä»¥åŠreadå¸¦æ¥çš„é˜»å¡é—®é¢˜äº†ï¼ŒåŒæ—¶åœ¨æœåŠ¡ç«¯ä¸ºæ¯ä¸€ä¸ªå®¢æˆ·ç«¯éƒ½åˆ›å»ºäº†ä¸€ä¸ªçº¿ç¨‹æ¥å¤„ç†å„è‡ªçš„ä¸šåŠ¡é€»è¾‘ï¼Œè¿™ç‚¹å…¶å®åŸºæœ¬ä¸Šå·²ç»è§£å†³äº†é˜»å¡é—®é¢˜äº†ï¼Œæˆ‘ä»¬å¯ä»¥ç†è§£æˆæ˜¯æœ€åˆç‰ˆçš„NIOï¼Œä½†æ˜¯ï¼Œä¸ºæ¯ä¸ªå®¢æˆ·ç«¯éƒ½åˆ›å»ºä¸€ä¸ªçº¿ç¨‹è¿™ç‚¹ç¡®å®è®©äººå¤´ç–¼çš„ï¼Œç‰¹åˆ«æ˜¯å®¢æˆ·ç«¯å¤šäº†çš„è¯ï¼Œå¾ˆæµªè´¹æœåŠ¡å™¨èµ„æºï¼Œå†åŠ ä¸Šçº¿ç¨‹ä¹‹é—´çš„åˆ‡æ¢å¼€é”€ï¼Œæ›´æ˜¯é›ªä¸ŠåŠ éœœï¼Œå³ä½¿ä½ å¼•å…¥äº†çº¿ç¨‹æ± æŠ€æœ¯æ¥æ§åˆ¶çº¿ç¨‹çš„ä¸ªæ•°ï¼Œä½†æ˜¯å½“å®¢æˆ·ç«¯å¤šèµ·æ¥çš„æ—¶å€™ä¼šå¯¼è‡´çº¿ç¨‹æ± çš„BlockingQueueé˜Ÿåˆ—è¶Šæ¥è¶Šå¤§ï¼Œé‚£ä¹ˆï¼Œè¿™æ—¶å€™çš„NIOå°±å¯ä»¥ä¸ºæˆ‘ä»¬è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå®ƒå¹¶ä¸ä¼šä¸ºæ¯ä¸ªå®¢æˆ·ç«¯éƒ½åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ï¼Œåœ¨æœåŠ¡ç«¯åªæœ‰ä¸€ä¸ªçº¿ç¨‹ï¼Œä¼šä¸ºæ¯ä¸ªå®¢æˆ·ç«¯åˆ›å»ºä¸€ä¸ªé€šé“ã€‚

# å¯¹accept()ä¸€äº›ä»£ç æ³¨æ„ç‚¹çš„æ€è€ƒ

accept()æœ¬åœ°æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥æ¥è¯•ç€çœ‹ä¸€çœ‹Linuxè¿™å—çš„ç›¸å…³è§£è¯»ï¼š
``` c
#include <sys/types.h>

#include <sys/socket.h>

int accept(int sockfd,struct sockaddr *addr,socklen_t *addrlen);
```
accept()ç³»ç»Ÿè°ƒç”¨ä¸»è¦ç”¨åœ¨åŸºäºè¿æ¥çš„å¥—æ¥å­—ç±»å‹ï¼Œæ¯”å¦‚SOCK_STREAMå’ŒSOCK_SEQPACKETã€‚å®ƒæå–å‡ºæ‰€ç›‘å¬å¥—æ¥å­—çš„ç­‰å¾…è¿æ¥é˜Ÿåˆ—ä¸­ç¬¬ä¸€ä¸ªè¿æ¥è¯·æ±‚ï¼Œ**åˆ›å»ºä¸€ä¸ªæ–°çš„å¥—æ¥å­—**ï¼Œå¹¶è¿”å›æŒ‡å‘è¯¥å¥—æ¥å­—çš„æ–‡ä»¶æè¿°ç¬¦ã€‚æ–°å»ºç«‹çš„å¥—æ¥å­—ä¸åœ¨ç›‘å¬çŠ¶æ€ï¼ŒåŸæ¥æ‰€ç›‘å¬çš„å¥—æ¥å­—ä¹Ÿä¸å—è¯¥ç³»ç»Ÿè°ƒç”¨çš„å½±å“ã€‚

**å¤‡æ³¨ï¼šæ–°å»ºç«‹çš„å¥—æ¥å­—å‡†å¤‡å‘é€send()å’Œæ¥æ”¶æ•°æ®recv()ã€‚**

å‚æ•°ï¼š

sockfd,    åˆ©ç”¨ç³»ç»Ÿè°ƒç”¨socket()å»ºç«‹çš„å¥—æ¥å­—æè¿°ç¬¦ï¼Œé€šè¿‡bind()ç»‘å®šåˆ°ä¸€ä¸ªæœ¬åœ°åœ°å€(ä¸€èˆ¬ä¸ºæœåŠ¡å™¨çš„å¥—æ¥å­—)ï¼Œå¹¶ä¸”é€šè¿‡listen()ä¸€ç›´åœ¨ç›‘å¬è¿æ¥ï¼›

addr,    æŒ‡å‘struct sockaddrçš„æŒ‡é’ˆï¼Œè¯¥ç»“æ„ç”¨é€šè®¯å±‚æœåŠ¡å™¨å¯¹ç­‰å¥—æ¥å­—çš„åœ°å€(ä¸€èˆ¬ä¸ºå®¢æˆ·ç«¯åœ°å€)å¡«å†™ï¼Œè¿”å›åœ°å€addrçš„ç¡®åˆ‡æ ¼å¼ç”±å¥—æ¥å­—çš„åœ°å€ç±»åˆ«(æ¯”å¦‚TCPæˆ–UDP)å†³å®šï¼›è‹¥addrä¸ºNULLï¼Œæ²¡æœ‰æœ‰æ•ˆåœ°å€å¡«å†™ï¼Œè¿™ç§æƒ…å†µä¸‹ï¼Œaddrlenä¹Ÿä¸ä½¿ç”¨ï¼Œåº”è¯¥ç½®ä¸ºNULLï¼›

**å¤‡æ³¨ï¼šaddræ˜¯ä¸ªæŒ‡å‘å±€éƒ¨æ•°æ®ç»“æ„sockaddr_inçš„æŒ‡é’ˆï¼Œè¿™å°±æ˜¯è¦æ±‚æ¥å…¥çš„ä¿¡æ¯æœ¬åœ°çš„å¥—æ¥å­—(åœ°å€å’ŒæŒ‡é’ˆ)ã€‚**

addrlen,    ä¸€ä¸ªå€¼ç»“æœå‚æ•°ï¼Œè°ƒç”¨å‡½æ•°å¿…é¡»åˆå§‹åŒ–ä¸ºåŒ…å«addræ‰€æŒ‡å‘ç»“æ„å¤§å°çš„æ•°å€¼ï¼Œå‡½æ•°è¿”å›æ—¶åŒ…å«å¯¹ç­‰åœ°å€(ä¸€èˆ¬ä¸ºæœåŠ¡å™¨åœ°å€)çš„å®é™…æ•°å€¼ï¼›

**å¤‡æ³¨ï¼šaddrlenæ˜¯ä¸ªå±€éƒ¨æ•´å½¢å˜é‡ï¼Œè®¾ç½®ä¸ºsizeof(struct   sockaddr_in)ã€‚**

å¦‚æœé˜Ÿåˆ—ä¸­æ²¡æœ‰ç­‰å¾…çš„è¿æ¥ï¼Œå¥—æ¥å­—ä¹Ÿæ²¡æœ‰è¢«æ ‡è®°ä¸ºNon-blockingï¼Œaccept()ä¼šé˜»å¡è°ƒç”¨å‡½æ•°ç›´åˆ°è¿æ¥å‡ºç°ï¼›å¦‚æœå¥—æ¥å­—è¢«æ ‡è®°ä¸ºNon-blockingï¼Œé˜Ÿåˆ—ä¸­ä¹Ÿæ²¡æœ‰ç­‰å¾…çš„è¿æ¥ï¼Œaccept()è¿”å›é”™è¯¯EAGAINæˆ–EWOULDBLOCKã€‚

**å¤‡æ³¨ï¼šä¸€èˆ¬æ¥è¯´ï¼Œå®ç°æ—¶accept()ä¸ºé˜»å¡å‡½æ•°ï¼Œå½“ç›‘å¬socketè°ƒç”¨accept()æ—¶ï¼Œå®ƒå…ˆåˆ°è‡ªå·±çš„receive_bufä¸­æŸ¥çœ‹æ˜¯å¦æœ‰è¿æ¥æ•°æ®åŒ…ï¼›è‹¥æœ‰ï¼ŒæŠŠæ•°æ®æ‹·è´å‡ºæ¥ï¼Œåˆ æ‰æ¥æ”¶åˆ°çš„æ•°æ®åŒ…ï¼Œåˆ›å»ºæ–°çš„socketä¸å®¢æˆ·å‘æ¥çš„åœ°å€å»ºç«‹è¿æ¥ï¼›è‹¥æ²¡æœ‰ï¼Œå°±é˜»å¡ç­‰å¾…ï¼›**

ä¸ºäº†åœ¨å¥—æ¥å­—ä¸­æœ‰åˆ°æ¥çš„è¿æ¥æ—¶å¾—åˆ°é€šçŸ¥ï¼Œå¯ä»¥ä½¿ç”¨**select()**æˆ–**poll()**ã€‚å½“å°è¯•å»ºç«‹æ–°è¿æ¥æ—¶ï¼Œç³»ç»Ÿå‘é€ä¸€ä¸ªå¯è¯»äº‹ä»¶ï¼Œç„¶åè°ƒç”¨accept()ä¸ºè¯¥è¿æ¥è·å–å¥—æ¥å­—ã€‚å¦ä¸€ç§æ–¹æ³•æ˜¯ï¼Œå½“å¥—æ¥å­—ä¸­æœ‰è¿æ¥åˆ°æ¥æ—¶è®¾å®šå¥—æ¥å­—å‘é€SIGIOä¿¡å·ã€‚

è¿”å›å€¼
æˆåŠŸæ—¶ï¼Œè¿”å›éè´Ÿæ•´æ•°ï¼Œè¯¥æ•´æ•°æ˜¯æ¥æ”¶åˆ°å¥—æ¥å­—çš„æè¿°ç¬¦ï¼›å‡ºé”™æ—¶ï¼Œè¿”å›ï¼1ï¼Œç›¸åº”åœ°è®¾å®šå…¨å±€å˜é‡errnoã€‚

æ‰€ä»¥ï¼Œæˆ‘ä»¬åœ¨æˆ‘ä»¬çš„Javaéƒ¨åˆ†çš„æºç é‡Œ(**java.net.ServerSocket#accept**)ä¼šnew ä¸€ä¸ªSocketå‡ºæ¥ï¼Œæ–¹ä¾¿è¿æ¥åæ‹¿åˆ°çš„æ–°Socketçš„æ–‡ä»¶æè¿°ç¬¦çš„ä¿¡æ¯ç»™è®¾å®šåˆ°æˆ‘ä»¬newå‡ºæ¥çš„è¿™ä¸ªSocketä¸Šæ¥ï¼Œè¿™ç‚¹åœ¨`java.net.PlainSocketImpl#socketAccept`ä¸­çœ‹åˆ°çš„å°¤ä¸ºæ˜æ˜¾ï¼Œè¯»è€…å¯ä»¥å›é¡¾ç›¸å…³æºç ã€‚