title: ã€è¿½å…‰è€…ç³»åˆ—ã€‘HikariCP è¿æ¥æ± å¤§å°å¤šå¤§åˆé€‚ï¼Ÿï¼ˆç¬¬äºŒå¼¹ï¼‰
date: 2018-01-10
tags:
categories: HikariCP
permalink: HikariCP/zhazhawangzi/how-big-should-size-be-2
author: æ¸£æ¸£ç‹å­
from_url: https://mp.weixin.qq.com/s/IgumHSMFvR4TxcuZn01L6w
wechat_url:

-------

æ‘˜è¦: åŸåˆ›å‡ºå¤„ https://mp.weixin.qq.com/s/IgumHSMFvR4TxcuZn01L6w ã€Œæ¸£æ¸£ç‹å­ã€æ¬¢è¿è½¬è½½ï¼Œä¿ç•™æ‘˜è¦ï¼Œè°¢è°¢ï¼

- [fixed pool design](http://www.iocoder.cn/HikariCP/zhazhawangzi/how-big-should-size-be-2/)
- [How to set minimumIdle](http://www.iocoder.cn/HikariCP/zhazhawangzi/how-big-should-size-be-2/)
- [å‚è€ƒèµ„æ–™](http://www.iocoder.cn/HikariCP/zhazhawangzi/how-big-should-size-be-2/)

-------

![](http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg)

> ğŸ™‚ğŸ™‚ğŸ™‚å…³æ³¨**å¾®ä¿¡å…¬ä¼—å·ï¼šã€èŠ‹é“æºç ã€‘**æœ‰ç¦åˆ©ï¼š
> 1. RocketMQ / MyCAT / Sharding-JDBC **æ‰€æœ‰**æºç åˆ†ææ–‡ç« åˆ—è¡¨
> 2. RocketMQ / MyCAT / Sharding-JDBC **ä¸­æ–‡æ³¨é‡Šæºç  GitHub åœ°å€**
> 3. æ‚¨å¯¹äºæºç çš„ç–‘é—®æ¯æ¡ç•™è¨€**éƒ½**å°†å¾—åˆ°**è®¤çœŸ**å›å¤ã€‚**ç”šè‡³ä¸çŸ¥é“å¦‚ä½•è¯»æºç ä¹Ÿå¯ä»¥è¯·æ•™å™¢**ã€‚
> 4. **æ–°çš„**æºç è§£ææ–‡ç« **å®æ—¶**æ”¶åˆ°é€šçŸ¥ã€‚**æ¯å‘¨æ›´æ–°ä¸€ç¯‡å·¦å³**ã€‚
> 5. **è®¤çœŸçš„**æºç äº¤æµå¾®ä¿¡ç¾¤ã€‚

-------

é¦–å…ˆæ¨èå¤§å®¶å¯ä»¥çœ‹ä¸€ä¸‹ [ã€è¿½å…‰è€…ç³»åˆ—ã€‘Hikariè¿æ¥æ± é…å¤šå¤§åˆé€‚ï¼Ÿ](http://mp.weixin.qq.com/s?__biz=MzUzNTY4NTYxMA==&mid=2247483731&idx=1&sn=b81013c6af5e6e62d5ac8d8a26e2b848&chksm=fa80f1d6cdf778c03aec5b9db0e539b5ad0efae471324a8735828762998b6703a8bb8b226ac4&scene=21#wechat_redirect)



# fixed pool design

åœ¨å¯åŠ¨æ—¶ï¼ŒHikariCPä½¿ç”¨é…ç½®çš„æœ€å¤§è¿æ¥æ•°maximumPoolSizeå¡«å……æ± ï¼Œå¹¶åœ¨æ± çš„ä½¿ç”¨æœŸé™å†…ç»´æŠ¤å®ƒä»¬ã€‚è¿™å¯ä»¥åœ¨com.zaxxer.hikari.pool.HikariPoolçš„HouseKeeperé‡Œçœ‹åˆ°ï¼Œè¿™ä¸ªtaskåœ¨ç¬¬ä¸€æ¬¡æ‰§è¡Œçš„æ—¶å€™ï¼Œç›´æ¥æ‰§è¡ŒfillPoolã€‚

```Java
/**
    * The house keeping task to retire and maintain minimum idle connections.
    */
   private final class HouseKeeper implements Runnable
   {
      private volatile long previous = plusMillis(currentTime(), -HOUSEKEEPING_PERIOD_MS);
      @Override
      public void run()
      {
         try {
            // refresh timeouts in case they changed via MBean
            connectionTimeout = config.getConnectionTimeout();
            validationTimeout = config.getValidationTimeout();
            leakTaskFactory.updateLeakDetectionThreshold(config.getLeakDetectionThreshold());
            final long idleTimeout = config.getIdleTimeout();
            final long now = currentTime();
            // Detect retrograde time, allowing +128ms as per NTP spec.
            if (plusMillis(now, 128) < plusMillis(previous, HOUSEKEEPING_PERIOD_MS)) {
               LOGGER.warn("{} - Retrograde clock change detected (housekeeper delta={}), soft-evicting connections from pool.",
                           poolName, elapsedDisplayString(previous, now));
               previous = now;
               softEvictConnections();
               return;
            }
            else if (now > plusMillis(previous, (3 * HOUSEKEEPING_PERIOD_MS) / 2)) {
               // No point evicting for forward clock motion, this merely accelerates connection retirement anyway
               LOGGER.warn("{} - Thread starvation or clock leap detected (housekeeper delta={}).", poolName, elapsedDisplayString(previous, now));
            }
            previous = now;
            String afterPrefix = "Pool ";
            if (idleTimeout > 0L && config.getMinimumIdle() < config.getMaximumPoolSize()) {
               logPoolState("Before cleanup ");
               afterPrefix = "After cleanup  ";
               final List<PoolEntry> notInUse = connectionBag.values(STATE_NOT_IN_USE);
               int toRemove = notInUse.size() - config.getMinimumIdle();
               for (PoolEntry entry : notInUse) {
                  if (toRemove > 0 && elapsedMillis(entry.lastAccessed, now) > idleTimeout && connectionBag.reserve(entry)) {
                     closeConnection(entry, "(connection has passed idleTimeout)");
                     toRemove--;
                  }
               }
            }
            logPoolState(afterPrefix);
            fillPool(); // Try to maintain minimum connections
         }
         catch (Exception e) {
            LOGGER.error("Unexpected exception in housekeeping task", e);
         }
      }
   }
```

fillPoolï¼Œåœ¨åˆå§‹åŒ–æ—¶åˆ»ï¼ŒminimumIdleä¸maximumPoolSizeå€¼ä¸€æ ·ï¼ŒtotalConnectionsä¸idleConnectionséƒ½ä¸º0ï¼Œé‚£ä¹ˆconnectionsToAddçš„å€¼å°±æ˜¯maximumPoolSizeï¼Œä¹Ÿå°±æ˜¯è¯´è¿™ä¸ªtaskä¼šæ·»åŠ maximumPoolSizeå¤§å°è¿æ¥ã€‚

```Java
  /**
    * Fill pool up from current idle connections (as they are perceived at the point of execution) to minimumIdle connections.
    */
   private synchronized void fillPool()
   {
      final int connectionsToAdd = Math.min(config.getMaximumPoolSize() - getTotalConnections(), config.getMinimumIdle() - getIdleConnections())
                                   - addConnectionQueue.size();
      for (int i = 0; i < connectionsToAdd; i++) {
         addConnectionExecutor.submit((i < connectionsToAdd - 1) ? POOL_ENTRY_CREATOR : POST_FILL_POOL_ENTRY_CREATOR);
      }
   }
```

ä½œè€…ä¸æ¨èä½¿ç”¨minimumIdleï¼Œè¯¥å±æ€§æ§åˆ¶HikariCPå°è¯•åœ¨æ± ä¸­ç»´æŠ¤çš„æœ€å°ç©ºé—²è¿æ¥æ•°ã€‚å¦‚æœç©ºé—²è¿æ¥ä½äºæ­¤å€¼å¹¶ä¸”æ± ä¸­çš„æ€»è¿æ¥æ•°å°‘äºmaximumPoolSizeï¼ŒHikariCPå°†å°½æœ€å¤§åŠªåŠ›å¿«é€Ÿé«˜æ•ˆåœ°æ·»åŠ å…¶ä»–è¿æ¥ã€‚ä½†æ˜¯ï¼Œä¸ºäº†è·å¾—æœ€ä½³æ€§èƒ½å’Œå“åº”å°–å³°éœ€æ±‚ï¼Œæˆ‘ä»¬å»ºè®®ä¸è¦è®¾ç½®æ­¤å€¼ï¼Œè€Œæ˜¯å…è®¸HikariCPå……å½“å›ºå®šå¤§å°çš„è¿æ¥æ± ã€‚ é»˜è®¤å€¼ï¼šä¸maximumPoolSizeç›¸åŒ

> **maximumPoolSize**
> This property controls the maximum size that the pool is allowed to reach, including both idle and in-use connections. Basically this value will determine the maximum number of actual connections to the database backend. A reasonable value for this is best determined by your execution environment. When the pool reaches this size, and no idle connections are available, calls to getConnection() will block for up to connectionTimeout milliseconds before timing out. Please read about pool sizing. Default: 10

æ­¤å±æ€§æ§åˆ¶æ± å…è®¸è¾¾åˆ°çš„æœ€å¤§å¤§å°ï¼ŒåŒ…æ‹¬ç©ºé—²å’Œæ­£åœ¨ä½¿ç”¨çš„è¿æ¥ã€‚åŸºæœ¬ä¸Šè¿™ä¸ªå€¼å°†å†³å®šåˆ°æ•°æ®åº“åç«¯çš„æœ€å¤§å®é™…è¿æ¥æ•°ã€‚å¯¹æ­¤çš„åˆç†ä»·å€¼æœ€å¥½ç”±æ‚¨çš„æ‰§è¡Œç¯å¢ƒå†³å®šã€‚å½“æ± è¾¾åˆ°æ­¤å¤§å°å¹¶ä¸”æ²¡æœ‰å¯ç”¨çš„ç©ºé—²è¿æ¥æ—¶ï¼Œå¯¹getConnectionï¼ˆï¼‰çš„è°ƒç”¨å°†connectionTimeoutåœ¨è¶…æ—¶å‰é˜»å¡è¾¾å‡ æ¯«ç§’ã€‚ é»˜è®¤å€¼ï¼š10

> **minimumIdle**
> This property controls the minimum number of idle connections that HikariCP tries to maintain in the pool. If the idle connections dip below this value and total connections in the pool are less than maximumPoolSize, HikariCP will make a best effort to add additional connections quickly and efficiently. However, for maximum performance and responsiveness to spike demands, we recommend not setting this value and instead allowing HikariCP to act as a fixed size connection pool. Default: same as maximumPoolSize

è¯¥å±æ€§æ§åˆ¶HikariCPå°è¯•åœ¨æ± ä¸­ç»´æŠ¤çš„æœ€å°ç©ºé—²è¿æ¥æ•°ã€‚å¦‚æœç©ºé—²è¿æ¥ä½äºæ­¤å€¼å¹¶ä¸”æ± ä¸­çš„æ€»è¿æ¥æ•°å°‘äºmaximumPoolSizeï¼ŒHikariCPå°†å°½æœ€å¤§åŠªåŠ›å¿«é€Ÿé«˜æ•ˆåœ°æ·»åŠ å…¶ä»–è¿æ¥ã€‚ä½†æ˜¯ï¼Œä¸ºäº†è·å¾—æœ€ä½³æ€§èƒ½å’Œå“åº”å°–å³°éœ€æ±‚ï¼Œæˆ‘ä»¬å»ºè®®ä¸è¦è®¾ç½®æ­¤å€¼ï¼Œè€Œæ˜¯å…è®¸HikariCPå……å½“å›ºå®šå¤§å°çš„è¿æ¥æ± ã€‚ é»˜è®¤å€¼ï¼šä¸maximumPoolSizeç›¸åŒ

ä½œè€…è®¤ä¸ºå¦‚æœminimumIdleå°äºmaximumPoolSizeçš„è¯ï¼Œåœ¨æµé‡æ¿€å¢çš„æ—¶å€™éœ€è¦é¢å¤–çš„è¿æ¥ï¼Œæ­¤æ—¶åœ¨è¯·æ±‚æ–¹æ³•é‡Œå¤´å†å»å¤„ç†æ–°å»ºè¿æ¥ä¼šé€ æˆæ€§èƒ½æŸå¤±ï¼Œå³ä¼šå¯¼è‡´æ•°æ®åº“ä¸€æ–¹é¢é™ä½è¿æ¥å»ºç«‹çš„é€Ÿåº¦ï¼Œå¦ä¸€æ–¹é¢ä¹Ÿä¼šå½±å“æ—¢æœ‰çš„è¿æ¥äº‹åŠ¡çš„å®Œæˆï¼Œé—´æ¥å½±å“äº†è¿™äº›æ—¢æœ‰è¿æ¥å½’è¿˜åˆ°è¿æ¥æ± çš„é€Ÿåº¦ã€‚
ä½œè€…è®¤ä¸ºminimumIdleä¸maximumPoolSizeè®¾ç½®æˆä¸€æ ·ï¼Œå¤šä½™çš„ç©ºé—²è¿æ¥ä¸ä¼šå¯¹æ•´ä½“çš„æ€§èƒ½æœ‰ä»€ä¹ˆä¸¥é‡å½±å“ã€‚

ä½œè€…çš„å¦‚ä¸Šè§‚ç‚¹å¯ä»¥å‚è§ https://www.postgresql.org/message-id/1395487594923-5797135.post@n5.nabble.com

> And I didn't see a pool of a few dozen
> connections actually impacting performance much when half of them are idle
> and half are executing transactions (ie. the idle ones don't impact the
> overall performance much).

å…¨æ–‡å¦‚ä¸‹ï¼š

Speaking to David's pointâ€¦
Reaching the maxPoolSize from the minPoolSize means creating the connections at the crucial moment where the client application is in the desperate need of completing an important query/transaction which the primary responsibility since it cannot hold the data collected.

This was one of the reasons I was proposing the fixed pool design. In my
experience, even in pools that maintain a minimum number of idle
connections, responding to spike demands is problematic. If you have a pool
with say 30 max. connections, and a 10 minimum idle connection goal, a
sudden spike demand for 20 connections means the pool can satisfy 10
instantly but then is left to [try to] establish 10 connections before the
application's connectionTimeout (read acquisition timeout from the pool) is
reached. This in turn generates a spike demand on the database slowing down
not only the connection establishments themselves but also slowing down the
completion of transactions that might actually return connections to the
pool.

As I think Tom noted is a slidestack I read somewhere, there is a "knee" in
the performance curve beyond which additional connections cause a drop in
TPS. While users think it is a good idea to have 10 idle connections but a
maxPoolSize of 100, the reality is, they can retire/reuse connections faster
with a much smaller maxPoolSize. And I didn't see a pool of a few dozen
connections actually impacting performance much when half of them are idle
and half are executing transactions (ie. the idle ones don't impact the
overall performance much).

Finally, one of my contentions was, either your database server has
resources or it doesn't. Either it has enough memory and processing power
for N connections or it doesn't. If the pool is set below, near, or at that
capacity what is the purpose of releasing connections in that case? Yes, it
frees up memory, but that memory is not really available for other use given
that at any instant the maximum capacity of the pool may be demanded.
Instead releasing resources only to try to reallocate them during a demand
peak seems counter-productive.

-Brett

å½“ç„¶å¦‚æœä½ ä¸æƒ³ä½¿ç”¨ä½œè€…å¼ºçƒˆæ¨èçš„å»ºè®®ï¼ŒminimumIdleä¹Ÿæ˜¯å¯ä»¥è°ƒæ•´çš„ï¼Œä»¥æ§åˆ¶é—²ç½®æ—¶æ®µçš„è¿æ¥æ•°é‡ã€‚

HikariCPçš„åˆå§‹ç‰ˆæœ¬åªæ”¯æŒå›ºå®šå¤§å°çš„æ± ã€‚ä½œè€…åˆè¡·æ˜¯ï¼ŒHikariCPæ˜¯ä¸“é—¨ä¸ºå…·æœ‰ç›¸å½“æ’å®šè´Ÿè½½çš„ç³»ç»Ÿè€Œè®¾è®¡çš„ï¼Œå¹¶ä¸”åœ¨å€¾å‘è¿æ¥æ± å¤§å°äºä¿æŒå…¶è¿è¡Œæ—¶å…è®¸è¾¾åˆ°çš„æœ€å¤§å¤§å°ï¼Œæ‰€ä»¥ä½œè€…è®¤ä¸ºæ²¡æœ‰å¿…è¦å°†ä»£ç å¤æ‚åŒ–ä»¥æ”¯æŒåŠ¨æ€è°ƒæ•´å¤§å°ã€‚æ¯•ç«Ÿä½ çš„ç³»ç»Ÿä¼šé—²ç½®å¾ˆä¹…ä¹ˆï¼Ÿå¦å¤–ä½œè€…è®¤ä¸ºé…ç½®é¡¹è¶Šå¤šï¼Œç”¨æˆ·é…ç½®æ± çš„éš¾åº¦å°±è¶Šå¤§ã€‚ä½†æ˜¯å‘¢ï¼Œç¡®å®æœ‰ä¸€äº›ç”¨æˆ·éœ€è¦åŠ¨æ€è°ƒæ•´è¿æ¥æ± å¤§å°ï¼Œå¹¶ä¸”æ²¡æœ‰å°±ä¸è¡Œï¼Œæ‰€ä»¥ä½œè€…å°±å¢åŠ äº†è¿™ä¸ªåŠŸèƒ½ã€‚ä½†æ˜¯åŸåˆ™ä¸Šï¼Œä½œè€…å¹¶ä¸å¸Œæœ›ç¼ºä¹åŠ¨æ€çš„å¤§å°æ”¯æŒä¼šå‰¥å¤ºç”¨æˆ·äº«å—HikariCPçš„å¯é æ€§å’Œæ­£ç¡®æ€§çš„å¥½å¤„ã€‚

å°ç»“ä¸€ä¸‹å°±æ˜¯ï¼ŒminIdleæ¥æŒ‡å®šç©ºé—²è¿æ¥çš„æœ€å°æ•°é‡ï¼ŒmaxPoolSizeæŒ‡å®šè¿æ¥æ± è¿æ¥æœ€å¤§å€¼ï¼Œé»˜è®¤åˆå§‹åŒ–çš„æ—¶å€™ï¼Œæ˜¯åˆå§‹åŒ–minIdleå¤§å°çš„è¿æ¥ï¼Œå¦‚æœminIdleä¸maxPoolSizeå€¼ç›¸ç­‰é‚£å°±æ˜¯åˆå§‹åŒ–æ—¶æŠŠè¿æ¥æ± å¡«æ»¡ã€‚idleTimeoutç”¨æ¥æŒ‡å®šç©ºé—²è¿æ¥çš„æ—¶é•¿ï¼ŒmaxLifetimeç”¨æ¥æŒ‡å®šæ‰€æœ‰è¿æ¥çš„æ—¶é•¿ã€‚com.zaxxer.hikari.housekeeping.periodMsç”¨æ¥æŒ‡å®šè¿æ¥æ± ç©ºé—²è¿æ¥å¤„ç†åŠè¿æ¥æ± æ•°è¡¥å……çš„HouseKeeperä»»åŠ¡çš„è°ƒåº¦æ—¶é—´é—´éš”ã€‚æ‰€æœ‰çš„è¿æ¥åœ¨maxLifetimeä¹‹åéƒ½å¾—é‡è¿ä¸€æ¬¡ï¼Œä¿è¯è¿æ¥æ± çš„æ´»æ€§ã€‚

# How to set minimumIdle

ç”¨æˆ·çš„åœºæ™¯å¦‚ä¸‹æ‰€ç¤ºï¼š

I have three nodes + one backup node of my application. And all of them i configured to use 20 connections in the pool. To maintain 4 nodes i need 20*4 = 60 connections. When all 4 nodes are enabled in production then only 5-6 connection needed (for node), but if some nodes are down for maintenance then count of required connection grows. But most of time all nodes are active and we have 35 idle connection. We use pg_pool which configured to share connections between clients, and this 35 connection can`t be shared to other clients (other apps) because they are stay in Hikari pool.

Only using minimumIdle can solve this problem? Is there any recommended value for this option?

è¿˜è®°å¾— [ã€è¿½å…‰è€…ç³»åˆ—ã€‘Hikariè¿æ¥æ± é…å¤šå¤§åˆé€‚ï¼Ÿ](http://mp.weixin.qq.com/s?__biz=MzUzNTY4NTYxMA==&mid=2247483731&idx=1&sn=b81013c6af5e6e62d5ac8d8a26e2b848&chksm=fa80f1d6cdf778c03aec5b9db0e539b5ad0efae471324a8735828762998b6703a8bb8b226ac4&scene=21#wechat_redirect) ç¬¬ä¸€ç¯‡æåŠçš„æˆ‘ä»¬å…¬å¸çš„é»˜è®¤é…ç½®

```Java
maximumPoolSize: 20
minimumIdle: 10
```

é’ˆå¯¹è¿™ä¸ªé—®é¢˜ï¼Œä½œè€…æ˜¯è¿™ä¹ˆå›å¤çš„ï¼š

Do you have "spike" demands in traffic? For example, a node normally needs 5-6 connections but sometimes needs 10-15 quickly?

If you don't have spike demands:

If you have 3 active nodes (and 1 backup), and in production each node normally needs 5-6 connections, possibly set maximumPoolSize to 20, minimumIdle to 2, and idleTimeout to something like 2 minutes (120000ms).

If you do have moderate spike demands:

Try maximumPoolSize at 20, minimumIdle at 5-10, and again idleTimeout of something like 2 minutes (120000ms).

ç”¨æˆ·ç°è±¡è¿›ä¸€æ­¥æè¿°ï¼š

```
In our current configuration maximum connections in pg_pool is setted to 860 (we have ~15 applications). We have "spike" demands in traffic in rush hours. If we set idleTimeout (to 2 minutes) then connection count will grow on requests or it will fall to actual count after 2 minutes? Can we use "overselling"? Can sum of maximumPoolSize be bigger then max connections in pg_pool?
When client makes request a connection and all connections are busy then does hikari immediately increase pool size if he can? Is there any option that configures time delay before establishing new connection to database?
```

è¿™é‡Œä½œè€…è§£é‡Šäº†idleTimeoutçš„ç”¨å¤„ï¼ŒThe only thing idleTimeout helps with is reducing the pool size after a higher demand load.

> **idleTimeout**
> This property controls the maximum amount of time that a connection is allowed to sit idle in the pool. This setting only applies when minimumIdle is defined to be less than maximumPoolSize. Idle connections will not be retired once the pool reaches minimumIdle connections. Whether a connection is retired as idle or not is subject to a maximum variation of +30 seconds, and average variation of +15 seconds. A connection will never be retired as idle before this timeout. A value of 0 means that idle connections are never removed from the pool. The minimum allowed value is 10000ms (10 seconds). Default: 600000 (10 minutes)

é»˜è®¤æ˜¯600000æ¯«ç§’ï¼Œå³10åˆ†é’Ÿã€‚å¦‚æœidleTimeout+1ç§’>maxLifetime ä¸” maxLifetime>0ï¼Œåˆ™ä¼šè¢«é‡ç½®ä¸º0ï¼›å¦‚æœidleTimeout!=0ä¸”å°äº10ç§’ï¼Œåˆ™ä¼šè¢«é‡ç½®ä¸º10ç§’ã€‚å¦‚æœidleTimeout=0åˆ™è¡¨ç¤ºç©ºé—²çš„è¿æ¥åœ¨è¿æ¥æ± ä¸­æ°¸è¿œä¸è¢«ç§»é™¤ã€‚
åªæœ‰å½“minimumIdleå°äºmaximumPoolSizeæ—¶ï¼Œè¿™ä¸ªå‚æ•°æ‰ç”Ÿæ•ˆï¼Œå½“ç©ºé—²è¿æ¥æ•°è¶…è¿‡minimumIdleï¼Œè€Œä¸”ç©ºé—²æ—¶é—´è¶…è¿‡idleTimeoutï¼Œåˆ™ä¼šè¢«ç§»é™¤ã€‚

hikariå†…ç½®çš„HouseKeeperæ˜¯ä¸€ä¸ªå®šæ—¶ä»»åŠ¡ï¼Œåœ¨HikariPoolæ„é€ å™¨é‡Œå¤´åˆå§‹åŒ–ï¼Œé»˜è®¤çš„æ˜¯åˆå§‹åŒ–å100æ¯«ç§’æ‰§è¡Œï¼Œä¹‹åæ¯æ‰§è¡Œå®Œä¸€æ¬¡ä¹‹åéš”HOUSEKEEPING_PERIOD_MS(30ç§’)æ—¶é—´æ‰§è¡Œã€‚
è¿™ä¸ªå®šæ—¶ä»»åŠ¡çš„ä½œç”¨å°±æ˜¯æ ¹æ®idleTimeoutçš„å€¼ï¼Œç§»é™¤æ‰ç©ºé—²è¶…æ—¶çš„è¿æ¥ã€‚
é¦–å…ˆæ£€æµ‹æ—¶é’Ÿæ˜¯å¦å€’é€€ï¼Œå¦‚æœå€’é€€äº†åˆ™ç«‹å³å¯¹è¿‡æœŸçš„è¿æ¥è¿›è¡Œæ ‡è®°evictï¼›ä¹‹åå½“idleTimeout>0ä¸”é…ç½®çš„minimumIdle<maximumPoolSizeæ—¶æ‰å¼€å§‹å¤„ç†è¶…æ—¶çš„ç©ºé—²è¿æ¥ã€‚
å–å‡ºçŠ¶æ€æ˜¯STATE_NOT_IN_USEçš„è¿æ¥æ•°ï¼Œå¦‚æœå¤§äºminimumIdleï¼Œåˆ™éå†STATE_NOT_IN_USEçš„è¿æ¥çš„è¿æ¥ï¼Œå°†ç©ºé—²è¶…æ—¶è¾¾åˆ°idleTimeoutçš„è¿æ¥ä»connectionBagç§»é™¤æ‰ï¼Œè‹¥ç§»é™¤æˆåŠŸåˆ™å…³é—­è¯¥è¿æ¥ï¼Œç„¶åtoRemove--ã€‚
åœ¨ç©ºé—²è¿æ¥ç§»é™¤ä¹‹åï¼Œå†è°ƒç”¨fillPoolï¼Œå°è¯•è¡¥å……ç©ºé—´è¿æ¥æ•°åˆ°minimumIdleå€¼ã€‚

è€Œhikariçš„è¿æ¥æ³„éœ²æ˜¯æ¯æ¬¡getConnectionçš„æ—¶å€™å•ç‹¬è§¦å‘ä¸€ä¸ªå»¶æ—¶ä»»åŠ¡æ¥å¤„ç†ï¼Œè€Œç©ºé—²è¿æ¥çš„æ¸…é™¤åˆ™æ˜¯ä½¿ç”¨HouseKeeperå®šæ—¶ä»»åŠ¡æ¥å¤„ç†ï¼Œå…¶è¿è¡Œé—´éš”ç”±com.zaxxer.hikari.housekeeping.periodMsç¯å¢ƒå˜é‡æ§åˆ¶ï¼Œé»˜è®¤ä¸º30ç§’ã€‚

minimumIdleè¯•å›¾ç¡®ä¿minimumIdleæ± ä¸­è‡³å°‘æœ‰å¯ç”¨çš„è¿æ¥ã€‚æ± â€œè¡¥å……â€æ¯30ç§’å·¦å³å‘ç”Ÿä¸€æ¬¡ã€‚ï¼ˆæºç ä¸Šæ–‡æœ‰æåˆ°ï¼‰ï¼Œå¦‚æœåœ¨ â€œè¡¥å……â€è¿è¡Œçš„æ—¶åˆ»æ‰€æœ‰è¿æ¥éƒ½è¢«æ¶ˆè€—ï¼ˆ0ç©ºé—²è¿æ¥ï¼‰ï¼Œåˆ™è¡¥å……å°†æ·»åŠ 5ä¸ªæ–°è¿æ¥ã€‚å½“5ä¸ªæ´»åŠ¨è¿æ¥å…³é—­æ—¶ï¼Œæ± å°†æœ‰10ä¸ªç©ºé—²è¿æ¥ã€‚è¯¥idleTimeoutï¼ˆæˆ–maxLifetimeï¼‰å°†å…³é—­è¿æ¥ï¼Œå¹¶ä¸”æ± æœ€ç»ˆä¼šè¿”å›åˆ°5ä¸ªç©ºé—²è¿æ¥ã€‚
å¦‚æœå¸Œæœ›æ¸¸æ³³æ± è¿…é€Ÿæ”¶ç¼©ï¼Œè¯·è®¾ç½®idleTimeoutä¸º30ç§’ï¼Œå¹¶maxLifetimeç­‰å¾…1åˆ†é’Ÿã€‚

![img](http://static.iocoder.cn/mp/mmbiz_png/a5BAX19eYnUHWZAZYwHyfEFsXkPlBaeooQ8LGAyAaibqveyYp9dnQKZ9H5ISm8Z3JrLyXUUic8Ya6rqNibgR1MjLg/640)

ä½œè€…å®Œæ•´ç­”å¤å¦‚ä¸‹ï¼š

The only thing idleTimeout helps with is reducing the pool size after a higher demand load.

Imagine that you have a minimumIdle of 2, and a maximumPoolSize of 20. When the pool starts, and there are no client request, the pool will look like this:

```
Total: 2, Idle: 2, Active: 0
```

Now, if three requests come in concurrently:

- The 2 idle connections are immediately used
- A new connection is created to handle the third request
- And then 2 additional connections are created to satisfy a minimumIdle of 2 (but this is not instantaneous)

The pool would then (possibly) look like this:

```
Total: 5, Idle: 2, Active: 3
```

Immediately after the three requests are complete, the pool would like this:

```
Total: 5, Idle: 5, Active: 0
```

If idleTimeout is set to 2 minutes, assuming no activity, then after 2 minutes the pool would again look like the initial condition (Total: 2, Idle: 2, Active: 0).

Basically, minimumIdle tries to ensure that there are at least minimumIdle connections available in the pool. If minimumIdle is 5, the number of connections in an idle pool will be 5. "As soon as" a request comes in and consumes one of the connections, there is now only 4 idle connections, so the pool will try to add a new connection to bring the idle connection count back up to 5.

The good news is, this is not an instantaneous action. The pool "refill" occurs every 30 seconds or so. So, if there are 5 idle connections and a request comes in and consumes one of them, leaving 4 idle, if the request completes and the connection is returned before the "refill", the pool will again have 5 idle connections and will not grow.

The "bad news" is, if at the instant that the "refill" runs all connections are consumed (0 idle connections), then the refill will add 5 new connections. When the 5 active connections are closed, the pool will then have 10 idle connections. The idleTimeout (or maxLifetime) will close connections, and the pool will eventually return back to 5 idle connections.

If you want the pool to shrink quickly, set idleTimeout to 30 seconds, and maxLifetime to something like 1 minute.

Now, getting to "overselling". According to the pgpool documentation:

```
... pgpool-II also has a limit on the maximum number of connections, but extra connections will be queued instead of returning an error immediately.
```

This means you could configure the sum of the HikariCP maximumPoolSize to be higher than the pgpool maximum connection limit. With the understanding that HikariCP will still throw SQLExceptions to a client if getConnection() is called and cannot be satisfied within connectionTimeout. The connectionTimeout applied to getConnection() is decoupled from the creation of new connections, which occurs asynchronously, so even if pgpool connection attempts were timing out the error is not necessarily passed through to HikariCP clients (if Connections are being returned to the pool by other threads within the connectionTimeout period).

Does that make sense?

æœ€ç»ˆè¯¥ç”¨æˆ·çš„è¿æ¥æ± å‚æ•°è°ƒæ•´ä¸ºset maximumPoolSize to 20, minimumIdle to 5, and idleTimeout to 2 minutes.

# å‚è€ƒèµ„æ–™

https://segmentfault.com/a/1190000013164535
https://www.postgresql.org/message-id/1395487594923-5797135.post@n5.nabble.com
https://github.com/brettwooldridge/HikariCP/issues/256

# 666. å½©è›‹

å¦‚æœä½ å¯¹ HikariCP æ„Ÿå…´è¶£ï¼Œæ¬¢è¿åŠ å…¥æˆ‘çš„çŸ¥è¯†æ˜Ÿçƒä¸€èµ·äº¤æµã€‚

![çŸ¥è¯†æ˜Ÿçƒ](http://www.iocoder.cn/images/Architecture/2017_12_29/01.png)