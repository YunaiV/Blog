title: Eureka æºç è§£æ â€”â€” ä»»åŠ¡æ‰¹å¤„ç†
date: 2018-07-17
tags:
categories: Eureka
permalink: Eureka/batch-tasks
wechat_url: https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247484783&idx=2&sn=81bad9f38cc8cc3c58a6c1b1549d7da8&chksm=fa497adecd3ef3c8fa378861d48c59594d5452ae4f4d2ba3f0ec38f2615173573a0bd4ecc7bf#rd

---

æ‘˜è¦: åŸåˆ›å‡ºå¤„ http://www.iocoder.cn/Eureka/batch-tasks/ ã€ŒèŠ‹é“æºç ã€æ¬¢è¿è½¬è½½ï¼Œä¿ç•™æ‘˜è¦ï¼Œè°¢è°¢ï¼

**æœ¬æ–‡ä¸»è¦åŸºäº Eureka 1.8.X ç‰ˆæœ¬**

- [1. æ¦‚è¿°](http://www.iocoder.cn/Eureka/batch-tasks/)
- [2. æ•´ä½“æµç¨‹](http://www.iocoder.cn/Eureka/batch-tasks/)
- [3. ä»»åŠ¡å¤„ç†å™¨](http://www.iocoder.cn/Eureka/batch-tasks/)
- [4. åˆ›å»ºä»»åŠ¡åˆ†å‘å™¨](http://www.iocoder.cn/Eureka/batch-tasks/)
  - [4.1 æ‰¹é‡ä»»åŠ¡æ‰§è¡Œåˆ†å‘å™¨](http://www.iocoder.cn/Eureka/batch-tasks/)
  - [4.2 å•ä»»åŠ¡æ‰§è¡Œåˆ†å‘å™¨](http://www.iocoder.cn/Eureka/batch-tasks/)
- [5. åˆ›å»ºä»»åŠ¡æ¥æ”¶æ‰§è¡Œå™¨](http://www.iocoder.cn/Eureka/batch-tasks/)
- [6. åˆ›å»ºä»»åŠ¡æ‰§è¡Œå™¨](http://www.iocoder.cn/Eureka/batch-tasks/)
  - [6.1 åˆ›å»ºæ‰¹é‡ä»»åŠ¡æ‰§è¡Œå™¨](http://www.iocoder.cn/Eureka/batch-tasks/)
  - [6.2 åˆ›å»ºå•ä»»åŠ¡æ‰§è¡Œå™¨](http://www.iocoder.cn/Eureka/batch-tasks/)
  - [6.3 å·¥ä½œçº¿ç¨‹æŠ½è±¡ç±»](http://www.iocoder.cn/Eureka/batch-tasks/)
- [7. ç½‘ç»œé€šä¿¡æ•´å½¢å™¨](http://www.iocoder.cn/Eureka/batch-tasks/)
- [8. ä»»åŠ¡æ¥æ”¶æ‰§è¡Œå™¨ã€å¤„ç†ä»»åŠ¡ã€‘](http://www.iocoder.cn/Eureka/batch-tasks/)
- [9. ä»»åŠ¡æ¥æ”¶çº¿ç¨‹ã€è°ƒåº¦ä»»åŠ¡ã€‘](http://www.iocoder.cn/Eureka/batch-tasks/)
- [10. ä»»åŠ¡æ‰§è¡Œå™¨ã€æ‰§è¡Œä»»åŠ¡ã€‘](http://www.iocoder.cn/Eureka/batch-tasks/)
  - [10.1 æ‰¹é‡ä»»åŠ¡å·¥ä½œçº¿ç¨‹](http://www.iocoder.cn/Eureka/batch-tasks/)
  - [10.2 å•ä»»åŠ¡å·¥ä½œçº¿ç¨‹](http://www.iocoder.cn/Eureka/batch-tasks/)
- [666. å½©è›‹](http://www.iocoder.cn/Eureka/batch-tasks/)

---

![](http://www.iocoder.cn/images/common/wechat_mp_2018_05_18.jpg)

> ğŸ™‚ğŸ™‚ğŸ™‚å…³æ³¨**å¾®ä¿¡å…¬ä¼—å·ï¼šã€èŠ‹é“æºç ã€‘**æœ‰ç¦åˆ©ï¼š  
> 1. RocketMQ / MyCAT / Sharding-JDBC **æ‰€æœ‰**æºç åˆ†ææ–‡ç« åˆ—è¡¨  
> 2. RocketMQ / MyCAT / Sharding-JDBC **ä¸­æ–‡æ³¨é‡Šæºç  GitHub åœ°å€**  
> 3. æ‚¨å¯¹äºæºç çš„ç–‘é—®æ¯æ¡ç•™è¨€**éƒ½**å°†å¾—åˆ°**è®¤çœŸ**å›å¤ã€‚**ç”šè‡³ä¸çŸ¥é“å¦‚ä½•è¯»æºç ä¹Ÿå¯ä»¥è¯·æ•™å™¢**ã€‚  
> 4. **æ–°çš„**æºç è§£ææ–‡ç« **å®æ—¶**æ”¶åˆ°é€šçŸ¥ã€‚**æ¯å‘¨æ›´æ–°ä¸€ç¯‡å·¦å³**ã€‚  
> 5. **è®¤çœŸçš„**æºç äº¤æµå¾®ä¿¡ç¾¤ã€‚

---

# 1. æ¦‚è¿°

æœ¬æ–‡ä¸»è¦åˆ†äº« **ä»»åŠ¡æ‰¹å¤„ç†**ã€‚Eureka-Server é›†ç¾¤é€šè¿‡ä»»åŠ¡æ‰¹å¤„ç†åŒæ­¥åº”ç”¨å®ä¾‹æ³¨å†Œå®ä¾‹ï¼Œæ‰€ä»¥æœ¬æ–‡ä¹Ÿæ˜¯ä¸º Eureka-Server é›†ç¾¤åŒæ­¥çš„åˆ†äº«åšé“ºå«ã€‚

æœ¬æ–‡æ¶‰åŠç±»åœ¨ `com.netflix.eureka.util.batcher` åŒ…ä¸‹ï¼Œæ¶‰åŠåˆ°ä¸»ä½“ç±»çš„ç±»å›¾å¦‚ä¸‹( [æ‰“å¼€å¤§å›¾](http://www.iocoder.cn/images/Eureka/2018_07_17/02.png) )ï¼š

![](http://www.iocoder.cn/images/Eureka/2018_07_17/02.png)

* ç´«è‰²éƒ¨åˆ† â€”â€” ä»»åŠ¡åˆ†å‘å™¨
* è“è‰²éƒ¨åˆ† â€”â€” ä»»åŠ¡æ¥æ”¶å™¨
* çº¢è‰²éƒ¨åˆ† â€”â€” ä»»åŠ¡æ‰§è¡Œå™¨
* ç»¿è‰²éƒ¨åˆ† â€”â€” ä»»åŠ¡å¤„ç†å™¨
* é»„è‰²éƒ¨åˆ† â€”â€” ä»»åŠ¡æŒæœ‰è€…( ä»»åŠ¡ )

**æ¨è Spring Cloud ä¹¦ç±**ï¼š

* è¯·æ”¯æŒæ­£ç‰ˆã€‚ä¸‹è½½ç›—ç‰ˆï¼Œ**ç­‰äºä¸»åŠ¨ç¼–å†™ä½çº§ BUG** ã€‚
* ç¨‹åºçŒ¿DD â€”â€” [ã€ŠSpring Cloudå¾®æœåŠ¡å®æˆ˜ã€‹](https://union-click.jd.com/jdc?d=505Twi)
* å‘¨ç«‹ â€”â€” [ã€ŠSpring Cloudä¸Dockerå¾®æœåŠ¡æ¶æ„å®æˆ˜ã€‹](https://union-click.jd.com/jdc?d=k3sAaK)
* ä¸¤ä¹¦é½ä¹°ï¼Œäº¬ä¸œåŒ…é‚®ã€‚



# 2. æ•´ä½“æµç¨‹

ä»»åŠ¡æ‰§è¡Œçš„æ•´ä½“æµç¨‹å¦‚ä¸‹( [æ‰“å¼€å¤§å›¾](http://www.iocoder.cn/images/Eureka/2018_07_17/01.png) )ï¼š

![](http://www.iocoder.cn/images/Eureka/2018_07_17/01.png)

* ç»†ç®­å¤´ â€”â€” ä»»åŠ¡æ‰§è¡Œç»å†çš„æ“ä½œ
* ç²—ç®­å¤´ â€”â€” ä»»åŠ¡é˜Ÿåˆ—æµè½¬çš„æ–¹å‘
* **ä¸åŒäº**ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œä»»åŠ¡æäº¤äº†**ç«‹å³**åŒæ­¥æˆ–å¼‚æ­¥æ‰§è¡Œï¼Œä»»åŠ¡çš„æ‰§è¡Œæ‹†åˆ†äº†**ä¸‰å±‚é˜Ÿåˆ—**ï¼š

    * ç¬¬ä¸€å±‚ï¼Œæ¥æ”¶é˜Ÿåˆ—( `acceptorQueue` )ï¼Œé‡æ–°å¤„ç†é˜Ÿåˆ—( `reprocessQueue` )ã€‚
        * è“çº¿ï¼šåˆ†å‘å™¨åœ¨æ”¶åˆ°ä»»åŠ¡æ‰§è¡Œè¯·æ±‚åï¼Œæäº¤åˆ°æ¥æ”¶é˜Ÿåˆ—ï¼Œ**ä»»åŠ¡å®é™…æœªæ‰§è¡Œ**ã€‚
        * é»„çº¿ï¼šæ‰§è¡Œå™¨çš„å·¥ä½œçº¿ç¨‹å¤„ç†ä»»åŠ¡å¤±è´¥ï¼Œå°†ç¬¦åˆæ¡ä»¶( è§ [ã€Œ3. ä»»åŠ¡å¤„ç†å™¨ã€](#) )çš„å¤±è´¥ä»»åŠ¡æäº¤åˆ°é‡æ–°æ‰§è¡Œé˜Ÿåˆ—ã€‚
        
   * ç¬¬äºŒå±‚ï¼Œå¾…æ‰§è¡Œé˜Ÿåˆ—( `processingOrder` )
        * ç²‰çº¿ï¼šæ¥æ”¶çº¿ç¨‹( Runner )å°†é‡æ–°æ‰§è¡Œé˜Ÿåˆ—ï¼Œæ¥æ”¶é˜Ÿåˆ—æäº¤åˆ°å¾…æ‰§è¡Œé˜Ÿåˆ—ã€‚
        
   * ç¬¬ä¸‰å±‚ï¼Œå·¥ä½œé˜Ÿåˆ—( `workQueue` )
        * ç²‰çº¿ï¼šæ¥æ”¶çº¿ç¨‹( Runner )å°†å¾…æ‰§è¡Œé˜Ÿåˆ—çš„ä»»åŠ¡æ ¹æ®å‚æ•°( `maxBatchingSize` )å°†ä»»åŠ¡åˆå¹¶æˆ**æ‰¹é‡ä»»åŠ¡**ï¼Œè°ƒåº¦( æäº¤ )åˆ°å·¥ä½œé˜Ÿåˆ—ã€‚
        * é»„çº¿ï¼šæ‰§è¡Œå™¨çš„å·¥ä½œçº¿ç¨‹**æ± **ï¼Œä¸€ä¸ªå·¥ä½œçº¿ç¨‹å¯ä»¥æ‹‰å–ä¸€ä¸ª**æ‰¹é‡ä»»åŠ¡**è¿›è¡Œæ‰§è¡Œã€‚

* **ä¸‰å±‚é˜Ÿåˆ—çš„å¥½å¤„**ï¼š
    * æ¥æ”¶é˜Ÿåˆ—ï¼Œé¿å…å¤„ç†ä»»åŠ¡çš„é˜»å¡ç­‰å¾…ã€‚
    * æ¥æ”¶çº¿ç¨‹( Runner )åˆå¹¶ä»»åŠ¡ï¼Œå°†ç›¸åŒä»»åŠ¡ç¼–å·( **æ˜¯çš„ï¼Œä»»åŠ¡æ˜¯å¸¦æœ‰ç¼–å·çš„** )çš„ä»»åŠ¡åˆå¹¶ï¼Œåªæ‰§è¡Œä¸€æ¬¡ã€‚
    * Eureka-Server ä¸ºé›†ç¾¤åŒæ­¥æä¾›æ‰¹é‡æ“ä½œ**å¤šä¸ª**åº”ç”¨å®ä¾‹çš„**æ¥å£**ï¼Œä¸€ä¸ª**æ‰¹é‡ä»»åŠ¡**å¯ä»¥ä¸€æ¬¡è°ƒåº¦æ¥å£å®Œæˆï¼Œé¿å…å¤šæ¬¡è°ƒç”¨çš„å¼€é”€ã€‚å½“ç„¶ï¼Œè¿™æ ·åšçš„å‰ææ˜¯åˆå¹¶ä»»åŠ¡ï¼Œè¿™ä¹Ÿå¯¼è‡´ Eureka-Server é›†ç¾¤ä¹‹é—´å¯¹åº”ç”¨å®ä¾‹çš„æ³¨å†Œå’Œä¸‹çº¿å¸¦æ¥æ›´å¤§çš„å»¶è¿Ÿã€‚**æ¯•ç«Ÿï¼ŒEureka æ˜¯åœ¨ CAP ä¹‹é—´ï¼Œé€‰æ‹©äº† AP**ã€‚

# 3. ä»»åŠ¡å¤„ç†å™¨

`com.netflix.eureka.util.batcher.TaskProcessor` ï¼Œä»»åŠ¡å¤„ç†å™¨**æ¥å£**ã€‚æ¥å£ä»£ç å¦‚ä¸‹ï¼š

```Java
public interface TaskProcessor<T> {

    /**
     * A processed task/task list ends up in one of the following states:
     * <ul>
     *     <li>{@code Success} processing finished successfully</li>
     *     <li>{@code TransientError} processing failed, but shall be retried later</li>
     *     <li>{@code PermanentError} processing failed, and is non recoverable</li>
     * </ul>
     */
    enum ProcessingResult {
        /**
         * æˆåŠŸ
         */
        Success,
        /**
         * æ‹¥æŒ¤é”™è¯¯
         */
        Congestion,
        /**
         * ç¬æ—¶é”™è¯¯
         */
        TransientError,
        /**
         * æ°¸ä¹…é”™è¯¯
         */
        PermanentError
    }

    /**
     * å¤„ç†å•ä»»åŠ¡
     * In non-batched mode a single task is processed at a time.
     */
    ProcessingResult process(T task);

    /**
     * å¤„ç†æ‰¹é‡ä»»åŠ¡
     *
     * For batched mode a collection of tasks is run at a time. The result is provided for the aggregated result,
     * and all tasks are handled in the same way according to what is returned (for example are rescheduled, if the
     * error is transient).
     */
    ProcessingResult process(List<T> tasks);
}
```

* ProcessingResult ï¼Œå¤„ç†ä»»åŠ¡ç»“æœã€‚
    * `Success` ï¼ŒæˆåŠŸã€‚
    * `Congestion` ï¼Œæ‹¥æŒ¤é”™è¯¯ï¼Œ**ä»»åŠ¡å°†ä¼šè¢«é‡è¯•**ã€‚ä¾‹å¦‚ï¼Œè¯·æ±‚è¢«é™æµã€‚
    * `TransientError` ï¼Œç¬æ—¶é”™è¯¯ï¼Œ**ä»»åŠ¡å°†ä¼šè¢«é‡è¯•**ã€‚ä¾‹å¦‚ï¼Œç½‘ç»œè¯·æ±‚è¶…æ—¶ã€‚
    * `PermanentError` ï¼Œæ°¸ä¹…é”™è¯¯ï¼Œ**ä»»åŠ¡å°†ä¼šè¢«ä¸¢å¼ƒ**ã€‚ä¾‹å¦‚ï¼Œæ‰§è¡Œæ—¶å‘ç”Ÿç¨‹åºå¼‚å¸¸ã€‚
* `#process(task)` æ–¹æ³•ï¼Œå¤„ç†å•ä»»åŠ¡ã€‚
* `#process(tasks)` æ–¹æ³•ï¼Œå¤„ç†æ‰¹é‡ä»»åŠ¡ã€‚



# 4. åˆ›å»ºä»»åŠ¡åˆ†å‘å™¨

`com.netflix.eureka.util.batcher.TaskDispatcher` ï¼Œä»»åŠ¡åˆ†å‘å™¨**æ¥å£**ã€‚æ¥å£ä»£ç å¦‚ä¸‹ï¼š

```Java
public interface TaskDispatcher<ID, T> {

    void process(ID id, T task, long expiryTime);

    void shutdown();
}
```
* `#process(...)` æ–¹æ³•ï¼Œæäº¤ä»»åŠ¡ç¼–å·ï¼Œä»»åŠ¡ï¼Œä»»åŠ¡è¿‡æœŸæ—¶é—´ç»™ä»»åŠ¡åˆ†å‘å™¨å¤„ç†ã€‚

`com.netflix.eureka.util.batcher.TaskDispatchers` ï¼Œä»»åŠ¡åˆ†å‘å™¨**å·¥å‚ç±»**ï¼Œç”¨äºåˆ›å»ºä»»åŠ¡åˆ†å‘å™¨ã€‚å…¶å†…éƒ¨æä¾›ä¸¤ç§ä»»åŠ¡åˆ†å‘å™¨çš„å®ç°ï¼š

* **æ‰¹é‡ä»»åŠ¡**æ‰§è¡Œçš„åˆ†å‘å™¨ï¼Œç”¨äº Eureka-Server é›†ç¾¤æ³¨å†Œä¿¡æ¯çš„åŒæ­¥ä»»åŠ¡ã€‚
* **å•ä»»åŠ¡**æ‰§è¡Œçš„åˆ†å‘å™¨ï¼Œç”¨äº Eureka-Server å‘äºšé©¬é€Š AWS çš„ ASG ( Autoscaling Group ) åŒæ­¥çŠ¶æ€ã€‚è™½ç„¶æœ¬ç³»åˆ—æš‚æ—¶å¯¹ AWS ç›¸å…³çš„ä¸åšè§£æï¼Œä»å·¥å…·ç±»çš„è§’åº¦æ¥è¯´ï¼Œæœ¬æ–‡ä¼šå¯¹è¯¥åˆ†å‘å™¨è¿›è¡Œåˆ†äº«ã€‚

`com.netflix.eureka.cluster.ReplicationTaskProcessor` ï¼Œå®ç° TaskDispatcher ï¼ŒEureka-Server é›†ç¾¤ä»»åŠ¡å¤„ç†å™¨ã€‚æ„Ÿå…´è¶£çš„åŒå­¦ï¼Œå¯ä»¥ç‚¹å‡»[é“¾æ¥](https://github.com/YunaiV/eureka/blob/6e1b694898aa2f4c155936420c2ce5850f142742/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java)è‡ªå·±ç ”ç©¶ï¼Œæˆ‘ä»¬å°†åœ¨ [ã€ŠEureka æºç è§£æ â€”â€” Eureka-Server é›†ç¾¤åŒæ­¥ã€‹](http://www.iocoder.cn/Eureka/server-cluster/?self) æœ‰è¯¦ç»†è§£æã€‚

## 4.1 æ‰¹é‡ä»»åŠ¡æ‰§è¡Œåˆ†å‘å™¨

è°ƒç”¨ `TaskDispatchers#createBatchingTaskDispatcher(...)` æ–¹æ³•ï¼Œåˆ›å»º**æ‰¹é‡ä»»åŠ¡**æ‰§è¡Œçš„åˆ†å‘å™¨ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
// TaskDispatchers.java
  1: /**
  2:  * åˆ›å»ºæ‰¹é‡ä»»åŠ¡æ‰§è¡Œçš„åˆ†å‘å™¨
  3:  *
  4:  * @param id ä»»åŠ¡æ‰§è¡Œå™¨ç¼–å·
  5:  * @param maxBufferSize å¾…æ‰§è¡Œé˜Ÿåˆ—æœ€å¤§æ•°é‡
  6:  * @param workloadSize å•ä¸ªæ‰¹é‡ä»»åŠ¡åŒ…å«ä»»åŠ¡æœ€å¤§æ•°é‡
  7:  * @param workerCount ä»»åŠ¡æ‰§è¡Œå™¨å·¥ä½œçº¿ç¨‹æ•°
  8:  * @param maxBatchingDelay æ‰¹é‡ä»»åŠ¡ç­‰å¾…æœ€å¤§å»¶è¿Ÿæ—¶é•¿ï¼Œå•ä½ï¼šæ¯«ç§’
  9:  * @param congestionRetryDelayMs è¯·æ±‚é™æµå»¶è¿Ÿé‡è¯•æ—¶é—´ï¼Œå•ä½ï¼šæ¯«ç§’
 10:  * @param networkFailureRetryMs ç½‘ç»œå¤±è´¥å»¶è¿Ÿé‡è¯•æ—¶é•¿ï¼Œå•ä½ï¼šæ¯«ç§’
 11:  * @param taskProcessor ä»»åŠ¡å¤„ç†å™¨
 12:  * @param <ID> ä»»åŠ¡ç¼–å·æ³›å‹
 13:  * @param <T> ä»»åŠ¡æ³›å‹
 14:  * @return æ‰¹é‡ä»»åŠ¡æ‰§è¡Œçš„åˆ†å‘å™¨
 15:  */
 16: public static <ID, T> TaskDispatcher<ID, T> createBatchingTaskDispatcher(String id,
 17:                                                                          int maxBufferSize,
 18:                                                                          int workloadSize,
 19:                                                                          int workerCount,
 20:                                                                          long maxBatchingDelay,
 21:                                                                          long congestionRetryDelayMs,
 22:                                                                          long networkFailureRetryMs,
 23:                                                                          TaskProcessor<T> taskProcessor) {
 24:     // åˆ›å»º ä»»åŠ¡æ¥æ”¶æ‰§è¡Œå™¨
 25:     final AcceptorExecutor<ID, T> acceptorExecutor = new AcceptorExecutor<>(
 26:             id, maxBufferSize, workloadSize, maxBatchingDelay, congestionRetryDelayMs, networkFailureRetryMs
 27:     );
 28:     // åˆ›å»º æ‰¹é‡ä»»åŠ¡æ‰§è¡Œå™¨
 29:     final TaskExecutors<ID, T> taskExecutor = TaskExecutors.batchExecutors(id, workerCount, taskProcessor, acceptorExecutor);
 30:     // åˆ›å»º æ‰¹é‡ä»»åŠ¡åˆ†å‘å™¨
 31:     return new TaskDispatcher<ID, T>() {
 32:         @Override
 33:         public void process(ID id, T task, long expiryTime) {
 34:             acceptorExecutor.process(id, task, expiryTime);
 35:         }
 36: 
 37:         @Override
 38:         public void shutdown() {
 39:             acceptorExecutor.shutdown();
 40:             taskExecutor.shutdown();
 41:         }
 42:     };
 43: }
```

* ç¬¬ 1 è‡³ 23 è¡Œ ï¼šæ–¹æ³•å‚æ•°ã€‚æ¯”è¾ƒå¤šå“ˆï¼Œè¯·è€å¿ƒç†è§£ã€‚
    * `workloadSize` å‚æ•°ï¼Œå•ä¸ªæ‰¹é‡ä»»åŠ¡åŒ…å«ä»»åŠ¡æœ€å¤§æ•°é‡ã€‚
    * `taskProcessor` å‚æ•°ï¼Œ**è‡ªå®šä¹‰ä»»åŠ¡æ‰§è¡Œå™¨å®ç°**ã€‚
* ç¬¬ 24 è‡³ 27 è¡Œ ï¼šåˆ›å»ºä»»åŠ¡**æ¥æ”¶**æ‰§è¡Œå™¨ã€‚åœ¨ [ã€Œ5. åˆ›å»ºä»»åŠ¡æ¥æ”¶å™¨ã€](#) è¯¦ç»†è§£æã€‚
* ç¬¬ 28 è‡³ 29 è¡Œ ï¼šåˆ›å»º**æ‰¹é‡**ä»»åŠ¡æ‰§è¡Œå™¨ã€‚åœ¨ [ã€Œ6.1 åˆ›å»ºæ‰¹é‡ä»»åŠ¡æ‰§è¡Œå™¨ã€](#) è¯¦ç»†è§£æã€‚
* ç¬¬ 30 è‡³ 42 è¡Œ ï¼šåˆ›å»º**æ‰¹é‡**ä»»åŠ¡åˆ†å‘å™¨ã€‚
    * ç¬¬ 32 è‡³ 35 è¡Œ ï¼š`#process()` æ–¹æ³•çš„å®ç°ï¼Œè°ƒç”¨ `AcceptorExecutor#process(...)` æ–¹æ³•ï¼Œæäº¤ [ ä»»åŠ¡ç¼–å· , ä»»åŠ¡ , ä»»åŠ¡è¿‡æœŸæ—¶é—´ ] ç»™ä»»åŠ¡åˆ†å‘å™¨å¤„ç†ã€‚

## 4.2 å•ä»»åŠ¡æ‰§è¡Œåˆ†å‘å™¨

è°ƒç”¨ `TaskDispatchers#createNonBatchingTaskDispatcher(...)` æ–¹æ³•ï¼Œåˆ›å»º**å•ä»»åŠ¡**æ‰§è¡Œçš„åˆ†å‘å™¨ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
  1: /**
  2:  * åˆ›å»ºå•ä»»åŠ¡æ‰§è¡Œçš„åˆ†å‘å™¨
  3:  *
  4:  * @param id ä»»åŠ¡æ‰§è¡Œå™¨ç¼–å·
  5:  * @param maxBufferSize å¾…æ‰§è¡Œé˜Ÿåˆ—æœ€å¤§æ•°é‡
  6:  * @param workerCount ä»»åŠ¡æ‰§è¡Œå™¨å·¥ä½œçº¿ç¨‹æ•°
  7:  * @param maxBatchingDelay æ‰¹é‡ä»»åŠ¡ç­‰å¾…æœ€å¤§å»¶è¿Ÿæ—¶é•¿ï¼Œå•ä½ï¼šæ¯«ç§’
  8:  * @param congestionRetryDelayMs è¯·æ±‚é™æµå»¶è¿Ÿé‡è¯•æ—¶é—´ï¼Œå•ä½ï¼šæ¯«ç§’
  9:  * @param networkFailureRetryMs ç½‘ç»œå¤±è´¥å»¶è¿Ÿé‡è¯•æ—¶é•¿ï¼Œå•ä½ï¼šæ¯«ç§’
 10:  * @param taskProcessor ä»»åŠ¡å¤„ç†å™¨
 11:  * @param <ID> ä»»åŠ¡ç¼–å·æ³›å‹
 12:  * @param <T> ä»»åŠ¡æ³›å‹
 13:  * @return å•ä»»åŠ¡æ‰§è¡Œçš„åˆ†å‘å™¨
 14:  */
 15: public static <ID, T> TaskDispatcher<ID, T> createNonBatchingTaskDispatcher(String id,
 16:                                                                             int maxBufferSize,
 17:                                                                             int workerCount,
 18:                                                                             long maxBatchingDelay,
 19:                                                                             long congestionRetryDelayMs,
 20:                                                                             long networkFailureRetryMs,
 21:                                                                             TaskProcessor<T> taskProcessor) {
 22:     // åˆ›å»º ä»»åŠ¡æ¥æ”¶æ‰§è¡Œå™¨
 23:     final AcceptorExecutor<ID, T> acceptorExecutor = new AcceptorExecutor<>(
 24:             id, maxBufferSize, /* workloadSize = 1 */1, maxBatchingDelay, congestionRetryDelayMs, networkFailureRetryMs
 25:     );
 26:     final TaskExecutors<ID, T> taskExecutor = TaskExecutors.singleItemExecutors(id, workerCount, taskProcessor, acceptorExecutor);
 27:     return new TaskDispatcher<ID, T>() {
 28:         @Override
 29:         public void process(ID id, T task, long expiryTime) {
 30:             acceptorExecutor.process(id, task, expiryTime);
 31:         }
 32: 
 33:         @Override
 34:         public void shutdown() {
 35:             acceptorExecutor.shutdown();
 36:             taskExecutor.shutdown();
 37:         }
 38:     };
 39: }
```

* ç¬¬ 1 è‡³ 21 è¡Œ ï¼šæ–¹æ³•å‚æ•°ã€‚æ¯”è¾ƒå¤šå“ˆï¼Œè¯·è€å¿ƒç†è§£ã€‚
    * ~~`workloadSize` å‚æ•°~~ï¼Œç›¸æ¯” `#createBatchingTaskDispatcher(...)` å°‘è¿™ä¸ªå‚æ•°ã€‚**åœ¨ç¬¬ 24 è¡Œï¼Œä½ ä¼šå‘ç°è¯¥å‚æ•°ä¼ é€’ç»™ AcceptorExecutor ä½¿ç”¨ 1 å™¢**ã€‚
    * `taskProcessor` å‚æ•°ï¼Œ**è‡ªå®šä¹‰ä»»åŠ¡æ‰§è¡Œå™¨å®ç°**ã€‚
* ç¬¬ 21 è‡³ 25 è¡Œ ï¼šåˆ›å»ºä»»åŠ¡**æ¥æ”¶**æ‰§è¡Œå™¨ã€‚å’Œ `#createBatchingTaskDispatcher(...)` åªå·® `workloadSize = 1` å‚æ•°ã€‚åœ¨ [ã€Œ5. åˆ›å»ºä»»åŠ¡æ¥æ”¶å™¨ã€](#) è¯¦ç»†è§£æã€‚
* ç¬¬ 28 è‡³ 29 è¡Œ ï¼šåˆ›å»º**å•**ä»»åŠ¡æ‰§è¡Œå™¨ã€‚**å’Œ `#createBatchingTaskDispatcher(...)` å·®åˆ«å¾ˆå¤§**ã€‚[ã€Œ6.2 åˆ›å»ºå•ä»»åŠ¡æ‰§è¡Œå™¨ã€](#) è¯¦ç»†è§£æã€‚
* ç¬¬ 30 è‡³ 42 è¡Œ ï¼šåˆ›å»º**å•**ä»»åŠ¡åˆ†å‘å™¨ã€‚å’Œ `#createBatchingTaskDispatcher(...)` ä¸€æ ·ã€‚

# 5. åˆ›å»ºä»»åŠ¡æ¥æ”¶æ‰§è¡Œå™¨

`com.netflix.eureka.util.batcher.AcceptorExecutor` ï¼Œä»»åŠ¡æ¥æ”¶æ‰§è¡Œå™¨ã€‚åˆ›å»ºæ„é€ æ–¹æ³•ä»£ç å¦‚ä¸‹ï¼š

```Java
  1: class AcceptorExecutor<ID, T> {
  2: 
  3:     private static final Logger logger = LoggerFactory.getLogger(AcceptorExecutor.class);
  4: 
  5:     /**
  6:      * å¾…æ‰§è¡Œé˜Ÿåˆ—æœ€å¤§æ•°é‡
  7:      * {@link #processingOrder}
  8:      */
  9:     private final int maxBufferSize;
 10:     /**
 11:      * å•ä¸ªæ‰¹é‡ä»»åŠ¡åŒ…å«ä»»åŠ¡æœ€å¤§æ•°é‡
 12:      */
 13:     private final int maxBatchingSize;
 14:     /**
 15:      * æ‰¹é‡ä»»åŠ¡ç­‰å¾…æœ€å¤§å»¶è¿Ÿæ—¶é•¿ï¼Œå•ä½ï¼šæ¯«ç§’
 16:      */
 17:     private final long maxBatchingDelay;
 18: 
 19:     /**
 20:      * æ˜¯å¦å…³é—­
 21:      */
 22:     private final AtomicBoolean isShutdown = new AtomicBoolean(false);
 23:     /**
 24:      * æ¥æ”¶ä»»åŠ¡é˜Ÿåˆ—
 25:      */
 26:     private final BlockingQueue<TaskHolder<ID, T>> acceptorQueue = new LinkedBlockingQueue<>();
 27:     /**
 28:      * é‡æ–°æ‰§è¡Œä»»åŠ¡é˜Ÿåˆ—
 29:      */
 30:     private final BlockingDeque<TaskHolder<ID, T>> reprocessQueue = new LinkedBlockingDeque<>();
 31:     /**
 32:      * æ¥æ”¶ä»»åŠ¡çº¿ç¨‹
 33:      */
 34:     private final Thread acceptorThread;
 35: 
 36:     /**
 37:      * å¾…æ‰§è¡Œä»»åŠ¡æ˜ å°„
 38:      */
 39:     private final Map<ID, TaskHolder<ID, T>> pendingTasks = new HashMap<>();
 40:     /**
 41:      * å¾…æ‰§è¡Œé˜Ÿåˆ—
 42:      */
 43:     private final Deque<ID> processingOrder = new LinkedList<>();
 44: 
 45:     /**
 46:      * å•ä»»åŠ¡å·¥ä½œè¯·æ±‚ä¿¡å·é‡
 47:      */
 48:     private final Semaphore singleItemWorkRequests = new Semaphore(0);
 49:     /**
 50:      * å•ä»»åŠ¡å·¥ä½œé˜Ÿåˆ—
 51:      */
 52:     private final BlockingQueue<TaskHolder<ID, T>> singleItemWorkQueue = new LinkedBlockingQueue<>();
 53: 
 54:     /**
 55:      * æ‰¹é‡ä»»åŠ¡å·¥ä½œè¯·æ±‚ä¿¡å·é‡
 56:      */
 57:     private final Semaphore batchWorkRequests = new Semaphore(0);
 58:     /**
 59:      * æ‰¹é‡ä»»åŠ¡å·¥ä½œé˜Ÿåˆ—
 60:      */
 61:     private final BlockingQueue<List<TaskHolder<ID, T>>> batchWorkQueue = new LinkedBlockingQueue<>();
 62: 
 63:     /**
 64:      * ç½‘ç»œé€šä¿¡æ•´å½¢å™¨
 65:      */
 66:     private final TrafficShaper trafficShaper;
 67: 
 68:     AcceptorExecutor(String id,
 69:                      int maxBufferSize,
 70:                      int maxBatchingSize,
 71:                      long maxBatchingDelay,
 72:                      long congestionRetryDelayMs,
 73:                      long networkFailureRetryMs) {
 74:         this.maxBufferSize = maxBufferSize;
 75:         this.maxBatchingSize = maxBatchingSize;
 76:         this.maxBatchingDelay = maxBatchingDelay;
 77: 
 78:         // åˆ›å»º ç½‘ç»œé€šä¿¡æ•´å½¢å™¨
 79:         this.trafficShaper = new TrafficShaper(congestionRetryDelayMs, networkFailureRetryMs);
 80: 
 81:         // åˆ›å»º æ¥æ”¶ä»»åŠ¡çº¿ç¨‹
 82:         ThreadGroup threadGroup = new ThreadGroup("eurekaTaskExecutors");
 83:         this.acceptorThread = new Thread(threadGroup, new AcceptorRunner(), "TaskAcceptor-" + id);
 84:         this.acceptorThread.setDaemon(true);
 85:         this.acceptorThread.start();
 86: 
 87:         // TODO ï¼ˆçœç•¥ä»£ç ï¼‰èŠ‹è‰¿ï¼šç›‘æ§ç›¸å…³ï¼Œæš‚æ—¶æ— è§†
 88:     }
 89: }
```

* ç¬¬ 5 è‡³ 61 è¡Œ ï¼šå±æ€§ã€‚æ¯”è¾ƒå¤šå“ˆï¼Œè¯·è€å¿ƒç†è§£ã€‚
    * çœ¼å°–å¦‚ä½ ï¼Œä¼šå‘ç° AcceptorExecutor å³å­˜åœ¨å•ä»»åŠ¡å·¥ä½œé˜Ÿåˆ—( `singleItemWorkQueue` )ï¼Œåˆå­˜åœ¨æ‰¹é‡ä»»åŠ¡å·¥ä½œé˜Ÿåˆ—( `batchWorkQueue` ) ï¼Œåœ¨ [ã€Œ9. ä»»åŠ¡æ¥æ”¶çº¿ç¨‹ã€è°ƒåº¦ä»»åŠ¡ã€‘ã€](#) ä¼šè§£ç­”è¿™ä¸ªç–‘æƒ‘ã€‚
* ç¬¬ 78 è‡³ 79 è¡Œ ï¼šåˆ›å»ºç½‘ç»œé€šä¿¡æ•´å½¢å™¨ã€‚åœ¨ [ã€Œ7. ç½‘ç»œé€šä¿¡æ•´å½¢å™¨ã€](#) è¯¦ç»†è§£æã€‚
* ç¬¬ 81 è‡³ 85 è¡Œ ï¼š**åˆ›å»ºæ¥æ”¶ä»»åŠ¡çº¿ç¨‹**ã€‚


# 6. åˆ›å»ºä»»åŠ¡æ‰§è¡Œå™¨

`com.netflix.eureka.util.batcher.TaskExecutors` ï¼Œä»»åŠ¡æ‰§è¡Œå™¨ã€‚**å…¶å†…éƒ¨æä¾›åˆ›å»ºå•ä»»åŠ¡å’Œæ‰¹é‡ä»»åŠ¡æ‰§è¡Œå™¨çš„ä¸¤ç§æ–¹æ³•**ã€‚TaskExecutors æ„é€ æ–¹æ³•å¦‚ä¸‹ï¼š

```Java
class TaskExecutors<ID, T> {

    private static final Logger logger = LoggerFactory.getLogger(TaskExecutors.class);

    /**
     * æ˜¯å¦å…³é—­
     */
    private final AtomicBoolean isShutdown;
    /**
     * å·¥ä½œçº¿ç¨‹æ± 
     */
    private final List<Thread> workerThreads;

    TaskExecutors(WorkerRunnableFactory<ID, T> workerRunnableFactory, int workerCount, AtomicBoolean isShutdown) {
        this.isShutdown = isShutdown;
        this.workerThreads = new ArrayList<>();

        // åˆ›å»º å·¥ä½œçº¿ç¨‹æ± 
        ThreadGroup threadGroup = new ThreadGroup("eurekaTaskExecutors");
        for (int i = 0; i < workerCount; i++) {
            WorkerRunnable<ID, T> runnable = workerRunnableFactory.create(i);
            Thread workerThread = new Thread(threadGroup, runnable, runnable.getWorkerName());
            workerThreads.add(workerThread);
            workerThread.setDaemon(true);
            workerThread.start();
        }
    }
    
    /**
     * åˆ›å»ºå·¥ä½œçº¿ç¨‹å·¥å‚
     *
     * @param <ID> ä»»åŠ¡ç¼–å·æ³›å‹
     * @param <T> æ‰¹é‡ä»»åŠ¡æ‰§è¡Œå™¨
     */
    interface WorkerRunnableFactory<ID, T> {
        WorkerRunnable<ID, T> create(int idx);
    }
}
```

* `workerThreads` å±æ€§ï¼Œå·¥ä½œçº¿ç¨‹**æ± **ã€‚**å·¥ä½œä»»åŠ¡é˜Ÿåˆ—ä¼šè¢«å·¥ä½œçº¿ç¨‹æ± å¹¶å‘æ‹‰å–ï¼Œå¹¶å‘æ‰§è¡Œ**ã€‚
* `com.netflix.eureka.util.batcher.TaskExecutors.WorkerRunnableFactory` ï¼Œåˆ›å»ºå·¥ä½œçº¿ç¨‹å·¥å‚**æ¥å£**ã€‚å•ä»»åŠ¡å’Œæ‰¹é‡ä»»åŠ¡æ‰§è¡Œå™¨çš„å·¥ä½œçº¿ç¨‹å®ç°ä¸åŒï¼Œé€šè¿‡è‡ªå®šä¹‰å·¥å‚å®ç°ç±»åˆ›å»ºã€‚

## 6.1 åˆ›å»ºæ‰¹é‡ä»»åŠ¡æ‰§è¡Œå™¨

è°ƒç”¨ `TaskExecutors#batchExecutors(...)` æ–¹æ³•ï¼Œåˆ›å»ºæ‰¹é‡ä»»åŠ¡æ‰§è¡Œå™¨ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
/**
* åˆ›å»ºæ‰¹é‡ä»»åŠ¡æ‰§è¡Œå™¨
*
* @param name ä»»åŠ¡æ‰§è¡Œå™¨å
* @param workerCount ä»»åŠ¡æ‰§è¡Œå™¨å·¥ä½œçº¿ç¨‹æ•°
* @param processor ä»»åŠ¡å¤„ç†å™¨
* @param acceptorExecutor æ¥æ”¶ä»»åŠ¡æ‰§è¡Œå™¨
* @param <ID> ä»»åŠ¡ç¼–å·æ³›å‹
* @param <T> ä»»åŠ¡æ³›å‹
* @return æ‰¹é‡ä»»åŠ¡æ‰§è¡Œå™¨
*/
static <ID, T> TaskExecutors<ID, T> batchExecutors(final String name,
                                                  int workerCount,
                                                  final TaskProcessor<T> processor,
                                                  final AcceptorExecutor<ID, T> acceptorExecutor) {
   final AtomicBoolean isShutdown = new AtomicBoolean();
   final TaskExecutorMetrics metrics = new TaskExecutorMetrics(name);
   // åˆ›å»ºæ‰¹é‡ä»»åŠ¡æ‰§è¡Œå™¨
   return new TaskExecutors<>(new WorkerRunnableFactory<ID, T>() { // æ‰¹é‡ä»»åŠ¡å·¥ä½œçº¿ç¨‹å·¥å‚
       @Override
       public WorkerRunnable<ID, T> create(int idx) {
           return new BatchWorkerRunnable<>("TaskBatchingWorker-" + name + '-' + idx /* çº¿ç¨‹å */, isShutdown, metrics, processor, acceptorExecutor);
       }
   }, workerCount, isShutdown);
}
```

* `com.netflix.eureka.util.batcher.TaskExecutors.WorkerRunnable.BatchWorkerRunnable` ï¼Œæ‰¹é‡ä»»åŠ¡å·¥ä½œçº¿ç¨‹ã€‚

## 6.2 åˆ›å»ºå•ä»»åŠ¡æ‰§è¡Œå™¨

è°ƒç”¨ `TaskExecutors#singleItemExecutors(...)` æ–¹æ³•ï¼Œåˆ›å»ºæ‰¹é‡ä»»åŠ¡æ‰§è¡Œå™¨ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
/**
* åˆ›å»ºå•ä»»åŠ¡æ‰§è¡Œå™¨
*
* @param name ä»»åŠ¡æ‰§è¡Œå™¨å
* @param workerCount ä»»åŠ¡æ‰§è¡Œå™¨å·¥ä½œçº¿ç¨‹æ•°
* @param processor ä»»åŠ¡å¤„ç†å™¨
* @param acceptorExecutor æ¥æ”¶ä»»åŠ¡æ‰§è¡Œå™¨
* @param <ID> ä»»åŠ¡ç¼–å·æ³›å‹
* @param <T> ä»»åŠ¡æ³›å‹
* @return å•ä»»åŠ¡æ‰§è¡Œå™¨
*/
static <ID, T> TaskExecutors<ID, T> singleItemExecutors(final String name,
                                                       int workerCount,
                                                       final TaskProcessor<T> processor,
                                                       final AcceptorExecutor<ID, T> acceptorExecutor) {
   final AtomicBoolean isShutdown = new AtomicBoolean();
   final TaskExecutorMetrics metrics = new TaskExecutorMetrics(name);
   // åˆ›å»ºå•ä»»åŠ¡æ‰§è¡Œå™¨
   return new TaskExecutors<>(new WorkerRunnableFactory<ID, T>() { // å•ä»»åŠ¡å·¥ä½œçº¿ç¨‹å·¥å‚
       @Override
       public WorkerRunnable<ID, T> create(int idx) {
           return new SingleTaskWorkerRunnable<>("TaskNonBatchingWorker-" + name + '-' + idx /* çº¿ç¨‹å */, isShutdown, metrics, processor, acceptorExecutor);
       }
   }, workerCount, isShutdown);
}
```

* `com.netflix.eureka.util.batcher.TaskExecutors.WorkerRunnable.SingleTaskWorkerRunnable` ï¼Œå•ä»»åŠ¡å·¥ä½œçº¿ç¨‹ã€‚

## 6.3 å·¥ä½œçº¿ç¨‹æŠ½è±¡ç±»

`com.netflix.eureka.util.batcher.TaskExecutors.WorkerRunnable` ï¼Œä»»åŠ¡å·¥ä½œçº¿ç¨‹æŠ½è±¡ç±»ã€‚BatchWorkerRunnable å’Œ SingleTaskWorkerRunnable éƒ½å®ç°è¯¥ç±»ï¼Œå·®å¼‚åœ¨ `#run()` çš„è‡ªå®šä¹‰å®ç°ã€‚WorkerRunnable å®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
abstract static class WorkerRunnable<ID, T> implements Runnable {
   /**
    * çº¿ç¨‹å
    */
   final String workerName;
   /**
    * æ˜¯å¦å…³é—­
    */
   final AtomicBoolean isShutdown;
   final TaskExecutorMetrics metrics;
   /**
    * ä»»åŠ¡å¤„ç†å™¨
    */
   final TaskProcessor<T> processor;
   /**
    * ä»»åŠ¡æ¥æ”¶æ‰§è¡Œå™¨
    */
   final AcceptorExecutor<ID, T> taskDispatcher;
   
   // ... çœç•¥æ„é€ æ–¹æ³•å’Œ getting æ–¹æ³•ã€‚
}
```

# 7. ç½‘ç»œé€šä¿¡æ•´å½¢å™¨

`com.netflix.eureka.util.batcher.TrafficShaper` ï¼Œç½‘ç»œé€šä¿¡æ•´å½¢å™¨ã€‚å½“ä»»åŠ¡æ‰§è¡Œå‘ç”Ÿè¯·æ±‚é™æµï¼Œæˆ–æ˜¯è¯·æ±‚ç½‘ç»œå¤±è´¥çš„æƒ…å†µï¼Œåˆ™å»¶æ—¶ AcceptorRunner å°†ä»»åŠ¡æäº¤åˆ°å·¥ä½œä»»åŠ¡é˜Ÿåˆ—ï¼Œä»è€Œé¿å…ä»»åŠ¡å¾ˆå¿«å»æ‰§è¡Œï¼Œå†æ¬¡å‘ç”Ÿä¸Šè¿°æƒ…å†µã€‚TrafficShaper å®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
class TrafficShaper {

    /**
     * Upper bound on delay provided by configuration.
     */
    private static final long MAX_DELAY = 30 * 1000;

    /**
     * è¯·æ±‚é™æµå»¶è¿Ÿé‡è¯•æ—¶é—´ï¼Œå•ä½ï¼šæ¯«ç§’
     */
    private final long congestionRetryDelayMs;
    /**
     * ç½‘ç»œå¤±è´¥å»¶è¿Ÿé‡è¯•æ—¶é•¿ï¼Œå•ä½ï¼šæ¯«ç§’
     */
    private final long networkFailureRetryMs;

    /**
     * æœ€åè¯·æ±‚é™æµæ—¶é—´æˆ³ï¼Œå•ä½ï¼šæ¯«ç§’
     */
    private volatile long lastCongestionError;
    /**
     * æœ€åç½‘ç»œå¤±è´¥æ—¶é—´æˆ³ï¼Œå•ä½ï¼šæ¯«ç§’
     */
    private volatile long lastNetworkFailure;

    TrafficShaper(long congestionRetryDelayMs, long networkFailureRetryMs) {
        this.congestionRetryDelayMs = Math.min(MAX_DELAY, congestionRetryDelayMs);
        this.networkFailureRetryMs = Math.min(MAX_DELAY, networkFailureRetryMs);
    }

    void registerFailure(ProcessingResult processingResult) {
        if (processingResult == ProcessingResult.Congestion) {
            lastCongestionError = System.currentTimeMillis();
        } else if (processingResult == ProcessingResult.TransientError) {
            lastNetworkFailure = System.currentTimeMillis();
        }
    }

    /**
     * è®¡ç®—æäº¤å»¶è¿Ÿï¼Œå•ä½ï¼šæ¯«ç§’
     *
     * @return å»¶è¿Ÿ
     */
    long transmissionDelay() {
        // æ— å»¶è¿Ÿ
        if (lastCongestionError == -1 && lastNetworkFailure == -1) {
            return 0;
        }

        long now = System.currentTimeMillis();

        // è®¡ç®—æœ€åè¯·æ±‚é™æµå¸¦æ¥çš„å»¶è¿Ÿ
        if (lastCongestionError != -1) {
            long congestionDelay = now - lastCongestionError;
            if (congestionDelay >= 0 && congestionDelay < congestionRetryDelayMs) { // èŒƒå›´å†…
                return congestionRetryDelayMs - congestionDelay; // è¡¥å……å»¶è¿Ÿ
            }
            lastCongestionError = -1; // é‡ç½®æ—¶é—´æˆ³
        }

        // è®¡ç®—æœ€åç½‘ç»œå¤±è´¥å¸¦æ¥çš„å»¶è¿Ÿ
        if (lastNetworkFailure != -1) {
            long failureDelay = now - lastNetworkFailure;
            if (failureDelay >= 0 && failureDelay < networkFailureRetryMs) { // èŒƒå›´å†…
                return networkFailureRetryMs - failureDelay; // è¡¥å……å»¶è¿Ÿ
            }
            lastNetworkFailure = -1; // é‡ç½®æ—¶é—´æˆ³
        }

        // æ— å»¶è¿Ÿ
        return 0;
    }
}
```

* `#registerFailure(...)` ï¼Œåœ¨ä»»åŠ¡æ‰§è¡Œå¤±è´¥æ—¶ï¼Œæäº¤ä»»åŠ¡ç»“æœç»™ TrafficShaper ï¼Œè®°å½•å‘ç”Ÿæ—¶é—´ã€‚åœ¨ [ã€Œ10. ä»»åŠ¡æ‰§è¡Œå™¨ã€æ‰§è¡Œä»»åŠ¡ã€‘ã€](#) ä¼šçœ‹åˆ°è°ƒç”¨è¯¥æ–¹æ³•ã€‚
* `#transmissionDelay(...)` ï¼Œè®¡ç®—æäº¤å»¶è¿Ÿï¼Œå•ä½ï¼šæ¯«ç§’ã€‚[ã€Œ9. ä»»åŠ¡æ¥æ”¶çº¿ç¨‹ã€è°ƒåº¦ä»»åŠ¡ã€‘ã€](#) ä¼šçœ‹åˆ°è°ƒç”¨è¯¥æ–¹æ³•ã€‚

# 8. ä»»åŠ¡æ¥æ”¶æ‰§è¡Œå™¨ã€å¤„ç†ä»»åŠ¡ã€‘

è°ƒç”¨ `AcceptorExecutor#process(...)` æ–¹æ³•ï¼Œæ·»åŠ ä»»åŠ¡åˆ°æ¥æ”¶ä»»åŠ¡é˜Ÿåˆ—ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
// AcceptorExecutor.java
void process(ID id, T task, long expiryTime) {
   acceptorQueue.add(new TaskHolder<ID, T>(id, task, expiryTime));
   acceptedTasks++;
}
```

* `com.netflix.eureka.util.batcher.TaskHolder` ï¼Œä»»åŠ¡æŒæœ‰è€…ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    class TaskHolder<ID, T> {
    
        /**
         * ä»»åŠ¡ç¼–å·
         */
        private final ID id;
        /**
         * ä»»åŠ¡
         */
        private final T task;
        /**
         * ä»»åŠ¡è¿‡æœŸæ—¶é—´æˆ³
         */
        private final long expiryTime;
        /**
         * ä»»åŠ¡æäº¤æ—¶é—´æˆ³
         */
        private final long submitTimestamp;
    }
    ```
    


# 9. ä»»åŠ¡æ¥æ”¶çº¿ç¨‹ã€è°ƒåº¦ä»»åŠ¡ã€‘

åå°çº¿ç¨‹æ‰§è¡Œ `AcceptorRunner#run(...)` æ–¹æ³•ï¼Œè°ƒåº¦ä»»åŠ¡ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
  1: @Override
  2: public void run() {
  3:     long scheduleTime = 0;
  4:     while (!isShutdown.get()) {
  5:         try {
  6:             // å¤„ç†å®Œè¾“å…¥é˜Ÿåˆ—( æ¥æ”¶é˜Ÿåˆ— + é‡æ–°æ‰§è¡Œé˜Ÿåˆ— )
  7:             drainInputQueues();
  8: 
  9:             // å¾…æ‰§è¡Œä»»åŠ¡æ•°é‡
 10:             int totalItems = processingOrder.size();
 11: 
 12:             // è®¡ç®—è°ƒåº¦æ—¶é—´
 13:             long now = System.currentTimeMillis();
 14:             if (scheduleTime < now) {
 15:                 scheduleTime = now + trafficShaper.transmissionDelay();
 16:             }
 17: 
 18:             // è°ƒåº¦
 19:             if (scheduleTime <= now) {
 20:                 // è°ƒåº¦æ‰¹é‡ä»»åŠ¡
 21:                 assignBatchWork();
 22:                 // è°ƒåº¦å•ä»»åŠ¡
 23:                 assignSingleItemWork();
 24:             }
 25: 
 26:             // 1ï¼‰ä»»åŠ¡æ‰§è¡Œå™¨æ— ä»»åŠ¡è¯·æ±‚ï¼Œæ­£åœ¨å¿™ç¢Œå¤„ç†ä¹‹å‰çš„ä»»åŠ¡ï¼›æˆ–è€… 2ï¼‰ä»»åŠ¡å»¶è¿Ÿè°ƒåº¦ã€‚ç¡çœ  10 ç§’ï¼Œé¿å…èµ„æºæµªè´¹ã€‚
 27:             // If no worker is requesting data or there is a delay injected by the traffic shaper,
 28:             // sleep for some time to avoid tight loop.
 29:             if (totalItems == processingOrder.size()) {
 30:                 Thread.sleep(10);
 31:             }
 32:         } catch (InterruptedException ex) {
 33:             // Ignore
 34:         } catch (Throwable e) {
 35:             // Safe-guard, so we never exit this loop in an uncontrolled way.
 36:             logger.warn("Discovery AcceptorThread error", e);
 37:         }
 38:     }
 39: }
```

* ç¬¬ 4 è¡Œ ï¼šæ— é™å¾ªç¯æ‰§è¡Œè°ƒåº¦ï¼Œç›´åˆ°å…³é—­ã€‚
* ç¬¬ 6 è‡³ 7 è¡Œ ï¼šè°ƒç”¨ `#drainInputQueues()` æ–¹æ³•ï¼Œ**å¾ªç¯**å¤„ç†å®Œè¾“å…¥é˜Ÿåˆ—( æ¥æ”¶é˜Ÿåˆ— + é‡æ–°æ‰§è¡Œé˜Ÿåˆ— )ï¼Œ**ç›´åˆ°**æœ‰å¾…æ‰§è¡Œçš„ä»»åŠ¡ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
      1: private void drainInputQueues() throws InterruptedException {
      2:     do {
      3:         // å¤„ç†å®Œé‡æ–°æ‰§è¡Œé˜Ÿåˆ—
      4:         drainReprocessQueue();
      5:         // å¤„ç†å®Œæ¥æ”¶é˜Ÿåˆ—
      6:         drainAcceptorQueue();
      7: 
      8:         // æ‰€æœ‰é˜Ÿåˆ—ä¸ºç©ºï¼Œç­‰å¾… 10 msï¼Œçœ‹æ¥æ”¶é˜Ÿåˆ—æ˜¯å¦æœ‰æ–°ä»»åŠ¡
      9:         if (!isShutdown.get()) {
     10:             // If all queues are empty, block for a while on the acceptor queue
     11:             if (reprocessQueue.isEmpty() && acceptorQueue.isEmpty() && pendingTasks.isEmpty()) {
     12:                 TaskHolder<ID, T> taskHolder = acceptorQueue.poll(10, TimeUnit.MILLISECONDS);
     13:                 if (taskHolder != null) {
     14:                     appendTaskHolder(taskHolder);
     15:                 }
     16:             }
     17:         }
     18:     } while (!reprocessQueue.isEmpty() || !acceptorQueue.isEmpty() || pendingTasks.isEmpty()); // å¤„ç†å®Œè¾“å…¥é˜Ÿåˆ—( æ¥æ”¶é˜Ÿåˆ— + é‡æ–°æ‰§è¡Œé˜Ÿåˆ— )
     19: }
    ```
    * ç¬¬ 2 è¡Œ && ç¬¬ 18 è¡Œ ï¼š**å¾ªç¯**ï¼Œç›´åˆ°**åŒæ—¶**æ»¡è¶³å¦‚ä¸‹å…¨éƒ¨æ¡ä»¶ï¼š
        * é‡æ–°æ‰§è¡Œé˜Ÿåˆ—( `reprocessQueue` ) å’Œæ¥æ”¶é˜Ÿåˆ—( `acceptorQueue` )ä¸ºç©º
        * å¾…æ‰§è¡Œä»»åŠ¡æ˜ å°„( `pendingTasks` )**ä¸ä¸ºç©º**
    * ç¬¬ 3 è‡³ 4 è¡Œ ï¼šå¤„ç†å®Œé‡æ–°æ‰§è¡Œé˜Ÿåˆ—( `reprocessQueue` )ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

        ```Java
          1: private void drainReprocessQueue() {
          2:     long now = System.currentTimeMillis();
          3:     while (!reprocessQueue.isEmpty() && !isFull()) {
          4:         TaskHolder<ID, T> taskHolder = reprocessQueue.pollLast(); // ä¼˜å…ˆæ‹¿è¾ƒæ–°çš„ä»»åŠ¡
          5:         ID id = taskHolder.getId();
          6:         if (taskHolder.getExpiryTime() <= now) { // è¿‡æœŸ
          7:             expiredTasks++;
          8:         } else if (pendingTasks.containsKey(id)) { // å·²å­˜åœ¨
          9:             overriddenTasks++;
         10:         } else {
         11:             pendingTasks.put(id, taskHolder);
         12:             processingOrder.addFirst(id); // æäº¤åˆ°é˜Ÿå¤´
         13:         }
         14:     }
         15:     // å¦‚æœå¾…æ‰§è¡Œé˜Ÿåˆ—å·²æ»¡ï¼Œæ¸…ç©ºé‡æ–°æ‰§è¡Œé˜Ÿåˆ—ï¼Œæ”¾å¼ƒè¾ƒæ—©çš„ä»»åŠ¡
         16:     if (isFull()) {
         17:         queueOverflows += reprocessQueue.size();
         18:         reprocessQueue.clear();
         19:     }
         20: }
        ```
        * ç¬¬ 4 è¡Œ ï¼šä¼˜å…ˆä»é‡æ–°æ‰§è¡Œä»»åŠ¡çš„é˜Ÿå°¾æ‹¿è¾ƒæ–°çš„ä»»åŠ¡ï¼Œä»è€Œå®ç°ä¿ç•™æ›´æ–°çš„ä»»åŠ¡åœ¨å¾…æ‰§è¡Œä»»åŠ¡æ˜ å°„( `pendingTasks` ) é‡Œã€‚
        * ç¬¬ 12 è¡Œ ï¼šæ·»åŠ ä»»åŠ¡ç¼–å·åˆ°å¾…æ‰§è¡Œé˜Ÿåˆ—( `processingOrder` ) çš„å¤´éƒ¨ã€‚æ•ˆæœå¦‚ä¸‹å›¾ï¼š![](http://www.iocoder.cn/images/Eureka/2018_07_17/03.png)
        * ç¬¬ 15 è‡³ 18 è¡Œ ï¼šå¦‚æœå¾…æ‰§è¡Œé˜Ÿåˆ—( `pendingTasks` )å·²æ»¡ï¼Œæ¸…ç©ºé‡æ–°æ‰§è¡Œé˜Ÿåˆ—( `processingOrder` )ï¼Œæ”¾å¼ƒè¾ƒæ—©çš„ä»»åŠ¡ã€‚
    
    * ç¬¬ 5 è‡³ 6 è¡Œ ï¼šå¤„ç†å®Œæ¥æ”¶é˜Ÿåˆ—( `acceptorQueue` )ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

        ```Java
        private void drainAcceptorQueue() {
          while (!acceptorQueue.isEmpty()) { // å¾ªç¯ï¼Œç›´åˆ°æ¥æ”¶é˜Ÿåˆ—ä¸ºç©º
              appendTaskHolder(acceptorQueue.poll());
          }
        }
        
        private void appendTaskHolder(TaskHolder<ID, T> taskHolder) {
          // å¦‚æœå¾…æ‰§è¡Œé˜Ÿåˆ—å·²æ»¡ï¼Œç§»é™¤å¾…å¤„ç†é˜Ÿåˆ—ï¼Œæ”¾å¼ƒè¾ƒæ—©çš„ä»»åŠ¡
          if (isFull()) {
              pendingTasks.remove(processingOrder.poll());
              queueOverflows++;
          }
          // æ·»åŠ åˆ°å¾…æ‰§è¡Œé˜Ÿåˆ—
          TaskHolder<ID, T> previousTask = pendingTasks.put(taskHolder.getId(), taskHolder);
          if (previousTask == null) {
              processingOrder.add(taskHolder.getId());
          } else {
              overriddenTasks++;
          }
        }
        ```

    * ç¬¬ 8 è‡³ 17 è¡Œ ï¼šå½“æ‰€æœ‰é˜Ÿåˆ—ä¸ºç©ºï¼Œé˜»å¡ä»æ¥æ”¶é˜Ÿåˆ—( `acceptorQueue` ) æ‹‰å–ä»»åŠ¡ 10 msã€‚è‹¥æ‹‰å–åˆ°ï¼Œæ·»åŠ åˆ°å¾…æ‰§è¡Œé˜Ÿåˆ—( `processingOrder` )ã€‚

* ç¬¬ 12 è‡³ 16 è¡Œ ï¼šè®¡ç®—å¯è°ƒåº¦ä»»åŠ¡çš„æœ€å°æ—¶é—´( `scheduleTime` )ã€‚
    * å½“ `scheduleTime` å°äºå½“å‰æ—¶é—´ï¼Œä¸é‡æ–°è®¡ç®—ï¼Œå³æ­¤æ—¶éœ€è¦å»¶è¿Ÿç­‰å¾…è°ƒåº¦ã€‚
    * å½“ `scheduleTime` å¤§äºç­‰äºå½“å‰æ—¶é—´ï¼Œé…åˆ `TrafficShaper#transmissionDelay(...)` é‡æ–°è®¡ç®—ã€‚
* ç¬¬ 19 è¡Œ ï¼šå½“ `scheduleTime` å°äºå½“å‰æ—¶é—´ï¼Œæ‰§è¡Œä»»åŠ¡çš„è°ƒåº¦ã€‚
* ç¬¬ 21 è¡Œ ï¼šè°ƒç”¨ `#assignBatchWork()` æ–¹æ³•ï¼Œè°ƒåº¦æ‰¹é‡ä»»åŠ¡ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
      1: void assignBatchWork() {
      2:     if (hasEnoughTasksForNextBatch()) {
      3:         // è·å– æ‰¹é‡ä»»åŠ¡å·¥ä½œè¯·æ±‚ä¿¡å·é‡
      4:         if (batchWorkRequests.tryAcquire(1)) {
      5:             // è·å–æ‰¹é‡ä»»åŠ¡
      6:             long now = System.currentTimeMillis();
      7:             int len = Math.min(maxBatchingSize, processingOrder.size());
      8:             List<TaskHolder<ID, T>> holders = new ArrayList<>(len);
      9:             while (holders.size() < len && !processingOrder.isEmpty()) {
     10:                 ID id = processingOrder.poll();
     11:                 TaskHolder<ID, T> holder = pendingTasks.remove(id);
     12:                 if (holder.getExpiryTime() > now) { // è¿‡æœŸ
     13:                     holders.add(holder);
     14:                 } else {
     15:                     expiredTasks++;
     16:                 }
     17:             }
     18:             //
     19:             if (holders.isEmpty()) { // æœªè°ƒåº¦åˆ°æ‰¹é‡ä»»åŠ¡ï¼Œé‡Šæ”¾è¯·æ±‚ä¿¡å·é‡
     20:                 batchWorkRequests.release();
     21:             } else { // æ·»åŠ æ‰¹é‡ä»»åŠ¡åˆ°æ‰¹é‡ä»»åŠ¡å·¥ä½œé˜Ÿåˆ—
     22:                 batchSizeMetric.record(holders.size(), TimeUnit.MILLISECONDS);
     23:                 batchWorkQueue.add(holders);
     24:             }
     25:         }
     26:     }
     27: }
    ```
    * ç¬¬ 2 è¡Œ ï¼šè°ƒç”¨ `#hasEnoughTasksForNextBatch()` æ–¹æ³•ï¼Œåˆ¤æ–­æ˜¯å¦æœ‰è¶³å¤Ÿä»»åŠ¡è¿›è¡Œä¸‹ä¸€æ¬¡æ‰¹é‡ä»»åŠ¡è°ƒåº¦ï¼š1ï¼‰å¾…æ‰§è¡Œä»»åŠ¡( `processingOrder` )æ˜ å°„å·²æ»¡ï¼›æˆ–è€… 2ï¼‰åˆ°è¾¾æ‰¹é‡ä»»åŠ¡å¤„ç†æœ€å¤§ç­‰å¾…å»¶è¿Ÿã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š
    
        ```Java
        private boolean hasEnoughTasksForNextBatch() {
            // å¾…æ‰§è¡Œé˜Ÿåˆ—ä¸ºç©º
            if (processingOrder.isEmpty()) {
              return false;
            }
            // å¾…æ‰§è¡Œä»»åŠ¡æ˜ å°„å·²æ»¡
            if (pendingTasks.size() >= maxBufferSize) {
                return true;
            }
        
            // åˆ°è¾¾æ‰¹é‡ä»»åŠ¡å¤„ç†æœ€å¤§ç­‰å¾…å»¶è¿Ÿ( é€šè¿‡å¾…å¤„ç†é˜Ÿåˆ—çš„å¤´éƒ¨ä»»åŠ¡åˆ¤æ–­ )
            TaskHolder<ID, T> nextHolder = pendingTasks.get(processingOrder.peek());
            long delay = System.currentTimeMillis() - nextHolder.getSubmitTimestamp();
            return delay >= maxBatchingDelay;
        }
        ```
        * x
    
    * ç¬¬ 5 è‡³ 17 è¡Œ ï¼šè·å–æ‰¹é‡ä»»åŠ¡( `holders` )ã€‚ğŸ˜ˆ ä½ ä¼šå‘ç°ï¼Œæœ¬æ–‡è¯´äº†åŠå¤©çš„æ‰¹é‡ä»»åŠ¡ï¼Œå®é™…æ˜¯ `List<TaskHolder<ID, T>>` å“ˆã€‚
    * ç¬¬ 4 è¡Œ ï¼šè·å–æ‰¹é‡ä»»åŠ¡å·¥ä½œè¯·æ±‚ä¿¡å·é‡( `batchWorkRequests` ) ã€‚åœ¨ä»»åŠ¡æ‰§è¡Œå™¨çš„æ‰¹é‡ä»»åŠ¡æ‰§è¡Œå™¨ï¼Œæ¯æ¬¡æ‰§è¡Œæ—¶ï¼Œå‘å‡º `batchWorkRequests` ã€‚**æ¯ä¸€ä¸ªä¿¡å·é‡éœ€è¦ä¿è¯è·å–åˆ°ä¸€ä¸ªæ‰¹é‡ä»»åŠ¡**ã€‚
    * ç¬¬ 19 è‡³ 20 è¡Œ ï¼šæœªè°ƒåº¦åˆ°æ‰¹é‡ä»»åŠ¡ï¼Œé‡Šæ”¾è¯·æ±‚ä¿¡å·é‡ï¼Œ**ä»£è¡¨è¯·æ±‚å®é™…æœªå®Œæˆï¼Œæ¯ä¸€ä¸ªä¿¡å·é‡éœ€è¦ä¿è¯è·å–åˆ°ä¸€ä¸ªæ‰¹é‡ä»»åŠ¡**ã€‚
    * ç¬¬ 21 è‡³ 24 è¡Œ ï¼šæ·»åŠ æ‰¹é‡ä»»åŠ¡åˆ°æ‰¹é‡ä»»åŠ¡å·¥ä½œé˜Ÿåˆ—ã€‚
    * ç¬¬ 23 è¡Œ ï¼šè°ƒç”¨ `#assignSingleItemWork()` æ–¹æ³•ï¼Œè°ƒåº¦å•ä»»åŠ¡ã€‚

* ç¬¬ 23 è¡Œ ï¼šè°ƒç”¨ `#assignSingleItemWork()` æ–¹æ³•ï¼Œè°ƒåº¦å•ä»»åŠ¡ï¼Œå’Œ `#assignBatchWork()` æ–¹æ³•**ç±»ä¼¼**ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    void assignSingleItemWork() {
      if (!processingOrder.isEmpty()) { // å¾…æ‰§è¡Œä»»é˜Ÿåˆ—ä¸ä¸ºç©º
          // è·å– å•ä»»åŠ¡å·¥ä½œè¯·æ±‚ä¿¡å·é‡
          if (singleItemWorkRequests.tryAcquire(1)) {
              // ã€å¾ªç¯ã€‘è·å–å•ä»»åŠ¡
              long now = System.currentTimeMillis();
              while (!processingOrder.isEmpty()) {
                  ID id = processingOrder.poll(); // ä¸€å®šä¸ä¸ºç©º
                  TaskHolder<ID, T> holder = pendingTasks.remove(id);
                  if (holder.getExpiryTime() > now) {
                      singleItemWorkQueue.add(holder);
                      return;
                  }
                  expiredTasks++;
              }
              // è·å–ä¸åˆ°å•ä»»åŠ¡ï¼Œé‡Šæ”¾è¯·æ±‚ä¿¡å·é‡
              singleItemWorkRequests.release();
          }
      }
    }
    ```
    * x

* ç¬¬ 26 è‡³ 31 è¡Œ ï¼šå½“è°ƒåº¦ä»»åŠ¡å‰çš„å¾…æ‰§è¡Œä»»åŠ¡æ•°( `totalItems` )ç­‰äºå½“å‰å¾…æ‰§è¡Œé˜Ÿåˆ—( `processingOrder` )çš„ä»»åŠ¡æ•°ï¼Œæ„å‘³ç€ï¼š1ï¼‰ä»»åŠ¡æ‰§è¡Œå™¨æ— ä»»åŠ¡è¯·æ±‚ï¼Œæ­£åœ¨å¿™ç¢Œå¤„ç†ä¹‹å‰çš„ä»»åŠ¡ï¼›æˆ–è€… 2ï¼‰ä»»åŠ¡å»¶è¿Ÿè°ƒåº¦ã€‚ç¡çœ  10 ç§’ï¼Œé¿å…èµ„æºæµªè´¹ã€‚
    
# 10. ä»»åŠ¡æ‰§è¡Œå™¨ã€æ‰§è¡Œä»»åŠ¡ã€‘

## 10.1 æ‰¹é‡ä»»åŠ¡å·¥ä½œçº¿ç¨‹

æ‰¹é‡ä»»åŠ¡å·¥ä½œåå°çº¿ç¨‹( BatchWorkerRunnable )æ‰§è¡Œ `#run(...)` æ–¹æ³•ï¼Œè°ƒåº¦ä»»åŠ¡ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
// 
  1: @Override
  2: public void run() {
  3:     try {
  4:         while (!isShutdown.get()) {
  5:             // è·å–æ‰¹é‡ä»»åŠ¡
  6:             List<TaskHolder<ID, T>> holders = getWork();
  7: 
  8:             // TODO èŠ‹è‰¿ï¼šç›‘æ§ç›¸å…³ï¼Œæš‚æ—¶æ— è§†
  9:             metrics.registerExpiryTimes(holders);
 10: 
 11:             // è·å¾—å®é™…æ‰¹é‡ä»»åŠ¡
 12:             List<T> tasks = getTasksOf(holders);
 13:             // è°ƒç”¨å¤„ç†å™¨æ‰§è¡Œä»»åŠ¡
 14:             ProcessingResult result = processor.process(tasks);
 15:             switch (result) {
 16:                 case Success:
 17:                     break;
 18:                 case Congestion:
 19:                 case TransientError:
 20:                     taskDispatcher.reprocess(holders, result); // æäº¤é‡æ–°å¤„ç†
 21:                     break;
 22:                 case PermanentError:
 23:                     logger.warn("Discarding {} tasks of {} due to permanent error", holders.size(), workerName);
 24:             }
 25: 
 26:             // TODO èŠ‹è‰¿ï¼šç›‘æ§ç›¸å…³ï¼Œæš‚æ—¶æ— è§†
 27:             metrics.registerTaskResult(result, tasks.size());
 28:         }
 29:     } catch (InterruptedException e) {
 30:         // Ignore
 31:     } catch (Throwable e) {
 32:         // Safe-guard, so we never exit this loop in an uncontrolled way.
 33:         logger.warn("Discovery WorkerThread error", e);
 34:     }
 35: }
```

* ç¬¬ 4 è¡Œ ï¼šæ— é™å¾ªç¯æ‰§è¡Œè°ƒåº¦ï¼Œç›´åˆ°å…³é—­ã€‚
* ç¬¬ 6 è¡Œ ï¼šè°ƒç”¨ `getWork()` æ–¹æ³•ï¼Œè·å–**ä¸€ä¸ª**æ‰¹é‡ä»»åŠ¡ç›´åˆ°æˆåŠŸã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
      1: private List<TaskHolder<ID, T>> getWork() throws InterruptedException {
      2:     // å‘èµ·è¯·æ±‚ä¿¡å·é‡ï¼Œå¹¶è·å¾—æ‰¹é‡ä»»åŠ¡çš„å·¥ä½œé˜Ÿåˆ—
      3:     BlockingQueue<List<TaskHolder<ID, T>>> workQueue = taskDispatcher.requestWorkItems();
      4:     // ã€å¾ªç¯ã€‘è·å–æ‰¹é‡ä»»åŠ¡ï¼Œç›´åˆ°æˆåŠŸ
      5:     List<TaskHolder<ID, T>> result;
      6:     do {
      7:         result = workQueue.poll(1, TimeUnit.SECONDS);
      8:     } while (!isShutdown.get() && result == null);
      9:     return result;
     10: }
    ```
    * ç¬¬ 3 è¡Œ ï¼šè°ƒç”¨ `TaskDispatcher#requestWorkItems()` æ–¹æ³•ï¼Œå‘èµ·è¯·æ±‚ä¿¡å·é‡ï¼Œå¹¶è·å¾—æ‰¹é‡ä»»åŠ¡çš„å·¥ä½œé˜Ÿåˆ—ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š
    
        ```Java
        // TaskDispatcher.java
        /**
        * æ‰¹é‡ä»»åŠ¡å·¥ä½œè¯·æ±‚ä¿¡å·é‡
        */
        private final Semaphore batchWorkRequests = new Semaphore(0);
        /**
        * æ‰¹é‡ä»»åŠ¡å·¥ä½œé˜Ÿåˆ—
        */
        private final BlockingQueue<List<TaskHolder<ID, T>>> batchWorkQueue = new LinkedBlockingQueue<>();
        
        BlockingQueue<List<TaskHolder<ID, T>>> requestWorkItems() {
           batchWorkRequests.release();
           return batchWorkQueue;
        }
        ```
        * **æ³¨æ„**ï¼Œæ‰¹é‡ä»»åŠ¡å·¥ä½œé˜Ÿåˆ—( `batchWorkQueue` ) å’Œå•ä»»åŠ¡å·¥ä½œé˜Ÿåˆ—( `singleItemWorkQueue` ) æ˜¯**ä¸åŒçš„é˜Ÿåˆ—**ã€‚
    
    * ç¬¬ 5 è‡³ 8 è¡Œ ï¼š**å¾ªç¯**è·å–**ä¸€ä¸ª**æ‰¹é‡ä»»åŠ¡ï¼Œç›´åˆ°æˆåŠŸã€‚

* ç¬¬ 12 è¡Œ ï¼šè°ƒç”¨ `#getTasksOf(...)` æ–¹æ³•ï¼Œè·å¾—**å®é™…**æ‰¹é‡ä»»åŠ¡ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    private List<T> getTasksOf(List<TaskHolder<ID, T>> holders) {
        List<T> tasks = new ArrayList<>(holders.size());
        for (TaskHolder<ID, T> holder : holders) {
            tasks.add(holder.getTask());
        }
        return tasks;
    }
    ```
    * x

* ç¬¬ 14 è‡³ 24 è¡Œ ï¼šè°ƒç”¨å¤„ç†å™¨( TaskProcessor ) æ‰§è¡Œä»»åŠ¡ã€‚å½“ä»»åŠ¡æ‰§è¡Œç»“æœä¸º `Congestion` æˆ– `TransientError` ï¼Œè°ƒç”¨ `AcceptorExecutor#reprocess(...)` æäº¤**æ•´ä¸ªæ‰¹é‡ä»»åŠ¡**é‡æ–°å¤„ç†ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    // AcceptorExecutor.java
    void reprocess(List<TaskHolder<ID, T>> holders, ProcessingResult processingResult) {
       // æ·»åŠ åˆ° é‡æ–°æ‰§è¡Œé˜Ÿåˆ—
       reprocessQueue.addAll(holders);
    
       // TODO èŠ‹è‰¿ï¼šç›‘æ§ç›¸å…³ï¼Œæš‚æ—¶æ— è§†
       replayedTasks += holders.size();
       
       // æäº¤ä»»åŠ¡ç»“æœç»™ TrafficShaper
       trafficShaper.registerFailure(processingResult);
    }
    ```

## 10.2 å•ä»»åŠ¡å·¥ä½œçº¿ç¨‹

å•ä»»åŠ¡å·¥ä½œåå°çº¿ç¨‹( SingleTaskWorkerRunnable )æ‰§è¡Œ `#run(...)` æ–¹æ³•ï¼Œè°ƒåº¦ä»»åŠ¡ï¼Œå’Œ `BatchWorkerRunnable#run(...)` åŸºæœ¬ç±»ä¼¼ï¼Œå°±ä¸å•°å—¦äº†ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
@Override
// SingleTaskWorkerRunnable.java
public void run() {
  try {
      while (!isShutdown.get()) {
          // å‘èµ·è¯·æ±‚ä¿¡å·é‡ï¼Œå¹¶è·å¾—å•ä»»åŠ¡çš„å·¥ä½œé˜Ÿåˆ—
          BlockingQueue<TaskHolder<ID, T>> workQueue = taskDispatcher.requestWorkItem();
          TaskHolder<ID, T> taskHolder;
          // ã€å¾ªç¯ã€‘è·å–å•ä»»åŠ¡ï¼Œç›´åˆ°æˆåŠŸ
          while ((taskHolder = workQueue.poll(1, TimeUnit.SECONDS)) == null) {
              if (isShutdown.get()) {
                  return;
              }
          }
          // TODO èŠ‹è‰¿ï¼šç›‘æ§ç›¸å…³ï¼Œæš‚æ—¶æ— è§†
          metrics.registerExpiryTime(taskHolder);
          if (taskHolder != null) {
              // è°ƒç”¨å¤„ç†å™¨æ‰§è¡Œä»»åŠ¡
              ProcessingResult result = processor.process(taskHolder.getTask());
              switch (result) {
                  case Success:
                      break;
                  case Congestion:
                  case TransientError:
                      taskDispatcher.reprocess(taskHolder, result); // æäº¤é‡æ–°å¤„ç†
                      break;
                  case PermanentError:
                      logger.warn("Discarding a task of {} due to permanent error", workerName);
              }
              // TODO èŠ‹è‰¿ï¼šç›‘æ§ç›¸å…³ï¼Œæš‚æ—¶æ— è§†
              metrics.registerTaskResult(result, 1);
          }
      }
  } catch (InterruptedException e) {
      // Ignore
  } catch (Throwable e) {
      // Safe-guard, so we never exit this loop in an uncontrolled way.
      logger.warn("Discovery WorkerThread error", e);
  }
}
```

# 666. å½©è›‹

![çŸ¥è¯†æ˜Ÿçƒ](http://www.iocoder.cn/images/Architecture/2017_12_29/01.png)

ğŸ˜ˆ åˆæ˜¯ä¸€ç¯‡é•¿æ–‡ã€‚å»ºè®®è¾¹çœ‹ä»£ç ï¼Œè¾¹å¯¹ç…§ç€æ•´ä½“æµç¨‹å›¾ï¼Œç†è§£å®é™…ä¸éš¾ã€‚

å½“ç„¶ï¼Œæ¬¢è¿ä½ æœ‰ä»»ä½•ç–‘é—®ï¼Œåœ¨æˆ‘çš„å…¬ä¼—å·( **èŠ‹é“æºç ** ) ç•™è¨€ã€‚

èƒ–å‹ï¼Œåˆ†äº«æˆ‘çš„å…¬ä¼—å·( **èŠ‹é“æºç ** ) ç»™ä½ çš„èƒ–å‹å¯å¥½ï¼Ÿ

