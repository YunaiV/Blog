title: Eureka æºç è§£æ â€”â€” åº”ç”¨å®ä¾‹æ³¨å†Œå‘ç°ï¼ˆä¸€ï¼‰ä¹‹æ³¨å†Œ
date: 2018-05-28
tags:
categories: Eureka
permalink: Eureka/instance-registry-register

---

æ‘˜è¦: åŸåˆ›å‡ºå¤„ http://www.iocoder.cn/Eureka/instance-registry-register/ ã€ŒèŠ‹é“æºç ã€æ¬¢è¿è½¬è½½ï¼Œä¿ç•™æ‘˜è¦ï¼Œè°¢è°¢ï¼

**æœ¬æ–‡ä¸»è¦åŸºäº Eureka 1.8.X ç‰ˆæœ¬** 

- [1. æ¦‚è¿°](http://www.iocoder.cn/Eureka/instance-registry-register/)
- [2. Eureka-Client å‘èµ·æ³¨å†Œ](http://www.iocoder.cn/Eureka/instance-registry-register/)
  - [2.1 åº”ç”¨å®ä¾‹ä¿¡æ¯å¤åˆ¶å™¨](http://www.iocoder.cn/Eureka/instance-registry-register/)
  - [2.2 åˆ·æ–°åº”ç”¨å®ä¾‹ä¿¡æ¯](http://www.iocoder.cn/Eureka/instance-registry-register/)
  - [2.3 å‘èµ·æ³¨å†Œåº”ç”¨å®ä¾‹](http://www.iocoder.cn/Eureka/instance-registry-register/)
- [3. Eureka-Server æ¥æ”¶æ³¨å†Œ](http://www.iocoder.cn/Eureka/instance-registry-register/)
  - [3.1 æ¥æ”¶æ³¨å†Œè¯·æ±‚](http://www.iocoder.cn/Eureka/instance-registry-register/)
  - [3.2 Lease](http://www.iocoder.cn/Eureka/instance-registry-register/)
  - [3.3 æ³¨å†Œåº”ç”¨å®ä¾‹ä¿¡æ¯](http://www.iocoder.cn/Eureka/instance-registry-register/)
- [666. å½©è›‹](http://www.iocoder.cn/Eureka/instance-registry-register/)

---

![](http://www.iocoder.cn/images/common/wechat_mp_2018_05_18.jpg)

> ğŸ™‚ğŸ™‚ğŸ™‚å…³æ³¨**å¾®ä¿¡å…¬ä¼—å·ï¼šã€èŠ‹é“æºç ã€‘**æœ‰ç¦åˆ©ï¼š  
> 1. RocketMQ / MyCAT / Sharding-JDBC **æ‰€æœ‰**æºç åˆ†ææ–‡ç« åˆ—è¡¨  
> 2. RocketMQ / MyCAT / Sharding-JDBC **ä¸­æ–‡æ³¨é‡Šæºç  GitHub åœ°å€**  
> 3. æ‚¨å¯¹äºæºç çš„ç–‘é—®æ¯æ¡ç•™è¨€**éƒ½**å°†å¾—åˆ°**è®¤çœŸ**å›å¤ã€‚**ç”šè‡³ä¸çŸ¥é“å¦‚ä½•è¯»æºç ä¹Ÿå¯ä»¥è¯·æ•™å™¢**ã€‚  
> 4. **æ–°çš„**æºç è§£ææ–‡ç« **å®æ—¶**æ”¶åˆ°é€šçŸ¥ã€‚**æ¯å‘¨æ›´æ–°ä¸€ç¯‡å·¦å³**ã€‚  
> 5. **è®¤çœŸçš„**æºç äº¤æµå¾®ä¿¡ç¾¤ã€‚

-------

# 1. æ¦‚è¿°

æœ¬æ–‡ä¸»è¦åˆ†äº« **Eureka-Client å‘ Eureka-Server æ³¨å†Œåº”ç”¨å®ä¾‹çš„è¿‡ç¨‹**ã€‚

> FROM [ã€Šæ·±åº¦å‰–ææœåŠ¡å‘ç°ç»„ä»¶Netflix Eurekaã€‹](ã€Šhttp://techshow.ctrip.com/archives/1699.htmlã€‹) äºŒæ¬¡ç¼–è¾‘    
> ![](http://www.iocoder.cn/images/Eureka/2018_05_28/01.jpeg)

* **è“æ¡†**éƒ¨åˆ†ï¼Œä¸ºæœ¬æ–‡é‡ç‚¹ã€‚
* é**è“æ¡†**éƒ¨åˆ†ï¼ŒEureka-Server é›†ç¾¤é—´å¤åˆ¶æ³¨å†Œçš„åº”ç”¨å®ä¾‹ä¿¡æ¯ï¼Œä¸åœ¨æœ¬æ–‡å†…å®¹èŒƒç•´ã€‚

**æ¨è Spring Cloud ä¹¦ç±**ï¼š

* è¯·æ”¯æŒæ­£ç‰ˆã€‚ä¸‹è½½ç›—ç‰ˆï¼Œ**ç­‰äºä¸»åŠ¨ç¼–å†™ä½çº§ BUG** ã€‚
* ç¨‹åºçŒ¿DD â€”â€” [ã€ŠSpring Cloudå¾®æœåŠ¡å®æˆ˜ã€‹](https://union-click.jd.com/jdc?d=505Twi)
* å‘¨ç«‹ â€”â€” [ã€ŠSpring Cloudä¸Dockerå¾®æœåŠ¡æ¶æ„å®æˆ˜ã€‹](https://union-click.jd.com/jdc?d=k3sAaK)
* ä¸¤ä¹¦é½ä¹°ï¼Œäº¬ä¸œåŒ…é‚®ã€‚



# 2. Eureka-Client å‘èµ·æ³¨å†Œ

Eureka-Client å‘ Eureka-Server å‘èµ·æ³¨å†Œåº”ç”¨å®ä¾‹éœ€è¦ç¬¦åˆå¦‚ä¸‹æ¡ä»¶ï¼š

* é…ç½® `eureka.registration.enabled = true`ï¼ŒEureka-Client å‘ Eureka-Server å‘èµ·æ³¨å†Œåº”ç”¨å®ä¾‹çš„**å¼€å…³**ã€‚
* InstanceInfo åœ¨ Eureka-Client å’Œ Eureka-Server æ•°æ®ä¸ä¸€è‡´ã€‚

æ¯æ¬¡ InstanceInfo å‘ç”Ÿ**å±æ€§å˜åŒ–**æ—¶ï¼Œæ ‡è®° `isInstanceInfoDirty` å±æ€§ä¸º `true`ï¼Œè¡¨ç¤º InstanceInfo åœ¨ Eureka-Client å’Œ Eureka-Server æ•°æ®ä¸ä¸€è‡´ï¼Œéœ€è¦æ³¨å†Œã€‚å¦å¤–ï¼ŒInstanceInfo åˆšè¢«åˆ›å»ºæ—¶ï¼Œåœ¨ Eureka-Server ä¸å­˜åœ¨ï¼Œä¹Ÿä¼šè¢«æ³¨å†Œã€‚

å½“ç¬¦åˆæ¡ä»¶æ—¶ï¼ŒInstanceInfo ä¸ä¼šç«‹å³å‘ Eureka-Server æ³¨å†Œï¼Œè€Œæ˜¯åå°çº¿ç¨‹**å®šæ—¶**æ³¨å†Œã€‚

å½“ InstanceInfo çš„çŠ¶æ€( `status` ) å±æ€§å‘ç”Ÿå˜åŒ–æ—¶ï¼Œå¹¶ä¸”é…ç½® `eureka.shouldOnDemandUpdateStatusChange = true` æ—¶ï¼Œç«‹å³å‘ Eureka-Server æ³¨å†Œã€‚**å› ä¸ºçŠ¶æ€å±æ€§éå¸¸é‡è¦ï¼Œä¸€èˆ¬æƒ…å†µä¸‹å»ºè®®å¼€å¯ï¼Œå½“ç„¶é»˜è®¤æƒ…å†µä¹Ÿæ˜¯å¼€å¯çš„**ã€‚

Let's Goã€‚è®©æˆ‘ä»¬çœ‹çœ‹ä»£ç çš„å®ç°ã€‚

## 2.1 åº”ç”¨å®ä¾‹ä¿¡æ¯å¤åˆ¶å™¨

```Java
// DiscoveryClient.java
public class DiscoveryClient implements EurekaClient {

    /**
     * åº”ç”¨å®ä¾‹çŠ¶æ€å˜æ›´ç›‘å¬å™¨
     */
    private ApplicationInfoManager.StatusChangeListener statusChangeListener;
    /**
     * åº”ç”¨å®ä¾‹ä¿¡æ¯å¤åˆ¶å™¨
     */
    private InstanceInfoReplicator instanceInfoReplicator;

    private void initScheduledTasks() {
        // ... çœç•¥æ— å…³ä»£ç 
        
        if (clientConfig.shouldRegisterWithEureka()) {
        
            // ... çœç•¥æ— å…³ä»£ç 
            
            // åˆ›å»º åº”ç”¨å®ä¾‹ä¿¡æ¯å¤åˆ¶å™¨
            // InstanceInfo replicator
            instanceInfoReplicator = new InstanceInfoReplicator(
                    this,
                    instanceInfo,
                    clientConfig.getInstanceInfoReplicationIntervalSeconds(),
                    2); // burstSize

            // åˆ›å»º åº”ç”¨å®ä¾‹çŠ¶æ€å˜æ›´ç›‘å¬å™¨
            statusChangeListener = new ApplicationInfoManager.StatusChangeListener() {
                @Override
                public String getId() {
                    return "statusChangeListener";
                }

                @Override
                public void notify(StatusChangeEvent statusChangeEvent) {
                    if (InstanceStatus.DOWN == statusChangeEvent.getStatus() ||
                            InstanceStatus.DOWN == statusChangeEvent.getPreviousStatus()) {
                        // log at warn level if DOWN was involved
                        logger.warn("Saw local status change event {}", statusChangeEvent);
                    } else {
                        logger.info("Saw local status change event {}", statusChangeEvent);
                    }
                    instanceInfoReplicator.onDemandUpdate();
                }
            };

            // æ³¨å†Œ åº”ç”¨å®ä¾‹çŠ¶æ€å˜æ›´ç›‘å¬å™¨
            if (clientConfig.shouldOnDemandUpdateStatusChange()) {
                applicationInfoManager.registerStatusChangeListener(statusChangeListener);
            }

            // å¼€å¯ åº”ç”¨å®ä¾‹ä¿¡æ¯å¤åˆ¶å™¨
            instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds());
        }
    
    }

}
```

* `com.netflix.discovery.InstanceInfoReplicator`ï¼Œåº”ç”¨å®ä¾‹ä¿¡æ¯å¤åˆ¶å™¨ã€‚

    * è°ƒç”¨ `InstanceInfoReplicator#start(...)` æ–¹æ³•ï¼Œ**å¼€å¯**åº”ç”¨å®ä¾‹ä¿¡æ¯å¤åˆ¶å™¨ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

        ```Java
        // InstanceInfoReplicator.java
        class InstanceInfoReplicator implements Runnable {
        
            private static final Logger logger = LoggerFactory.getLogger(InstanceInfoReplicator.class);
        
            private final DiscoveryClient discoveryClient;
            /**
             * åº”ç”¨å®ä¾‹ä¿¡æ¯
             */
            private final InstanceInfo instanceInfo;
            /**
             * å®šæ—¶æ‰§è¡Œé¢‘ç‡ï¼Œå•ä½ï¼šç§’
             */
            private final int replicationIntervalSeconds;
            /**
             * å®šæ—¶æ‰§è¡Œå™¨
             */
            private final ScheduledExecutorService scheduler;
            /**
             * å®šæ—¶æ‰§è¡Œä»»åŠ¡çš„ Future
             */
            private final AtomicReference<Future> scheduledPeriodicRef;
            /**
             * æ˜¯å¦å¼€å¯è°ƒåº¦
             */
            private final AtomicBoolean started;
        
            private final RateLimiter rateLimiter; // é™æµç›¸å…³ï¼Œè·³è¿‡
            private final int burstSize; // é™æµç›¸å…³ï¼Œè·³è¿‡
            private final int allowedRatePerMinute; // é™æµç›¸å…³ï¼Œè·³è¿‡
        
            InstanceInfoReplicator(DiscoveryClient discoveryClient, InstanceInfo instanceInfo, int replicationIntervalSeconds, int burstSize) {
                this.discoveryClient = discoveryClient;
                this.instanceInfo = instanceInfo;
                this.scheduler = Executors.newScheduledThreadPool(1,
                        new ThreadFactoryBuilder()
                                .setNameFormat("DiscoveryClient-InstanceInfoReplicator-%d")
                                .setDaemon(true)
                                .build());
        
                this.scheduledPeriodicRef = new AtomicReference<Future>();
        
                this.started = new AtomicBoolean(false);
                this.rateLimiter = new RateLimiter(TimeUnit.MINUTES);
                this.replicationIntervalSeconds = replicationIntervalSeconds;
                this.burstSize = burstSize;
        
                this.allowedRatePerMinute = 60 * this.burstSize / this.replicationIntervalSeconds;
                logger.info("InstanceInfoReplicator onDemand update allowed rate per min is {}", allowedRatePerMinute);
            }
        
            public void start(int initialDelayMs) {
                if (started.compareAndSet(false, true)) {
                    // è®¾ç½® åº”ç”¨å®ä¾‹ä¿¡æ¯ æ•°æ®ä¸ä¸€è‡´
                    instanceInfo.setIsDirty();  // for initial register
                    // æäº¤ä»»åŠ¡ï¼Œå¹¶è®¾ç½®è¯¥ä»»åŠ¡çš„ Future
                    Future next = scheduler.schedule(this, initialDelayMs, TimeUnit.SECONDS);
                    scheduledPeriodicRef.set(next);
                }
            }
            
            // ... çœç•¥æ— å…³æ–¹æ³•
        }
        
        // InstanceInfo.java
        private volatile boolean isInstanceInfoDirty = false;
        private volatile Long lastDirtyTimestamp;
        
        public synchronized void setIsDirty() {
           isInstanceInfoDirty = true;
           lastDirtyTimestamp = System.currentTimeMillis();
        }
        ```
        * æ‰§è¡Œ `instanceInfo.setIsDirty()` ä»£ç å—ï¼Œå› ä¸º **InstanceInfo åˆšè¢«åˆ›å»ºæ—¶ï¼Œåœ¨ Eureka-Server ä¸å­˜åœ¨ï¼Œä¹Ÿä¼šè¢«æ³¨å†Œ**ã€‚
        * è°ƒç”¨ `ScheduledExecutorService#schedule(...)` æ–¹æ³•ï¼Œå»¶è¿Ÿ `initialDelayMs` æ¯«ç§’æ‰§è¡Œ**ä¸€æ¬¡**ä»»åŠ¡ã€‚ä¸ºä»€ä¹ˆæ­¤å¤„è®¾ç½® `scheduledPeriodicRef` ï¼Ÿåœ¨ `InstanceInfoReplicator#onDemandUpdate()` æ–¹æ³•ä¼šçœ‹åˆ°å…·ä½“ç”¨é€”ã€‚

    * **å®šæ—¶**æ£€æŸ¥ InstanceInfo çš„çŠ¶æ€( `status` ) å±æ€§æ˜¯å¦å‘ç”Ÿå˜åŒ–ã€‚**è‹¥æ˜¯**ï¼Œå‘èµ·æ³¨å†Œã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

        ```Java
        // InstanceInfoReplicator.java
        @Override
        public void run() {
           try {
               // åˆ·æ–° åº”ç”¨å®ä¾‹ä¿¡æ¯
               discoveryClient.refreshInstanceInfo();
               // åˆ¤æ–­ åº”ç”¨å®ä¾‹ä¿¡æ¯ æ˜¯å¦æ•°æ®ä¸ä¸€è‡´
               Long dirtyTimestamp = instanceInfo.isDirtyWithTime();
               if (dirtyTimestamp != null) {
                   // å‘èµ·æ³¨å†Œ
                   discoveryClient.register();
                   // è®¾ç½® åº”ç”¨å®ä¾‹ä¿¡æ¯ æ•°æ®ä¸€è‡´
                   instanceInfo.unsetIsDirty(dirtyTimestamp);
               }
           } catch (Throwable t) {
               logger.warn("There was a problem with the instance info replicator", t);
           } finally {
               // æäº¤ä»»åŠ¡ï¼Œå¹¶è®¾ç½®è¯¥ä»»åŠ¡çš„ Future
               Future next = scheduler.schedule(this, replicationIntervalSeconds, TimeUnit.SECONDS);
               scheduledPeriodicRef.set(next);
           }
        }
        
        // InstanceInfo.java
        public synchronized long setIsDirtyWithTime() {
           setIsDirty();
           return lastDirtyTimestamp;
        }
        
        public synchronized void unsetIsDirty(long unsetDirtyTimestamp) {
           if (lastDirtyTimestamp <= unsetDirtyTimestamp) {
               isInstanceInfoDirty = false;
           } else {
           }
        }
        ```
        * è°ƒç”¨ `DiscoveryClient#refreshInstanceInfo()` æ–¹æ³•ï¼Œåˆ·æ–°åº”ç”¨å®ä¾‹ä¿¡æ¯ã€‚**æ­¤å¤„å¯èƒ½å¯¼è‡´åº”ç”¨å®ä¾‹ä¿¡æ¯æ•°æ®ä¸ä¸€è‡´**ï¼Œåœ¨[ã€Œ2.2ã€åˆ·æ–°åº”ç”¨å®ä¾‹ä¿¡æ¯](#) è¯¦ç»†è§£æã€‚
        * è°ƒç”¨ `DiscoveryClient#register()` æ–¹æ³•ï¼Œ**Eureka-Client å‘ Eureka-Server æ³¨å†Œåº”ç”¨å®ä¾‹**ã€‚
        * è°ƒç”¨ `ScheduledExecutorService#schedule(...)` æ–¹æ³•ï¼Œå†æ¬¡å»¶è¿Ÿæ‰§è¡Œä»»åŠ¡ï¼Œå¹¶è®¾ç½® `scheduledPeriodicRef`ã€‚é€šè¿‡è¿™æ ·çš„æ–¹å¼ï¼Œä¸æ–­**å¾ªç¯**å®šæ—¶æ‰§è¡Œä»»åŠ¡ã€‚

* `com.netflix.appinfo.ApplicationInfoManager.StatusChangeListener` **å†…éƒ¨ç±»**ï¼Œç›‘å¬åº”ç”¨å®ä¾‹ä¿¡æ¯çŠ¶æ€çš„å˜æ›´ã€‚
    * è°ƒç”¨ `ApplicationInfoManager#registerStatusChangeListener(...)` æ–¹æ³•ï¼Œæ³¨å†Œåº”ç”¨å®ä¾‹çŠ¶æ€å˜æ›´ç›‘å¬å™¨ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

        ```Java
        public class ApplicationInfoManager {
        
            /**
             * çŠ¶æ€å˜æ›´ç›‘å¬å™¨
             */
            protected final Map<String, StatusChangeListener> listeners;
            
            public void registerStatusChangeListener(StatusChangeListener listener) {
                listeners.put(listener.getId(), listener);
            }
        }   
        ```

    * **ä¸šåŠ¡é‡Œ**ï¼Œè°ƒç”¨ `ApplicationInfoManager#setInstanceStatus(...)` æ–¹æ³•ï¼Œè®¾ç½®åº”ç”¨å®ä¾‹ä¿¡æ¯çš„çŠ¶æ€ï¼Œä»è€Œ**é€šçŸ¥** `InstanceInfoReplicator#onDemandUpdate()` æ–¹æ³•çš„è°ƒç”¨ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

        ```Java
        // ApplicationInfoManager.java
        public synchronized void setInstanceStatus(InstanceStatus status) {
           InstanceStatus next = instanceStatusMapper.map(status);
           if (next == null) {
               return;
           }
           InstanceStatus prev = instanceInfo.setStatus(next);
           if (prev != null) {
               for (StatusChangeListener listener : listeners.values()) {
                   try {
                       listener.notify(new StatusChangeEvent(prev, next));
                   } catch (Exception e) {
                       logger.warn("failed to notify listener: {}", listener.getId(), e);
                   }
               }
           }
        }
        
        // InstanceInfo.java
        public synchronized InstanceStatus setStatus(InstanceStatus status) {
           if (this.status != status) {
               InstanceStatus prev = this.status;
               this.status = status;
               // è®¾ç½® åº”ç”¨å®ä¾‹ä¿¡æ¯ æ•°æ®ä¸€è‡´
               setIsDirty();
               return prev;
           }
           return null;
        }
        ```

    * `InstanceInfoReplicator#onDemandUpdate()`ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

        ```Java
        // InstanceInfoReplicator.java
        public boolean onDemandUpdate() {
           if (rateLimiter.acquire(burstSize, allowedRatePerMinute)) { // é™æµç›¸å…³ï¼Œè·³è¿‡
               scheduler.submit(new Runnable() {
                   @Override
                   public void run() {
                       logger.debug("Executing on-demand update of local InstanceInfo");
                       // å–æ¶ˆä»»åŠ¡
                       Future latestPeriodic = scheduledPeriodicRef.get();
                       if (latestPeriodic != null && !latestPeriodic.isDone()) {
                           logger.debug("Canceling the latest scheduled update, it will be rescheduled at the end of on demand update");
                           latestPeriodic.cancel(false);
                       }
                       // å†æ¬¡è°ƒç”¨
                       InstanceInfoReplicator.this.run();
                   }
               });
               return true;
           } else {
               logger.warn("Ignoring onDemand update due to rate limiter");
               return false;
           }
        }    
        ```
        * è°ƒç”¨ `Future#cancel(false)` æ–¹æ³•ï¼Œå–æ¶ˆå®šæ—¶ä»»åŠ¡ï¼Œ**é¿å…æ— ç”¨çš„æ³¨å†Œ**ã€‚
        * è°ƒç”¨ `InstanceInfoReplicator#run()` æ–¹æ³•ï¼Œå‘èµ·æ³¨å†Œã€‚

## 2.2 åˆ·æ–°åº”ç”¨å®ä¾‹ä¿¡æ¯

è°ƒç”¨ `DiscoveryClient#refreshInstanceInfo()` æ–¹æ³•ï¼Œåˆ·æ–°åº”ç”¨å®ä¾‹ä¿¡æ¯ã€‚**æ­¤å¤„å¯èƒ½å¯¼è‡´åº”ç”¨å®ä¾‹ä¿¡æ¯æ•°æ®ä¸ä¸€è‡´**ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
void refreshInstanceInfo() {
   // åˆ·æ–° æ•°æ®ä¸­å¿ƒä¿¡æ¯
   applicationInfoManager.refreshDataCenterInfoIfRequired();
   // åˆ·æ–° ç§Ÿçº¦ä¿¡æ¯
   applicationInfoManager.refreshLeaseInfoIfRequired();
   // å¥åº·æ£€æŸ¥
   InstanceStatus status;
   try {
       status = getHealthCheckHandler().getStatus(instanceInfo.getStatus());
   } catch (Exception e) {
       logger.warn("Exception from healthcheckHandler.getStatus, setting status to DOWN", e);
       status = InstanceStatus.DOWN;
   }
   if (null != status) {
       applicationInfoManager.setInstanceStatus(status);
   }
}
```

* è°ƒç”¨ `ApplicationInfoManager#refreshDataCenterInfoIfRequired()` æ–¹æ³•ï¼Œåˆ·æ–°æ•°æ®ä¸­å¿ƒç›¸å…³ä¿¡æ¯ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    // ApplicationInfoManager.java
    public void refreshDataCenterInfoIfRequired() {
       // hostname
       String existingAddress = instanceInfo.getHostName();
       String newAddress;
       if (config instanceof RefreshableInstanceConfig) {
           // Refresh data center info, and return up to date address
           newAddress = ((RefreshableInstanceConfig) config).resolveDefaultAddress(true);
       } else {
           newAddress = config.getHostName(true);
       }
       // ip
       String newIp = config.getIpAddress();
       if (newAddress != null && !newAddress.equals(existingAddress)) {
           logger.warn("The address changed from : {} => {}", existingAddress, newAddress);
           // :( in the legacy code here the builder is acting as a mutator.
           // This is hard to fix as this same instanceInfo instance is referenced elsewhere.
           // We will most likely re-write the client at sometime so not fixing for now.
           InstanceInfo.Builder builder = new InstanceInfo.Builder(instanceInfo);
           builder.setHostName(newAddress) // hostname
                   .setIPAddr(newIp) // ip
                   .setDataCenterInfo(config.getDataCenterInfo()); // dataCenterInfo
           instanceInfo.setIsDirty();
       }
    }
    
    public abstract class AbstractInstanceConfig implements EurekaInstanceConfig {
    
        private static final Pair<String, String> hostInfo = getHostInfo();
        
        @Override
        public String getHostName(boolean refresh) {
            return hostInfo.second();
        }
        
        @Override
        public String getIpAddress() {
            return hostInfo.first();
        }

        private static Pair<String, String> getHostInfo() {
            Pair<String, String> pair;
            try {
                InetAddress localHost = InetAddress.getLocalHost();
                pair = new Pair<String, String>(localHost.getHostAddress(), localHost.getHostName());
            } catch (UnknownHostException e) {
                logger.error("Cannot get host info", e);
                pair = new Pair<String, String>("", "");
            }
            return pair;
        }
        
    }
    ```
    * å…³æ³¨åº”ç”¨å®ä¾‹ä¿¡æ¯çš„ `hostName` ã€ `ipAddr` ã€ `dataCenterInfo` å±æ€§çš„å˜åŒ–ã€‚ 
    * ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯é RefreshableInstanceConfig å®ç°çš„é…ç½®ç±»( ä¸€èˆ¬æ˜¯ MyDataCenterInstanceConfig )ï¼Œå› ä¸º `AbstractInstanceConfig.hostInfo` æ˜¯**é™æ€å±æ€§**ï¼Œ**å³ä½¿æœ¬æœºä¿®æ”¹äº† IP ç­‰ä¿¡æ¯ï¼ŒEureka-Client è¿›ç¨‹ä¹Ÿä¸ä¼šæ„ŸçŸ¥åˆ°**ã€‚TODO[0022]ï¼šçœ‹ä¸‹springcloud çš„å®ç°

* è°ƒç”¨ `ApplicationInfoManager#refreshLeaseInfoIfRequired()` æ–¹æ³•ï¼Œåˆ·æ–°ç§Ÿçº¦ç›¸å…³ä¿¡æ¯ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    public void refreshLeaseInfoIfRequired() {
       LeaseInfo leaseInfo = instanceInfo.getLeaseInfo();
       if (leaseInfo == null) {
           return;
       }
       int currentLeaseDuration = config.getLeaseExpirationDurationInSeconds();
       int currentLeaseRenewal = config.getLeaseRenewalIntervalInSeconds();
       if (leaseInfo.getDurationInSecs() != currentLeaseDuration // ç§Ÿçº¦è¿‡æœŸæ—¶é—´ æ”¹å˜
               || leaseInfo.getRenewalIntervalInSecs() != currentLeaseRenewal) { // ç§Ÿçº¦ç»­çº¦é¢‘ç‡ æ”¹å˜
           LeaseInfo newLeaseInfo = LeaseInfo.Builder.newBuilder()
                   .setRenewalIntervalInSecs(currentLeaseRenewal)
                   .setDurationInSecs(currentLeaseDuration)
                   .build();
           instanceInfo.setLeaseInfo(newLeaseInfo);
           instanceInfo.setIsDirty();
       }
    }
    ```
    * å…³æ³¨åº”ç”¨å®ä¾‹ä¿¡æ¯çš„ `renewalIntervalInSecs` ã€ `durationInSecs` å±æ€§çš„å˜åŒ–ã€‚

* è°ƒç”¨ `HealthCheckHandler#getStatus()` æ–¹æ³•ï¼Œå¥åº·æ£€æŸ¥ã€‚è¿™é‡Œå…ˆæš‚æ—¶è·³è¿‡ï¼Œæˆ‘ä»¬åœ¨[TODO[0004]ï¼šå¥åº·æ£€æŸ¥](#) è¯¦ç»†è§£æã€‚

## 2.3 å‘èµ·æ³¨å†Œåº”ç”¨å®ä¾‹

è°ƒç”¨ `DiscoveryClient#register()` æ–¹æ³•ï¼Œ**Eureka-Client å‘ Eureka-Server æ³¨å†Œåº”ç”¨å®ä¾‹**ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
// DiscoveryClient.java
boolean register() throws Throwable {
   logger.info(PREFIX + appPathIdentifier + ": registering service...");
   EurekaHttpResponse<Void> httpResponse;
   try {
       httpResponse = eurekaTransport.registrationClient.register(instanceInfo);
   } catch (Exception e) {
       logger.warn("{} - registration failed {}", PREFIX + appPathIdentifier, e.getMessage(), e);
       throw e;
   }
   if (logger.isInfoEnabled()) {
       logger.info("{} - registration status: {}", PREFIX + appPathIdentifier, httpResponse.getStatusCode());
   }
   return httpResponse.getStatusCode() == 204;
}

// AbstractJerseyEurekaHttpClient.java
@Override
public EurekaHttpResponse<Void> register(InstanceInfo info) {
   String urlPath = "apps/" + info.getAppName();
   ClientResponse response = null;
   try {
       Builder resourceBuilder = jerseyClient.resource(serviceUrl).path(urlPath).getRequestBuilder();
       addExtraHeaders(resourceBuilder);
       response = resourceBuilder
               .header("Accept-Encoding", "gzip")
               .type(MediaType.APPLICATION_JSON_TYPE)
               .accept(MediaType.APPLICATION_JSON)
               .post(ClientResponse.class, info);
       return anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build();
   } finally {
       if (logger.isDebugEnabled()) {
           logger.debug("Jersey HTTP POST {}/{} with instance {}; statusCode={}", serviceUrl, urlPath, info.getId(),
                   response == null ? "N/A" : response.getStatus());
       }
       if (response != null) {
           response.close();
       }
   }
}
```

* è°ƒç”¨ `AbstractJerseyEurekaHttpClient#register(...)` æ–¹æ³•ï¼Œ`POST` è¯·æ±‚ Eureka-Server çš„ `apps/${APP_NAME}` æ¥å£ï¼Œå‚æ•°ä¸º InstanceInfo ï¼Œå®ç°æ³¨å†Œå®ä¾‹ä¿¡æ¯çš„æ³¨å†Œã€‚

# 3. Eureka-Server æ¥æ”¶æ³¨å†Œ

## 3.1 æ¥æ”¶æ³¨å†Œè¯·æ±‚

`com.netflix.eureka.resources.ApplicationResource`ï¼Œå¤„ç†**å•ä¸ª**åº”ç”¨çš„è¯·æ±‚æ“ä½œçš„ Resource ( Controller )ã€‚

æ³¨å†Œåº”ç”¨å®ä¾‹ä¿¡æ¯çš„è¯·æ±‚ï¼Œæ˜ å°„ `ApplicationResource#addInstance()` æ–¹æ³•ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
@Produces({"application/xml", "application/json"})
public class ApplicationResource {

    @POST
    @Consumes({"application/json", "application/xml"})
    public Response addInstance(InstanceInfo info,
                                @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication) {
        // æ ¡éªŒå‚æ•°æ˜¯å¦åˆæ³•
        logger.debug("Registering instance {} (replication={})", info.getId(), isReplication);
        // validate that the instanceinfo contains all the necessary required fields
        if (isBlank(info.getId())) {
            return Response.status(400).entity("Missing instanceId").build();
        } else if (isBlank(info.getHostName())) {
            return Response.status(400).entity("Missing hostname").build();
        } else if (isBlank(info.getIPAddr())) {
            return Response.status(400).entity("Missing ip address").build();
        } else if (isBlank(info.getAppName())) {
            return Response.status(400).entity("Missing appName").build();
        } else if (!appName.equals(info.getAppName())) {
            return Response.status(400).entity("Mismatched appName, expecting " + appName + " but was " + info.getAppName()).build();
        } else if (info.getDataCenterInfo() == null) {
            return Response.status(400).entity("Missing dataCenterInfo").build();
        } else if (info.getDataCenterInfo().getName() == null) {
            return Response.status(400).entity("Missing dataCenterInfo Name").build();
        }

        // AWS ç›¸å…³ï¼Œè·³è¿‡
        // handle cases where clients may be registering with bad DataCenterInfo with missing data
        DataCenterInfo dataCenterInfo = info.getDataCenterInfo();
        if (dataCenterInfo instanceof UniqueIdentifier) {
            String dataCenterInfoId = ((UniqueIdentifier) dataCenterInfo).getId();
            if (isBlank(dataCenterInfoId)) {
                boolean experimental = "true".equalsIgnoreCase(serverConfig.getExperimental("registration.validation.dataCenterInfoId"));
                if (experimental) {
                    String entity = "DataCenterInfo of type " + dataCenterInfo.getClass() + " must contain a valid id";
                    return Response.status(400).entity(entity).build();
                } else if (dataCenterInfo instanceof AmazonInfo) {
                    AmazonInfo amazonInfo = (AmazonInfo) dataCenterInfo;
                    String effectiveId = amazonInfo.get(AmazonInfo.MetaDataKey.instanceId);
                    if (effectiveId == null) {
                        amazonInfo.getMetadata().put(AmazonInfo.MetaDataKey.instanceId.getName(), info.getId());
                    }
                } else {
                    logger.warn("Registering DataCenterInfo of type {} without an appropriate id", dataCenterInfo.getClass());
                }
            }
        }

        // æ³¨å†Œåº”ç”¨å®ä¾‹ä¿¡æ¯
        registry.register(info, "true".equals(isReplication));

        // è¿”å› 204 æˆåŠŸ
        return Response.status(204).build();  // 204 to be backwards compatible
    }

}
```

* è¯·æ±‚å¤´ `isReplication` å‚æ•°ï¼Œå’Œ Eureka-Server é›†ç¾¤å¤åˆ¶ç›¸å…³ï¼Œæš‚æ—¶è·³è¿‡ã€‚
* è°ƒç”¨ `PeerAwareInstanceRegistryImpl#register(...)` æ–¹æ³•ï¼Œæ³¨å†Œåº”ç”¨å®ä¾‹ä¿¡æ¯ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    @Override
    public void register(final InstanceInfo info, final boolean isReplication) {
       // ç§Ÿçº¦è¿‡æœŸæ—¶é—´
       int leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;
       if (info.getLeaseInfo() != null && info.getLeaseInfo().getDurationInSecs() > 0) {
           leaseDuration = info.getLeaseInfo().getDurationInSecs();
       }
       // æ³¨å†Œåº”ç”¨å®ä¾‹ä¿¡æ¯
       super.register(info, leaseDuration, isReplication);
       // Eureka-Server å¤åˆ¶
       replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, null, isReplication);
    }
    ```
    * è°ƒç”¨çˆ¶ç±» `AbstractInstanceRegistry#register(...)` æ–¹æ³•ï¼Œæ³¨å†Œåº”ç”¨å®ä¾‹ä¿¡æ¯ã€‚

## 3.2 Lease

åœ¨çœ‹å…·ä½“çš„æ³¨å†Œåº”ç”¨å®ä¾‹ä¿¡æ¯çš„é€»è¾‘ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹ä¸‹ `com.netflix.eureka.lease.Lease`ï¼Œç§Ÿçº¦ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
public class Lease<T> {

    /**
     * å®ä½“
     */
    private T holder;
    /**
     * æ³¨å†Œæ—¶é—´æˆ³
     */
    private long registrationTimestamp;
    /**
     * å¼€å§‹æœåŠ¡æ—¶é—´æˆ³
     */
    private long serviceUpTimestamp;
    /**
     * å–æ¶ˆæ³¨å†Œæ—¶é—´æˆ³
     */
    private long evictionTimestamp;
    /**
     * æœ€åæ›´æ–°æ—¶é—´æˆ³
     */
    // Make it volatile so that the expiration task would see this quicker
    private volatile long lastUpdateTimestamp;
    /**
     * ç§Ÿçº¦æŒç»­æ—¶é•¿ï¼Œå•ä½ï¼šæ¯«ç§’
     */
    private long duration;

    public Lease(T r, int durationInSecs) {
        holder = r;
        registrationTimestamp = System.currentTimeMillis();
        lastUpdateTimestamp = registrationTimestamp;
        duration = (durationInSecs * 1000);
    }
    
}
```

* `holder` å±æ€§ï¼Œç§Ÿçº¦çš„æŒæœ‰è€…ã€‚åœ¨ Eureka-Server é‡Œï¼Œæš‚æ—¶åªæœ‰ InstanceInfo ä½¿ç”¨ã€‚
* `registrationTimestamp` å±æ€§ï¼Œæ³¨å†Œ( åˆ›å»º )ç§Ÿçº¦æ—¶é—´æˆ³ã€‚åœ¨**æ„é€ æ–¹æ³•**é‡Œå¯ä»¥çœ‹ç§Ÿçº¦å¯¹è±¡çš„åˆ›å»ºæ—¶é—´æˆ³å³ä¸ºæ³¨å†Œç§Ÿçº¦æ—¶é—´æˆ³ã€‚
* `serviceUpTimestamp` å±æ€§ï¼Œå¼€å§‹æœåŠ¡æ—¶é—´æˆ³ã€‚æ³¨å†Œåº”ç”¨å®ä¾‹ä¿¡æ¯ä¼šä½¿ç”¨åˆ°å®ƒå¦‚ä¸‹ä¸¤ä¸ªæ–¹æ³•ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    public void serviceUp() {
       if (serviceUpTimestamp == 0) { // ç¬¬ä¸€æ¬¡æœ‰æ•ˆ
           serviceUpTimestamp = System.currentTimeMillis();
       }
    }
    
    public void setServiceUpTimestamp(long serviceUpTimestamp) {
        this.serviceUpTimestamp = serviceUpTimestamp;
    }
    ```

* `lastUpdatedTimestamp` å±æ€§ï¼Œæœ€åæ›´æ–°ç§Ÿçº¦æ—¶é—´æˆ³ã€‚æ¯æ¬¡ç»­ç§Ÿæ—¶ï¼Œæ›´æ–°è¯¥æ—¶é—´æˆ³ã€‚æ³¨å†Œåº”ç”¨å®ä¾‹ä¿¡æ¯ä¼šä½¿ç”¨åˆ°å®ƒå¦‚ä¸‹æ–¹æ³•ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    public void setLastUpdatedTimestamp() {
       this.lastUpdatedTimestamp = System.currentTimeMillis();
    }
    ```

* `duration` å±æ€§ï¼Œç§Ÿçº¦æŒç»­æ—¶é—´ï¼Œå•ä½ï¼šæ¯«ç§’ã€‚å½“ç§Ÿçº¦è¿‡ä¹…æœªç»­ç§Ÿï¼Œå³å½“å‰æ—¶é—´ - `lastUpdatedTimestamp` > `duration` æ—¶ï¼Œç§Ÿçº¦è¿‡æœŸã€‚
* `evictionTimestamp` å±æ€§ï¼Œç§Ÿçº¦è¿‡æœŸæ—¶é—´æˆ³ã€‚

## 3.3 æ³¨å†Œåº”ç”¨å®ä¾‹ä¿¡æ¯

è°ƒç”¨ `AbstractInstanceRegistry#register(...)` æ–¹æ³•ï¼Œæ³¨å†Œåº”ç”¨å®ä¾‹ä¿¡æ¯ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
  1: public void register(InstanceInfo registrant, int leaseDuration, boolean isReplication) {
  2:     try {
  3:         // è·å–è¯»é”
  4:         read.lock();
  5:         Map<String, Lease<InstanceInfo>> gMap = registry.get(registrant.getAppName());
  6:         // å¢åŠ  æ³¨å†Œæ¬¡æ•° åˆ° ç›‘æ§
  7:         REGISTER.increment(isReplication);
  8:         // è·å¾— åº”ç”¨å®ä¾‹ä¿¡æ¯ å¯¹åº”çš„ ç§Ÿçº¦
  9:         if (gMap == null) {
 10:             final ConcurrentHashMap<String, Lease<InstanceInfo>> gNewMap = new ConcurrentHashMap<String, Lease<InstanceInfo>>();
 11:             gMap = registry.putIfAbsent(registrant.getAppName(), gNewMap); // æ·»åŠ  åº”ç”¨
 12:             if (gMap == null) { // æ·»åŠ  åº”ç”¨ æˆåŠŸ
 13:                 gMap = gNewMap;
 14:             }
 15:         }
 16:         Lease<InstanceInfo> existingLease = gMap.get(registrant.getId());
 17:         // Retain the last dirty timestamp without overwriting it, if there is already a lease
 18:         if (existingLease != null && (existingLease.getHolder() != null)) { // å·²å­˜åœ¨æ—¶ï¼Œä½¿ç”¨æ•°æ®ä¸ä¸€è‡´çš„æ—¶é—´å¤§çš„åº”ç”¨æ³¨å†Œä¿¡æ¯ä¸ºæœ‰æ•ˆçš„
 19:             Long existingLastDirtyTimestamp = existingLease.getHolder().getLastDirtyTimestamp(); // Server æ³¨å†Œçš„ InstanceInfo
 20:             Long registrationLastDirtyTimestamp = registrant.getLastDirtyTimestamp(); // Client è¯·æ±‚çš„ InstanceInfo
 21:             logger.debug("Existing lease found (existing={}, provided={}", existingLastDirtyTimestamp, registrationLastDirtyTimestamp);
 22: 
 23:             // this is a > instead of a >= because if the timestamps are equal, we still take the remote transmitted
 24:             // InstanceInfo instead of the server local copy.
 25:             if (existingLastDirtyTimestamp > registrationLastDirtyTimestamp) {
 26:                 logger.warn("There is an existing lease and the existing lease's dirty timestamp {} is greater" +
 27:                         " than the one that is being registered {}", existingLastDirtyTimestamp, registrationLastDirtyTimestamp);
 28:                 logger.warn("Using the existing instanceInfo instead of the new instanceInfo as the registrant");
 29:                 registrant = existingLease.getHolder();
 30:             }
 31:         } else {
 32:             // The lease does not exist and hence it is a new registration
 33:             // ã€è‡ªæˆ‘ä¿æŠ¤æœºåˆ¶ã€‘å¢åŠ  `numberOfRenewsPerMinThreshold` ã€`expectedNumberOfRenewsPerMin`
 34:             synchronized (lock) {
 35:                 if (this.expectedNumberOfRenewsPerMin > 0) {
 36:                     // Since the client wants to cancel it, reduce the threshold
 37:                     // (1
 38:                     // for 30 seconds, 2 for a minute)
 39:                     this.expectedNumberOfRenewsPerMin = this.expectedNumberOfRenewsPerMin + 2;
 40:                     this.numberOfRenewsPerMinThreshold =
 41:                             (int) (this.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());
 42:                 }
 43:             }
 44:             logger.debug("No previous lease information found; it is new registration");
 45:         }
 46:         // åˆ›å»º ç§Ÿçº¦
 47:         Lease<InstanceInfo> lease = new Lease<InstanceInfo>(registrant, leaseDuration);
 48:         if (existingLease != null) { // è‹¥ç§Ÿçº¦å·²å­˜åœ¨ï¼Œè®¾ç½® ç§Ÿçº¦çš„å¼€å§‹æœåŠ¡çš„æ—¶é—´æˆ³
 49:             lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());
 50:         }
 51:         // æ·»åŠ åˆ° ç§Ÿçº¦æ˜ å°„
 52:         gMap.put(registrant.getId(), lease);
 53:         // æ·»åŠ åˆ° æœ€è¿‘æ³¨å†Œçš„è°ƒè¯•é˜Ÿåˆ—
 54:         synchronized (recentRegisteredQueue) {
 55:             recentRegisteredQueue.add(new Pair<Long, String>(
 56:                     System.currentTimeMillis(),
 57:                     registrant.getAppName() + "(" + registrant.getId() + ")"));
 58:         }
 59:         // æ·»åŠ åˆ° åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€æ˜ å°„ï¼ˆEureka-Server åˆå§‹åŒ–ä½¿ç”¨ï¼‰
 60:         // This is where the initial state transfer of overridden status happens
 61:         if (!InstanceStatus.UNKNOWN.equals(registrant.getOverriddenStatus())) {
 62:             logger.debug("Found overridden status {} for instance {}. Checking to see if needs to be add to the "
 63:                             + "overrides", registrant.getOverriddenStatus(), registrant.getId());
 64:             if (!overriddenInstanceStatusMap.containsKey(registrant.getId())) {
 65:                 logger.info("Not found overridden id {} and hence adding it", registrant.getId());
 66:                 overriddenInstanceStatusMap.put(registrant.getId(), registrant.getOverriddenStatus());
 67:             }
 68:         }
 69:         InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(registrant.getId());
 70:         if (overriddenStatusFromMap != null) {
 71:             logger.info("Storing overridden status {} from map", overriddenStatusFromMap);
 72:             registrant.setOverriddenStatus(overriddenStatusFromMap);
 73:         }
 74: 
 75:         // è·å¾—åº”ç”¨å®ä¾‹æœ€ç»ˆçŠ¶æ€ï¼Œå¹¶è®¾ç½®åº”ç”¨å®ä¾‹çš„çŠ¶æ€
 76:         // Set the status based on the overridden status rules
 77:         InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(registrant, existingLease, isReplication);
 78:         registrant.setStatusWithoutDirty(overriddenInstanceStatus);
 79: 
 80:         // è®¾ç½® ç§Ÿçº¦çš„å¼€å§‹æœåŠ¡çš„æ—¶é—´æˆ³ï¼ˆåªæœ‰ç¬¬ä¸€æ¬¡æœ‰æ•ˆï¼‰
 81:         // If the lease is registered with UP status, set lease service up timestamp
 82:         if (InstanceStatus.UP.equals(registrant.getStatus())) {
 83:             lease.serviceUp();
 84:         }
 85:         // è®¾ç½® åº”ç”¨å®ä¾‹ä¿¡æ¯çš„æ“ä½œç±»å‹ ä¸º æ·»åŠ 
 86:         registrant.setActionType(ActionType.ADDED);
 87:         // æ·»åŠ åˆ° æœ€è¿‘ç§Ÿçº¦å˜æ›´è®°å½•é˜Ÿåˆ—
 88:         recentlyChangedQueue.add(new RecentlyChangedItem(lease));
 89:         // è®¾ç½® ç§Ÿçº¦çš„æœ€åæ›´æ–°æ—¶é—´æˆ³
 90:         registrant.setLastUpdatedTimestamp();
 91:         // è®¾ç½® å“åº”ç¼“å­˜ è¿‡æœŸ
 92:         invalidateCache(registrant.getAppName(), registrant.getVIPAddress(), registrant.getSecureVipAddress());
 93:         logger.info("Registered instance {}/{} with status {} (replication={})",
 94:                 registrant.getAppName(), registrant.getId(), registrant.getStatus(), isReplication);
 95:     } finally {
 96:         // é‡Šæ”¾é”
 97:         read.unlock();
 98:     }
 99: }
```

* ç¬¬ 3 è¡Œ ï¼šæ·»åŠ åˆ°åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€æ˜ å°„ï¼Œåœ¨ [ã€ŠEureka æºç è§£æ â€”â€” Eureka-Server é›†ç¾¤åŒæ­¥ã€‹](http://www.iocoder.cn/Eureka/server-cluster/?self) è¯¦ç»†è§£æã€‚
* ç¬¬ 6 è‡³ 7 è¡Œ ï¼šå¢åŠ æ³¨å†Œæ¬¡æ•°åˆ°ç›‘æ§ã€‚é…åˆ [Netflix Servo](https://github.com/Netflix/servo) å®ç°ç›‘æ§ä¿¡æ¯é‡‡é›†ã€‚
* ç¬¬ 5 è‡³ 16 è¡Œ ï¼šè·å¾—åº”ç”¨å®ä¾‹ä¿¡æ¯å¯¹åº”çš„**ç§Ÿçº¦**ã€‚`registry` å®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    /**
     * ç§Ÿçº¦æ˜ å°„
     * key1 ï¼šåº”ç”¨å {@link InstanceInfo#appName}
     * key2 ï¼šåº”ç”¨å®ä¾‹ä¿¡æ¯ç¼–å· {@link InstanceInfo#instanceId}
     * value ï¼šç§Ÿçº¦
     */
    private final ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>> registry = new ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>>();
    ```

* ç¬¬ 17 è‡³ 30 è¡Œ ï¼šå½“ç§Ÿçº¦**å·²å­˜åœ¨**ï¼Œåˆ¤æ–­ Server å·²å­˜åœ¨çš„ InstanceInfo çš„ `lastDirtyTimestamp` æ˜¯å¦**å¤§äº**( ä¸åŒ…æ‹¬ç­‰äº ) Client è¯·æ±‚çš„ InstanceInfo ï¼Œ**è‹¥æ˜¯ï¼Œä½¿ç”¨ Server çš„ InstanceInfo è¿›è¡Œæ›¿ä»£**ã€‚
* ç¬¬ 31 è‡³ 44 è¡Œ ï¼šå¢åŠ  `numberOfRenewsPerMinThreshold` ã€`expectedNumberOfRenewsPerMin`ï¼Œè‡ªæˆ‘ä¿æŠ¤æœºåˆ¶ç›¸å…³ï¼Œåœ¨ [ã€ŠEureka æºç è§£æ â€”â€” åº”ç”¨å®ä¾‹æ³¨å†Œå‘ç°ï¼ˆå››ï¼‰ä¹‹è‡ªæˆ‘ä¿æŠ¤æœºåˆ¶ã€‹](http://www.iocoder.cn/Eureka/instance-registry-self-preservation/?self) æœ‰è¯¦ç»†è§£æã€‚
* ç¬¬ 45 è‡³ 52 è¡Œ ï¼šåˆ›å»ºç§Ÿçº¦ï¼Œå¹¶æ·»åŠ åˆ°ç§Ÿçº¦æ˜ å°„( `registry` )ã€‚
* ç¬¬ 53 è‡³ 58 è¡Œ ï¼šæ·»åŠ åˆ°æœ€è¿‘æ³¨å†Œçš„**è°ƒè¯•**é˜Ÿåˆ—( `recentRegisteredQueue` )ï¼Œç”¨äº Eureka-Server è¿ç»´ç•Œé¢çš„æ˜¾ç¤ºï¼Œæ— å®é™…ä¸šåŠ¡é€»è¾‘ä½¿ç”¨ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    /**
    * æœ€è¿‘æ³¨å†Œçš„è°ƒè¯•é˜Ÿåˆ—
    * key ï¼šæ·»åŠ æ—¶çš„æ—¶é—´æˆ³
    * value ï¼šå­—ç¬¦ä¸² = åº”ç”¨å(åº”ç”¨å®ä¾‹ä¿¡æ¯ç¼–å·)
    */
    private final CircularQueue<Pair<Long, String>> recentRegisteredQueue;
    
    /**
    * å¾ªç¯é˜Ÿåˆ—
    *
    * @param <E> æ³›å‹
    */
    private class CircularQueue<E> extends ConcurrentLinkedQueue<E> {
    
       /**
        * é˜Ÿåˆ—å¤§å°
        */
       private int size = 0;
    
       public CircularQueue(int size) {
           this.size = size;
       }
    
       @Override
       public boolean add(E e) {
           this.makeSpaceIfNotAvailable();
           return super.add(e);
    
       }
    
       /**
        * ä¿è¯ç©ºé—´è¶³å¤Ÿ
        *
        * å½“ç©ºé—´ä¸å¤Ÿæ—¶ï¼Œç§»é™¤é¦–å…ƒç´ 
        */
       private void makeSpaceIfNotAvailable() {
           if (this.size() == size) {
               this.remove();
           }
       }
    
       public boolean offer(E e) {
           this.makeSpaceIfNotAvailable();
           return super.offer(e);
       }
    }
    ```

* ç¬¬ 59 è‡³ 68 è¡Œ ï¼šæ·»åŠ åˆ°åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€æ˜ å°„ï¼Œåœ¨ [ã€ŠEureka æºç è§£æ â€”â€” Eureka-Server é›†ç¾¤åŒæ­¥ã€‹](http://www.iocoder.cn/Eureka/server-cluster/?self) è¯¦ç»†è§£æã€‚
* ç¬¬ 69 è‡³ 73 è¡Œ ï¼šè®¾ç½®åº”ç”¨å®ä¾‹çš„è¦†ç›–çŠ¶æ€( `overridestatus` )ï¼Œé¿å…æ³¨å†Œåº”ç”¨å®ä¾‹åï¼Œä¸¢å¤±è¦†ç›–çŠ¶æ€ã€‚åœ¨[ã€Šåº”ç”¨å®ä¾‹æ³¨å†Œå‘ç° ï¼ˆå…«ï¼‰ä¹‹è¦†ç›–çŠ¶æ€ã€‹](http://www.iocoder.cn/Eureka/instance-registry-override-status/?self)è¯¦ç»†è§£æã€‚
* ç¬¬ 75 è‡³ 78 è¡Œ ï¼š **è·å¾—åº”ç”¨å®ä¾‹æœ€ç»ˆçŠ¶æ€**ï¼Œå¹¶è®¾ç½®åº”ç”¨å®ä¾‹çš„çŠ¶æ€ã€‚åœ¨[ã€Šåº”ç”¨å®ä¾‹æ³¨å†Œå‘ç° ï¼ˆå…«ï¼‰ä¹‹è¦†ç›–çŠ¶æ€ã€‹](http://www.iocoder.cn/Eureka/instance-registry-override-status/?self)è¯¦ç»†è§£æã€‚
* ç¬¬ 80 è‡³ 84 è¡Œ ï¼šè®¾ç½®ç§Ÿçº¦çš„å¼€å§‹æœåŠ¡çš„æ—¶é—´æˆ³( **åªæœ‰ç¬¬ä¸€æ¬¡æœ‰æ•ˆ** )ã€‚
* ç¬¬ 85 è‡³ 88 è¡Œ ï¼šè®¾ç½®åº”ç”¨å®ä¾‹ä¿¡æ¯çš„**æ“ä½œç±»å‹ä¸ºæ·»åŠ **ï¼Œå¹¶æ·»åŠ åˆ°æœ€è¿‘ç§Ÿçº¦å˜æ›´è®°å½•é˜Ÿåˆ—( `recentlyChangedQueue` )ã€‚`recentlyChangedQueue` ç”¨äºæ³¨å†Œä¿¡æ¯çš„**å¢é‡**è·å–ï¼Œåœ¨[ã€Šåº”ç”¨å®ä¾‹æ³¨å†Œå‘ç° ï¼ˆä¸ƒï¼‰ä¹‹å¢é‡è·å–ã€‹](http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/?self)è¯¦ç»†è§£æã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    /**
    * æœ€è¿‘ç§Ÿçº¦å˜æ›´è®°å½•é˜Ÿåˆ—
    */
    private ConcurrentLinkedQueue<RecentlyChangedItem> recentlyChangedQueue = new ConcurrentLinkedQueue<RecentlyChangedItem>();
    ```

* ç¬¬ 89 è‡³ 90 è¡Œ ï¼šè®¾ç½®ç§Ÿçº¦çš„æœ€åæ›´æ–°æ—¶é—´æˆ³ã€‚
* ç¬¬ 91 è‡³ 92 è¡Œ ï¼šè®¾ç½®å“åº”ç¼“å­˜( ResponseCache )è¿‡æœŸï¼Œåœ¨[ã€ŠEureka æºç è§£æ â€”â€” åº”ç”¨å®ä¾‹æ³¨å†Œå‘ç° ï¼ˆå…­ï¼‰ä¹‹å…¨é‡è·å–ã€‹](http://www.iocoder.cn/Eureka/instance-registry-override-status/?self)è¯¦ç»†è§£æã€‚
* ç¬¬ 96 è‡³ 97 è¡Œ ï¼šé‡Šæ”¾é”ã€‚

# 666. å½©è›‹

![çŸ¥è¯†æ˜Ÿçƒ](http://www.iocoder.cn/images/Architecture/2017_12_29/01.png)

å˜¿å˜¿ï¼Œè›®å—¨çš„ï¼Œæ¯”èµ·å‰é¢å‡ ç¯‡å†™é…ç½®ç›¸å…³çš„æ–‡ç« æ¥è¯´ã€‚

èƒ–å‹ï¼Œåˆ†äº«æˆ‘çš„å…¬ä¼—å·( **èŠ‹é“æºç ** ) ç»™ä½ çš„èƒ–å‹å¯å¥½ï¼Ÿ

