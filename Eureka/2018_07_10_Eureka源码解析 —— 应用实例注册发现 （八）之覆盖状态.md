title: Eureka æºç è§£æ â€”â€” åº”ç”¨å®ä¾‹æ³¨å†Œå‘ç°ï¼ˆå…«ï¼‰ä¹‹è¦†ç›–çŠ¶æ€
date: 2018-07-08
tags:
categories: Eureka
permalink: Eureka/instance-registry-override-status
wechat_url: https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247484626&idx=2&sn=44e40114d9534f029f8a74013453ad57&chksm=fa497b63cd3ef27546567cb116b791dfcda0befc0576329ecf1716ffbf5d478cb87241577a52#rd

---

æ‘˜è¦: åŸåˆ›å‡ºå¤„ http://www.iocoder.cn/Eureka/instance-registry-override-status/ ã€ŒèŠ‹é“æºç ã€æ¬¢è¿è½¬è½½ï¼Œä¿ç•™æ‘˜è¦ï¼Œè°¢è°¢ï¼

**æœ¬æ–‡ä¸»è¦åŸºäº Eureka 1.8.X ç‰ˆæœ¬** 


- [1. æ¦‚è¿°](http://www.iocoder.cn/Eureka/instance-registry-override-status/)
- [2. åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€å˜æ›´æ¥å£](http://www.iocoder.cn/Eureka/instance-registry-override-status/)
  - [2.1 æ›´æ–°åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€](http://www.iocoder.cn/Eureka/instance-registry-override-status/)
- [3. åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€åˆ é™¤æ¥å£](http://www.iocoder.cn/Eureka/instance-registry-override-status/)
  - [3.1 åˆ é™¤åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€](http://www.iocoder.cn/Eureka/instance-registry-override-status/)
- [4. åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€æ˜ å°„](http://www.iocoder.cn/Eureka/instance-registry-override-status/)
  - [4.1 åº”ç”¨å®ä¾‹çŠ¶æ€è¦†ç›–è§„åˆ™](http://www.iocoder.cn/Eureka/instance-registry-override-status/)
  - [4.2 æ³¨å†Œåœºæ™¯](http://www.iocoder.cn/Eureka/instance-registry-override-status/)
  - [4.3 ç»­ç§Ÿåœºæ™¯](http://www.iocoder.cn/Eureka/instance-registry-override-status/)
  - [4.4 ä¸‹çº¿åœºæ™¯](http://www.iocoder.cn/Eureka/instance-registry-override-status/)
  - [4.5 è¿‡æœŸåœºæ™¯](http://www.iocoder.cn/Eureka/instance-registry-override-status/)
- [5. å®¢æˆ·ç«¯è°ƒç”¨æ¥å£](http://www.iocoder.cn/Eureka/instance-registry-override-status/)
- [666. å½©è›‹](http://www.iocoder.cn/Eureka/instance-registry-override-status/)

---

![](http://www.iocoder.cn/images/common/wechat_mp_2018_05_18.jpg)

> ğŸ™‚ğŸ™‚ğŸ™‚å…³æ³¨**å¾®ä¿¡å…¬ä¼—å·ï¼šã€èŠ‹é“æºç ã€‘**æœ‰ç¦åˆ©ï¼š  
> 1. RocketMQ / MyCAT / Sharding-JDBC **æ‰€æœ‰**æºç åˆ†ææ–‡ç« åˆ—è¡¨  
> 2. RocketMQ / MyCAT / Sharding-JDBC **ä¸­æ–‡æ³¨é‡Šæºç  GitHub åœ°å€**  
> 3. æ‚¨å¯¹äºæºç çš„ç–‘é—®æ¯æ¡ç•™è¨€**éƒ½**å°†å¾—åˆ°**è®¤çœŸ**å›å¤ã€‚**ç”šè‡³ä¸çŸ¥é“å¦‚ä½•è¯»æºç ä¹Ÿå¯ä»¥è¯·æ•™å™¢**ã€‚  
> 4. **æ–°çš„**æºç è§£ææ–‡ç« **å®æ—¶**æ”¶åˆ°é€šçŸ¥ã€‚**æ¯å‘¨æ›´æ–°ä¸€ç¯‡å·¦å³**ã€‚  
> 5. **è®¤çœŸçš„**æºç äº¤æµå¾®ä¿¡ç¾¤ã€‚

---

# 1. æ¦‚è¿°

æœ¬æ–‡ä¸»è¦åˆ†äº« **åº”ç”¨å®ä¾‹çš„è¦†ç›–çŠ¶æ€å±æ€§**ã€‚

è¿™é‡Œè¦æ³¨æ„ä¸‹ï¼Œä¸æ˜¯åº”ç”¨å®ä¾‹çš„çŠ¶æ€( `status` )ï¼Œè€Œæ˜¯è¦†ç›–çŠ¶æ€( `overridestatus` ) ã€‚ä»£ç å¦‚ä¸‹ï¼š

```Java
public class InstanceInfo {

    private volatile InstanceStatus overriddenstatus = InstanceStatus.UNKNOWN;
    
    // ... çœç•¥å±æ€§å’Œæ–¹æ³•

}
```

è°ƒç”¨ Eureka-Server HTTP Restful æ¥å£ `apps/${APP_NAME}/${INSTANCE_ID}/status` å¯¹åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€çš„å˜æ›´ï¼Œä»è€Œè¾¾åˆ°**ä¸»åŠ¨**çš„ã€**å¼ºåˆ¶**çš„å˜æ›´åº”ç”¨å®ä¾‹çŠ¶æ€ã€‚æ³¨æ„ï¼Œ**å®é™…ä¸ä¼šçœŸçš„ä¿®æ”¹ Eureka-Client åº”ç”¨å®ä¾‹çš„çŠ¶æ€ï¼Œè€Œæ˜¯ä¿®æ”¹åœ¨ Eureka-Server æ³¨å†Œçš„åº”ç”¨å®ä¾‹çš„çŠ¶æ€**ã€‚

é€šè¿‡è¿™æ ·çš„æ–¹å¼ï¼ŒEureka-Client åœ¨è·å–åˆ°æ³¨å†Œä¿¡æ¯æ—¶ï¼Œå¹¶ä¸”é…ç½® `eureka.shouldFilterOnlyUpInstances = true`ï¼Œè¿‡æ»¤æ‰é `InstanceStatus.UP` çš„åº”ç”¨å®ä¾‹ï¼Œä»è€Œé¿å…è°ƒåŠ¨è¯¥å®ä¾‹ï¼Œä»¥è¾¾åˆ°åº”ç”¨å®ä¾‹çš„**æš‚åœæœåŠ¡( `InstanceStatus.OUT_OF_SERVICE` )ï¼Œè€Œæ— éœ€å…³é—­åº”ç”¨å®ä¾‹**ã€‚

å› æ­¤ï¼Œå¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œè°ƒç”¨è¯¥æ¥å£çš„ç›®çš„ï¼Œå°†åº”ç”¨å®ä¾‹çŠ¶æ€åœ¨ ( `InstanceStatus.UP` ) å’Œ  ( `InstanceStatus.OUT_OF_SERVICE` ) ä¹‹é—´åˆ‡æ¢ã€‚å¼•ç”¨å®˜æ–¹ä»£ç ä¸Šçš„æ³¨é‡Šå¦‚ä¸‹ï¼š

> `AbstractInstanceRegistry#statusUpdate` æ–¹æ³•æ³¨é‡Š  
> Updates the status of an instance.  
> Normally happens to put an instance between {@link InstanceStatus#OUT_OF_SERVICE} and {@link InstanceStatus#UP} to put the instance in and out of traffic.

-------

**æ¨è Spring Cloud ä¹¦ç±**ï¼š

* è¯·æ”¯æŒæ­£ç‰ˆã€‚ä¸‹è½½ç›—ç‰ˆï¼Œ**ç­‰äºä¸»åŠ¨ç¼–å†™ä½çº§ BUG** ã€‚
* ç¨‹åºçŒ¿DD â€”â€” [ã€ŠSpring Cloudå¾®æœåŠ¡å®æˆ˜ã€‹](https://union-click.jd.com/jdc?d=505Twi)
* å‘¨ç«‹ â€”â€” [ã€ŠSpring Cloudä¸Dockerå¾®æœåŠ¡æ¶æ„å®æˆ˜ã€‹](https://union-click.jd.com/jdc?d=k3sAaK)
* ä¸¤ä¹¦é½ä¹°ï¼Œäº¬ä¸œåŒ…é‚®ã€‚



-------

æ¥å£ `apps/${APP_NAME}/${INSTANCE_ID}/status` å®é™…æ˜¯ä¸¤ä¸ªï¼š

* PUT `apps/${APP_NAME}/${INSTANCE_ID}/status`
* DELETE `apps/${APP_NAME}/${INSTANCE_ID}/status`

ä¸‹é¢ï¼Œæˆ‘ä»¬é€èŠ‚åˆ†äº«è¿™ä¸¤æ¥å£çš„ä»£ç å®ç°ã€‚

# 2. åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€å˜æ›´æ¥å£

åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€å˜æ›´æ¥å£ï¼Œæ˜ å°„ `InstanceResource#statusUpdate()` æ–¹æ³•ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
@PUT
@Path("status")
public Response statusUpdate(
       @QueryParam("value") String newStatus,
       @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication,
       @QueryParam("lastDirtyTimestamp") String lastDirtyTimestamp) {
   try {
       // åº”ç”¨å®ä¾‹ä¸å­˜åœ¨
       if (registry.getInstanceByAppAndId(app.getName(), id) == null) {
           logger.warn("Instance not found: {}/{}", app.getName(), id);
           return Response.status(Status.NOT_FOUND).build();
       }

       // è¦†ç›–çŠ¶æ€æ›´æ–°
       boolean isSuccess = registry.statusUpdate(app.getName(), id,
               InstanceStatus.valueOf(newStatus), lastDirtyTimestamp,
               "true".equals(isReplication));

       // è¿”å›ç»“æœ
       if (isSuccess) {
           logger.info("Status updated: " + app.getName() + " - " + id
                   + " - " + newStatus);
           return Response.ok().build();
       } else {
           logger.warn("Unable to update status: " + app.getName() + " - "
                   + id + " - " + newStatus);
           return Response.serverError().build();
       }
   } catch (Throwable e) {
       logger.error("Error updating instance {} for status {}", id,
               newStatus);
       return Response.serverError().build();
   }
}
```

* è°ƒç”¨ `PeerAwareInstanceRegistryImpl#statusUpdate(...)` æ–¹æ³•ï¼Œæ›´æ–°åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    @Override
    public boolean statusUpdate(final String appName, final String id,
                               final InstanceStatus newStatus, String lastDirtyTimestamp,
                               final boolean isReplication) {
       if (super.statusUpdate(appName, id, newStatus, lastDirtyTimestamp, isReplication)) {
           // Eureka-Server é›†ç¾¤åŒæ­¥
           replicateToPeers(Action.StatusUpdate, appName, id, null, newStatus, isReplication);
           return true;
       }
       return false;
    }
    ```
    * è°ƒç”¨çˆ¶ç±» `AbstractInstanceRegistry#statusUpdate(...)` æ–¹æ³•ï¼Œæ›´æ–°åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€ã€‚

## 2.1 æ›´æ–°åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€

è°ƒç”¨ `AbstractInstanceRegistry#statusUpdate(...)` æ–¹æ³•ï¼Œæ›´æ–°åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
  1: @Override
  2: public boolean statusUpdate(String appName, String id,
  3:                             InstanceStatus newStatus, String lastDirtyTimestamp,
  4:                             boolean isReplication) {
  5:     try {
  6:         // è·å–è¯»é”
  7:         read.lock();
  8:         // æ·»åŠ  è¦†ç›–çŠ¶æ€å˜æ›´æ¬¡æ•° åˆ° ç›‘æ§
  9:         STATUS_UPDATE.increment(isReplication);
 10:         // è·å¾— ç§Ÿçº¦
 11:         Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
 12:         Lease<InstanceInfo> lease = null;
 13:         if (gMap != null) {
 14:             lease = gMap.get(id);
 15:         }
 16:         // ç§Ÿçº¦ä¸å­˜åœ¨
 17:         if (lease == null) {
 18:             return false;
 19:         } else {
 20:             // è®¾ç½® ç§Ÿçº¦æœ€åæ›´æ–°æ—¶é—´ï¼ˆç»­ç§Ÿï¼‰
 21:             lease.renew();
 22: 
 23:             // åº”ç”¨å®ä¾‹ä¿¡æ¯ä¸å­˜åœ¨( é˜²å¾¡å‹ç¼–ç¨‹ )
 24:             InstanceInfo info = lease.getHolder();
 25:             // Lease is always created with its instance info object.
 26:             // This log statement is provided as a safeguard, in case this invariant is violated.
 27:             if (info == null) {
 28:                 logger.error("Found Lease without a holder for instance id {}", id);
 29:             }
 30:             //
 31:             if ((info != null) && !(info.getStatus().equals(newStatus))) {
 32:                 // è®¾ç½® ç§Ÿçº¦çš„å¼€å§‹æœåŠ¡çš„æ—¶é—´æˆ³ï¼ˆåªæœ‰ç¬¬ä¸€æ¬¡æœ‰æ•ˆï¼‰
 33:                 // Mark service as UP if needed
 34:                 if (InstanceStatus.UP.equals(newStatus)) {
 35:                     lease.serviceUp();
 36:                 }
 37:                 // æ·»åŠ åˆ° åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€æ˜ å°„
 38:                 // This is NAC overridden status
 39:                 overriddenInstanceStatusMap.put(id, newStatus);
 40:                 // è®¾ç½® åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€
 41:                 // Set it for transfer of overridden status to replica on
 42:                 // replica start up
 43:                 info.setOverriddenStatus(newStatus);
 44:                 // è®¾ç½® åº”ç”¨å®ä¾‹ä¿¡æ¯ æ•°æ®ä¸ä¸€è‡´æ—¶é—´
 45:                 long replicaDirtyTimestamp = 0;
 46:                 // è®¾ç½® åº”ç”¨å®ä¾‹çŠ¶æ€
 47:                 info.setStatusWithoutDirty(newStatus);
 48:                 if (lastDirtyTimestamp != null) {
 49:                     replicaDirtyTimestamp = Long.valueOf(lastDirtyTimestamp);
 50:                 }
 51:                 // If the replication's dirty timestamp is more than the existing one, just update
 52:                 // it to the replica's.
 53:                 if (replicaDirtyTimestamp > info.getLastDirtyTimestamp()) {
 54:                     info.setLastDirtyTimestamp(replicaDirtyTimestamp);
 55:                 }
 56:                 // æ·»åŠ åˆ° æœ€è¿‘ç§Ÿçº¦å˜æ›´è®°å½•é˜Ÿåˆ—
 57:                 info.setActionType(ActionType.MODIFIED);
 58:                 recentlyChangedQueue.add(new RecentlyChangedItem(lease));
 59:                 // è®¾ç½® æœ€åæ›´æ–°æ—¶é—´
 60:                 info.setLastUpdatedTimestamp();
 61:                 // è®¾ç½® å“åº”ç¼“å­˜ è¿‡æœŸ
 62:                 invalidateCache(appName, info.getVIPAddress(), info.getSecureVipAddress());
 63:             }
 64:             return true;
 65:         }
 66:     } finally {
 67:         // é‡Šæ”¾é”
 68:         read.unlock();
 69:     }
 70: }
```

* ç¬¬ 6 è‡³ 7 è¡Œ ï¼šè·å–è¯»é”ã€‚åœ¨ [ã€ŠEurekaæºç è§£æ â€”â€” åº”ç”¨å®ä¾‹æ³¨å†Œå‘ç° ï¼ˆä¹ï¼‰ä¹‹å²æœˆæ˜¯æŠŠèŒèŒçš„è¯»å†™é”ã€‹](http://www.iocoder.cn/Eureka/instance-registry-read-write-lock/?self) è¯¦ç»†è§£æã€‚
* ç¬¬ 8 è‡³ 9 è¡Œ ï¼šæ·»åŠ è¦†ç›–çŠ¶æ€å˜æ›´æ¬¡æ•°åˆ°ç›‘æ§ã€‚é…åˆ [Netflix Servo](https://github.com/Netflix/servo) å®ç°ç›‘æ§ä¿¡æ¯é‡‡é›†ã€‚
* ç¬¬ 10 è‡³ 15 è¡Œ ï¼šè·å¾—ç§Ÿçº¦ã€‚
* ç¬¬ 16 è‡³ 18 è¡Œ ï¼šç§Ÿçº¦ä¸å­˜åœ¨ï¼Œè¿”å›æ›´æ–°å¤±è´¥ã€‚
* ç¬¬ 20 è‡³ 21 è¡Œ ï¼šè®¾ç½®ç§Ÿçº¦æœ€åæ›´æ–°æ—¶é—´( ç»­ç§Ÿ )ã€‚
* ç¬¬ 23 è‡³ 29 è¡Œ ï¼šæŒæœ‰ç§Ÿçº¦çš„åº”ç”¨å®ä¾‹ä¸å­˜åœ¨ï¼Œç†è®ºæ¥è¯´ä¸ä¼šå‡ºç°ï¼Œé˜²å¾¡æ€§ç¼–ç¨‹ã€‚
* ç¬¬ 31 è¡Œ ï¼š**åº”ç”¨å®ä¾‹å½“å‰çŠ¶æ€å’Œè¦†è¯¥çŠ¶æ€ä¸ä¸€è‡´æ—¶æ‰æ›´æ–°è¦†ç›–çŠ¶æ€**ã€‚
* ç¬¬ 32 è‡³ 36 è¡Œ ï¼šå½“è¦†ç›–çŠ¶æ€æ˜¯ `InstanceStatus.UP`ï¼Œè®¾ç½®ç§Ÿçº¦çš„å¼€å§‹æœåŠ¡çš„æ—¶é—´æˆ³ï¼ˆåªæœ‰ç¬¬ä¸€æ¬¡æœ‰æ•ˆï¼‰ã€‚
* ç¬¬ 37 è‡³ 39 è¡Œ ï¼šæ·»åŠ åˆ°åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€æ˜ å°„( `overriddenInstanceStatusMap` )ã€‚æ­¤å¤„è‹±æ–‡ `"NAC"` å¯èƒ½æ˜¯ `"Network Access Control"` çš„ç¼©å†™ï¼Œæ„Ÿå…´è¶£çš„å¯ä»¥çœ‹çœ‹ [ã€ŠNetwork Access Controlã€‹](https://en.wikipedia.org/wiki/Network_Access_Control) ã€‚`overriddenInstanceStatusMap` å±æ€§ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    /**
    * åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€æ˜ å°„
    * keyï¼šåº”ç”¨å®ä¾‹ç¼–å·
    */
    protected final ConcurrentMap<String, InstanceStatus> overriddenInstanceStatusMap = CacheBuilder
          .newBuilder().initialCapacity(500)
          .expireAfterAccess(1, TimeUnit.HOURS)
          .<String, InstanceStatus>build().asMap();
    ```
    * æœ‰æ•ˆæœŸ 1 å°æ—¶ã€‚æ¯æ¬¡è®¿é—®åä¼šåˆ·æ–°æœ‰æ•ˆæœŸï¼Œåœ¨åæ–‡ä½ ä¼šçœ‹åˆ°å¯¹å…¶çš„è®¿é—®ã€‚

* ç¬¬ 40 è‡³ 43 è¡Œ ï¼šè®¾ç½®åº”ç”¨å®ä¾‹çš„è¦†ç›–çŠ¶æ€ã€‚ç”¨äº Eureka-Server é›†ç¾¤åŒæ­¥ã€‚
* ç¬¬ 46 è‡³ 47 è¡Œ ï¼š**è®¾ç½®åº”ç”¨å®ä¾‹çŠ¶æ€**ã€‚è®¾ç½®åï¼ŒEureka-Client æ‹‰å–æ³¨å†Œä¿¡æ¯ï¼Œè¢«æ›´æ–°è¦†ç›–çŠ¶æ€çš„åº”ç”¨å®ä¾‹å°±æ˜¯è®¾ç½®çš„çŠ¶æ€ã€‚
* ç¬¬ 48 è‡³ 55 è¡Œ ï¼šè®¾ç½®åº”ç”¨å®ä¾‹çš„æ•°æ®ä¸ä¸€è‡´æ—¶é—´ã€‚ç”¨äº Eureka-Server é›†ç¾¤åŒæ­¥ã€‚
* ç¬¬ 56 è‡³ 58 è¡Œ ï¼šæ·»åŠ åº”ç”¨å®ä¾‹åˆ°æœ€è¿‘ç§Ÿçº¦å˜æ›´è®°å½•é˜Ÿåˆ—ã€‚
* ç¬¬ 59 è‡³ 60 è¡Œ ï¼šè®¾ç½®åº”ç”¨å®ä¾‹çš„æœ€åæ›´æ–°æ—¶é—´( `lastUpdatedTimestamp` )ã€‚`lastUpdatedTimestamp` ä¸»è¦ç”¨äºè®°å½•æœ€åæ›´æ–°æ—¶é—´ï¼Œæ— å®é™…ä¸šåŠ¡ç”¨é€”ã€‚
* ç¬¬ 61 è‡³ 62 è¡Œ ï¼šè®¾ç½®å“åº”ç¼“å­˜è¿‡æœŸã€‚
* ç¬¬ 64 è¡Œ ï¼šè¿”å›æ›´æ–°æˆåŠŸã€‚
* ç¬¬ 68 è¡Œ ï¼šé‡Šæ”¾è¯»é”ã€‚

# 3. åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€åˆ é™¤æ¥å£

å½“æˆ‘ä»¬ä¸éœ€è¦åº”ç”¨å®ä¾‹çš„è¦†ç›–çŠ¶æ€æ—¶ï¼Œè°ƒåº¦æ¥å£æ¥å£è¿›è¡Œåˆ é™¤ã€‚å…³è”å®˜æ–¹ `issue#89` ï¼š[Provide an API to remove all overridden status](https://github.com/Netflix/eureka/issues/89)ã€‚

åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€åˆ é™¤æ¥å£ï¼Œæ˜ å°„ `InstanceResource#deleteStatusUpdate()` æ–¹æ³•ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
@DELETE
@Path("status")
public Response deleteStatusUpdate(
       @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication,
       @QueryParam("value") String newStatusValue,
       @QueryParam("lastDirtyTimestamp") String lastDirtyTimestamp) {
   try {
       // åº”ç”¨å®ä¾‹ä¸å­˜åœ¨
       if (registry.getInstanceByAppAndId(app.getName(), id) == null) {
           logger.warn("Instance not found: {}/{}", app.getName(), id);
           return Response.status(Status.NOT_FOUND).build();
       }

       // è¦†ç›–çŠ¶æ€åˆ é™¤
       InstanceStatus newStatus = newStatusValue == null ? InstanceStatus.UNKNOWN : InstanceStatus.valueOf(newStatusValue);
       boolean isSuccess = registry.deleteStatusOverride(app.getName(), id,
               newStatus, lastDirtyTimestamp, "true".equals(isReplication));

       // è¿”å›ç»“æœ
       if (isSuccess) {
           logger.info("Status override removed: " + app.getName() + " - " + id);
           return Response.ok().build();
       } else {
           logger.warn("Unable to remove status override: " + app.getName() + " - " + id);
           return Response.serverError().build();
       }
   } catch (Throwable e) {
       logger.error("Error removing instance's {} status override", id);
       return Response.serverError().build();
   }
}
```

* è¯·æ±‚å‚æ•° `newStatusValue` ï¼Œè®¾ç½®åº”ç”¨å®ä¾‹çš„çŠ¶æ€ã€‚å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œ`newStatusValue` è¦å’Œåº”ç”¨å®ä¾‹å®é™…çš„çŠ¶æ€ä¸€è‡´ï¼Œå› ä¸ºè¯¥åº”ç”¨å®ä¾‹çš„ Eureka-Client ä¸ä¼šä» Eureka-Server æ‹‰å–åˆ°è¯¥åº”ç”¨çŠ¶æ€ `newStatusValue` ã€‚å¦å¤–ä¸€ç§æ–¹å¼ï¼Œä¸ä¼ é€’è¯¥å‚æ•°ï¼Œç›¸å½“äº `UNKNOWN` çŠ¶æ€ï¼Œè¿™æ ·ï¼ŒEureka-Client ä¼šä¸»åŠ¨å‘ Eureka-Server å†æ¬¡å‘èµ·æ³¨å†Œï¼Œå…·ä½“åŸå› åœ¨ [ã€Œ4.3 ç»­ç§Ÿåœºæ™¯ã€] è¯¦ç»†è§£æï¼Œæ›´åŠ æ¨èçš„æ–¹å¼ã€‚
* è°ƒç”¨çˆ¶ç±» `AbstractInstanceRegistry#deleteStatusOverride(...)` æ–¹æ³•ï¼Œåˆ é™¤åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    @Override
    public boolean deleteStatusOverride(String appName, String id,
                                       InstanceStatus newStatus,
                                       String lastDirtyTimestamp,
                                       boolean isReplication) {
       if (super.deleteStatusOverride(appName, id, newStatus, lastDirtyTimestamp, isReplication)) {
           // Eureka-Server é›†ç¾¤åŒæ­¥
           replicateToPeers(Action.DeleteStatusOverride, appName, id, null, null, isReplication);
           return true;
       }
       return false;
    }
    ```
    * è°ƒç”¨çˆ¶ç±» `AbstractInstanceRegistry#deleteStatusOverride(...)` æ–¹æ³•ï¼Œåˆ é™¤åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€ã€‚

## 3.1 åˆ é™¤åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€

è°ƒç”¨çˆ¶ç±» `AbstractInstanceRegistry#deleteStatusOverride(...)` æ–¹æ³•ï¼Œåˆ é™¤åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
  1: @Override
  2: public boolean deleteStatusOverride(String appName, String id,
  3:                                     InstanceStatus newStatus,
  4:                                     String lastDirtyTimestamp,
  5:                                     boolean isReplication) {
  6:     try {
  7:         // è·å–è¯»é”
  8:         read.lock();
  9:         // æ·»åŠ  è¦†ç›–çŠ¶æ€åˆ é™¤æ¬¡æ•° åˆ° ç›‘æ§
 10:         STATUS_OVERRIDE_DELETE.increment(isReplication);
 11:         // è·å¾— ç§Ÿçº¦
 12:         Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
 13:         Lease<InstanceInfo> lease = null;
 14:         if (gMap != null) {
 15:             lease = gMap.get(id);
 16:         }
 17:         // ç§Ÿçº¦ä¸å­˜åœ¨
 18:         if (lease == null) {
 19:             return false;
 20:         } else {
 21:             // è®¾ç½® ç§Ÿçº¦æœ€åæ›´æ–°æ—¶é—´ï¼ˆç»­ç§Ÿï¼‰
 22:             lease.renew();
 23: 
 24:             // åº”ç”¨å®ä¾‹ä¿¡æ¯ä¸å­˜åœ¨( é˜²å¾¡å‹ç¼–ç¨‹ )
 25:             InstanceInfo info = lease.getHolder();
 26:             // Lease is always created with its instance info object.
 27:             // This log statement is provided as a safeguard, in case this invariant is violated.
 28:             if (info == null) {
 29:                 logger.error("Found Lease without a holder for instance id {}", id);
 30:             }
 31: 
 32:             // ç§»é™¤ åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€
 33:             InstanceStatus currentOverride = overriddenInstanceStatusMap.remove(id);
 34:             if (currentOverride != null && info != null) {
 35:                 // è®¾ç½® åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€
 36:                 info.setOverriddenStatus(InstanceStatus.UNKNOWN);
 37:                 // è®¾ç½® åº”ç”¨å®ä¾‹çŠ¶æ€
 38:                 info.setStatusWithoutDirty(newStatus);
 39:                 // è®¾ç½® åº”ç”¨å®ä¾‹ä¿¡æ¯ æ•°æ®ä¸ä¸€è‡´æ—¶é—´
 40:                 long replicaDirtyTimestamp = 0;
 41:                 if (lastDirtyTimestamp != null) {
 42:                     replicaDirtyTimestamp = Long.valueOf(lastDirtyTimestamp);
 43:                 }
 44:                 // If the replication's dirty timestamp is more than the existing one, just update
 45:                 // it to the replica's.
 46:                 if (replicaDirtyTimestamp > info.getLastDirtyTimestamp()) {
 47:                     info.setLastDirtyTimestamp(replicaDirtyTimestamp);
 48:                 }
 49:                 // æ·»åŠ åˆ° æœ€è¿‘ç§Ÿçº¦å˜æ›´è®°å½•é˜Ÿåˆ—
 50:                 info.setActionType(ActionType.MODIFIED);
 51:                 recentlyChangedQueue.add(new RecentlyChangedItem(lease));
 52:                 // è®¾ç½® æœ€åæ›´æ–°æ—¶é—´
 53:                 info.setLastUpdatedTimestamp();
 54:                 // è®¾ç½® å“åº”ç¼“å­˜ è¿‡æœŸ
 55:                 invalidateCache(appName, info.getVIPAddress(), info.getSecureVipAddress());
 56:             }
 57:             return true;
 58:         }
 59:     } finally {
 60:         // é‡Šæ”¾é”
 61:         read.unlock();
 62:     }
 63: }
```

* ç¬¬ 7 è‡³ 8 è¡Œ ï¼šè·å–è¯»é”ã€‚åœ¨ [ã€ŠEurekaæºç è§£æ â€”â€” åº”ç”¨å®ä¾‹æ³¨å†Œå‘ç° ï¼ˆä¹ï¼‰ä¹‹å²æœˆæ˜¯æŠŠèŒèŒçš„è¯»å†™é”ã€‹](http://www.iocoder.cn/Eureka/instance-registry-read-write-lock/?self) è¯¦ç»†è§£æã€‚
* ç¬¬ 9 è‡³ 10 è¡Œ ï¼šæ·»åŠ è¦†ç›–çŠ¶æ€åˆ é™¤æ¬¡æ•°åˆ°ç›‘æ§ã€‚é…åˆ [Netflix Servo](https://github.com/Netflix/servo) å®ç°ç›‘æ§ä¿¡æ¯é‡‡é›†ã€‚
* ç¬¬ 11 è‡³ 16 è¡Œ ï¼šè·å¾—ç§Ÿçº¦ã€‚
* ç¬¬ 17 è‡³ 19 è¡Œ ï¼šç§Ÿçº¦ä¸å­˜åœ¨ï¼Œè¿”å›æ›´æ–°å¤±è´¥ã€‚
* ç¬¬ 21 è‡³ 22 è¡Œ ï¼šè®¾ç½®ç§Ÿçº¦æœ€åæ›´æ–°æ—¶é—´( ç»­ç§Ÿ )ã€‚
* ç¬¬ 24 è‡³ 30 è¡Œ ï¼šæŒæœ‰ç§Ÿçº¦çš„åº”ç”¨å®ä¾‹ä¸å­˜åœ¨ï¼Œç†è®ºæ¥è¯´ä¸ä¼šå‡ºç°ï¼Œé˜²å¾¡æ€§ç¼–ç¨‹ã€‚
* ç¬¬ 32 è‡³ 33 è¡Œ ï¼šç§»é™¤å‡ºåº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€æ˜ å°„( `overriddenInstanceStatusMap` )ã€‚
* ç¬¬ 34 è¡Œ ï¼š**åº”ç”¨å®ä¾‹çš„è¦†ç›–çŠ¶æ€å­˜åœ¨æ‰è®¾ç½®çŠ¶æ€**ã€‚
* ç¬¬ 35 è‡³ 36 è¡Œ ï¼šè®¾ç½®åº”ç”¨å®ä¾‹çš„è¦†ç›–çŠ¶æ€ä¸º InstanceStatus.UNKNOWNã€‚ç”¨äº Eureka-Server é›†ç¾¤åŒæ­¥ã€‚
* ç¬¬ 37 è‡³ 38 è¡Œ ï¼šè®¾ç½®åº”ç”¨å®ä¾‹çš„çŠ¶æ€ä¸º `newStatus`ã€‚è®¾ç½®åï¼ŒEureka-Client æ‹‰å–æ³¨å†Œä¿¡æ¯ï¼Œè¢«æ›´æ–°è¦†ç›–çŠ¶æ€çš„åº”ç”¨å®ä¾‹å°±æ˜¯è®¾ç½®çš„çŠ¶æ€ã€‚
* ç¬¬ 39 è‡³ 48 è¡Œ ï¼šè®¾ç½®åº”ç”¨å®ä¾‹çš„æ•°æ®ä¸ä¸€è‡´æ—¶é—´ã€‚ç”¨äº Eureka-Server é›†ç¾¤åŒæ­¥ã€‚
* ç¬¬ 49 è‡³ 51 è¡Œ ï¼šæ·»åŠ åº”ç”¨å®ä¾‹åˆ°æœ€è¿‘ç§Ÿçº¦å˜æ›´è®°å½•é˜Ÿåˆ—ã€‚
* ç¬¬ 52 è‡³ 53 è¡Œ ï¼šè®¾ç½®åº”ç”¨å®ä¾‹çš„æœ€åæ›´æ–°æ—¶é—´( `lastUpdatedTimestamp` )ã€‚`lastUpdatedTimestamp` ä¸»è¦ç”¨äºè®°å½•æœ€åæ›´æ–°æ—¶é—´ï¼Œæ— å®é™…ä¸šåŠ¡ç”¨é€”ã€‚
* ç¬¬ 54 è‡³ 55 è¡Œ ï¼šè®¾ç½®å“åº”ç¼“å­˜è¿‡æœŸã€‚
* ç¬¬ 57 è¡Œ ï¼šè¿”å›æ›´æ–°æˆåŠŸã€‚
* ç¬¬ 61 è¡Œ ï¼šé‡Šæ”¾è¯»é”ã€‚

# 4. åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€æ˜ å°„

è™½ç„¶æˆ‘ä»¬åœ¨ä¸Šé¢ä»£ç ï¼Œä½¿ç”¨è¦†ç›–çŠ¶æ€( `overridestatus` )è®¾ç½®åˆ°åº”ç”¨å®ä¾‹çš„çŠ¶æ€( `status` )ï¼Œ**å®é™…è°ƒç”¨ `AbstractInstanceRegistry#getOverriddenInstanceStatus(...)` æ–¹æ³•ï¼Œæ ¹æ®åº”ç”¨å®ä¾‹çŠ¶æ€è¦†ç›–è§„åˆ™( InstanceStatusOverrideRule )è¿›è¡Œè®¡ç®—æœ€ç»ˆåº”ç”¨å®ä¾‹çš„çŠ¶æ€**ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
// AbstractInstanceRegistry.java
protected InstanceInfo.InstanceStatus getOverriddenInstanceStatus(InstanceInfo r,
                                                               Lease<InstanceInfo> existingLease,
                                                               boolean isReplication) {
   InstanceStatusOverrideRule rule = getInstanceInfoOverrideRule();
   logger.debug("Processing override status using rule: {}", rule);
   return rule.apply(r, existingLease, isReplication).status();
}

protected abstract InstanceStatusOverrideRule getInstanceInfoOverrideRule();
```

* è°ƒç”¨ `#getInstanceInfoOverrideRule()` æ–¹æ³•ï¼Œè·å–åº”ç”¨å®ä¾‹çŠ¶æ€è¦†ç›–è§„åˆ™( InstanceStatusOverrideRule )ã€‚åœ¨ PeerAwareInstanceRegistryImpl é‡Œè¯¥æ–¹æ³•å®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    private final InstanceStatusOverrideRule instanceStatusOverrideRule;
    
    public PeerAwareInstanceRegistryImpl(
                EurekaServerConfig serverConfig,
                EurekaClientConfig clientConfig,
                ServerCodecs serverCodecs,
                EurekaClient eurekaClient
        ) {
        // ... çœç•¥å…¶å®ƒæ–¹æ³•
        
        this.instanceStatusOverrideRule = new FirstMatchWinsCompositeRule(
            new DownOrStartingRule(),
            new OverrideExistsRule(overriddenInstanceStatusMap), 
            new LeaseExistsRule());
    }
    
    @Override
    protected InstanceStatusOverrideRule getInstanceInfoOverrideRule() {
       return this.instanceStatusOverrideRule;
    }
    ```

## 4.1 åº”ç”¨å®ä¾‹çŠ¶æ€è¦†ç›–è§„åˆ™

`com.netflix.eureka.registry.rule.InstanceStatusOverrideRule` ï¼Œåº”ç”¨å®ä¾‹çŠ¶æ€è¦†ç›–è§„åˆ™**æ¥å£**ã€‚æ¥å£ä»£ç å¦‚ä¸‹ï¼š

```Java
// InstanceStatusOverrideRule.java
public interface InstanceStatusOverrideRule {

     /**
     * Match this rule.
     *
     * @param instanceInfo The instance info whose status we care about. å…³æ³¨çŠ¶æ€çš„åº”ç”¨å®ä¾‹å¯¹è±¡
     * @param existingLease Does the instance have an existing lease already? If so let's consider that. å·²å­˜åœ¨çš„ç§Ÿçº¦
     * @param isReplication When overriding consider if we are under a replication mode from other servers. æ˜¯å¦æ˜¯ Eureka-Server å‘èµ·çš„è¯·æ±‚
     * @return A result with whether we matched and what we propose the status to be overriden to.
     */
     StatusOverrideResult apply(final InstanceInfo instanceInfo,
                               final Lease<InstanceInfo> existingLease,
                               boolean isReplication);

}

// StatusOverrideResult.java
public class StatusOverrideResult {

    public static StatusOverrideResult NO_MATCH = new StatusOverrideResult(false, null);

    public static StatusOverrideResult matchingStatus(InstanceInfo.InstanceStatus status) {
        return new StatusOverrideResult(true, status);
    }

    // Does the rule match?
    private final boolean matches;

    // The status computed by the rule.
    private final InstanceInfo.InstanceStatus status;

    private StatusOverrideResult(boolean matches, InstanceInfo.InstanceStatus status) {
        this.matches = matches;
        this.status = status;
    }

    public boolean matches() {
        return matches;
    }

    public InstanceInfo.InstanceStatus status() {
        return status;
    }
}
```

* `#apply(...)` æ–¹æ³•å‚æ•° `instanceInfo` ä»£è¡¨çš„æ˜¯**å…³æ³¨çŠ¶æ€**çš„åº”ç”¨å®ä¾‹ï¼Œå’Œæ–¹æ³•å‚æ•° `existingLease` é‡Œçš„åº”ç”¨å®ä¾‹ä¸ä¸€å®šæ˜¯åŒä¸€ä¸ªï¼Œåœ¨ [ã€Œ4.1.6 æ€»ç»“ã€](#) è¯¦ç»†è§£æã€‚
* `com.netflix.eureka.registry.rule.StatusOverrideResult` ï¼ŒçŠ¶æ€è¦†ç›–ç»“æœã€‚å½“åŒ¹é…æˆåŠŸï¼Œè¿”å› `matches = true` ï¼›å¦åˆ™ï¼Œè¿”å› `matches = false` ã€‚

**å®ç°ç±»å…³ç³»å¦‚ä¸‹**ï¼š

![](http://www.iocoder.cn/images/Eureka/2018_07_10/01.png)

* AsgEnabledRule ï¼Œäºšé©¬é€Š AWS ä¸“ç”¨ï¼Œè·³è¿‡ã€‚

### 4.1.1 FirstMatchWinsCompositeRule

`com.netflix.eureka.registry.rule.FirstMatchWinsCompositeRule` ï¼Œ**å¤åˆ**è§„åˆ™ï¼Œä»¥ç¬¬ä¸€ä¸ªåŒ¹é…æˆåŠŸä¸ºå‡†ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
public class FirstMatchWinsCompositeRule implements InstanceStatusOverrideRule {

    /**
     * å¤åˆè§„åˆ™é›†åˆ
     */
    private final InstanceStatusOverrideRule[] rules;
    /**
     * é»˜è®¤è§„åˆ™
     */
    private final InstanceStatusOverrideRule defaultRule;
    private final String compositeRuleName;

    public FirstMatchWinsCompositeRule(InstanceStatusOverrideRule... rules) {
        this.rules = rules;
        this.defaultRule = new AlwaysMatchInstanceStatusRule();
        // Let's build up and "cache" the rule name to be used by toString();
        List<String> ruleNames = new ArrayList<>(rules.length+1);
        for (int i = 0; i < rules.length; ++i) {
            ruleNames.add(rules[i].toString());
        }
        ruleNames.add(defaultRule.toString());
        compositeRuleName = ruleNames.toString();
    }

    @Override
    public StatusOverrideResult apply(InstanceInfo instanceInfo,
                                      Lease<InstanceInfo> existingLease,
                                      boolean isReplication) {
        // ä½¿ç”¨å¤åˆè§„åˆ™ï¼Œé¡ºåºåŒ¹é…ï¼Œç›´åˆ°åŒ¹é…æˆåŠŸ
        for (int i = 0; i < this.rules.length; ++i) {
            StatusOverrideResult result = this.rules[i].apply(instanceInfo, existingLease, isReplication);
            if (result.matches()) {
                return result;
            }
        }
        // ä½¿ç”¨é»˜è®¤è§„åˆ™
        return defaultRule.apply(instanceInfo, existingLease, isReplication);
    }

    @Override
    public String toString() {
        return this.compositeRuleName;
    }
}
```

* `rules` å±æ€§ï¼Œ**å¤åˆ**è§„åˆ™é›†åˆã€‚åœ¨ PeerAwareInstanceRegistryImpl é‡Œï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°è¯¥å±æ€§ä¸º [ DownOrStartingRule , OverrideExistsRule , LeaseExistsRule ] ã€‚
* `defaultRule` å±æ€§ï¼Œé»˜è®¤è§„åˆ™ï¼Œå€¼ä¸º AlwaysMatchInstanceStatusRule ã€‚
* `#apply()` æ–¹æ³•ï¼Œä¼˜å…ˆä½¿ç”¨**å¤åˆ**è§„åˆ™( `rules` )ï¼Œé¡ºåºåŒ¹é…ï¼Œç›´åˆ°åŒ¹é…æˆåŠŸ ã€‚å½“æœªåŒ¹é…æˆåŠŸï¼Œä½¿ç”¨é»˜è®¤è§„åˆ™( `defaultRule` ) ã€‚

### 4.1.2 DownOrStartingRule

`com.netflix.eureka.registry.rule.DownOrStartingRule` ï¼ŒåŒ¹é… `InstanceInfo.InstanceStatus.DOWN` æˆ–è€… `InstanceInfo.InstanceStatus.STARTING` çŠ¶æ€ã€‚å®ç° `#apply(...)` ä»£ç å¦‚ä¸‹ï¼š

```Java
@Override
public StatusOverrideResult apply(InstanceInfo instanceInfo,
                                 Lease<InstanceInfo> existingLease,
                                 boolean isReplication) {
   // ReplicationInstance is DOWN or STARTING - believe that, but when the instance says UP, question that
   // The client instance sends STARTING or DOWN (because of heartbeat failures), then we accept what
   // the client says. The same is the case with replica as well.
   // The OUT_OF_SERVICE from the client or replica needs to be confirmed as well since the service may be
   // currently in SERVICE
   if ((!InstanceInfo.InstanceStatus.UP.equals(instanceInfo.getStatus()))
           && (!InstanceInfo.InstanceStatus.OUT_OF_SERVICE.equals(instanceInfo.getStatus()))) {
       logger.debug("Trusting the instance status {} from replica or instance for instance {}",
               instanceInfo.getStatus(), instanceInfo.getId());
       return StatusOverrideResult.matchingStatus(instanceInfo.getStatus());
   }
   return StatusOverrideResult.NO_MATCH;
}
```

* **æ³¨æ„**ï¼Œä½¿ç”¨çš„æ˜¯ `instanceInfo` ã€‚

### 4.1.3 OverrideExistsRule

`com.netflix.eureka.registry.rule.OverrideExistsRule` ï¼ŒåŒ¹é…åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€æ˜ å°„( `statusOverrides` ) ã€‚å®ç° `#apply(...)` ä»£ç å¦‚ä¸‹ï¼š

```Java
public class OverrideExistsRule implements InstanceStatusOverrideRule {

   private Map<String, InstanceInfo.InstanceStatus> statusOverrides;

    @Override
    public StatusOverrideResult apply(InstanceInfo instanceInfo, Lease<InstanceInfo> existingLease, boolean isReplication) {
        InstanceInfo.InstanceStatus overridden = statusOverrides.get(instanceInfo.getId());
        // If there are instance specific overrides, then they win - otherwise the ASG status
        if (overridden != null) {
            logger.debug("The instance specific override for instance {} and the value is {}",
                    instanceInfo.getId(), overridden.name());
            return StatusOverrideResult.matchingStatus(overridden);
        }
        return StatusOverrideResult.NO_MATCH;
    }

}
```

* `statusOverrides` å±æ€§ï¼Œåº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€æ˜ å°„ã€‚åœ¨ PeerAwareInstanceRegistryImpl é‡Œï¼Œä½¿ç”¨ `AbstractInstanceRegistry.overriddenInstanceStatusMap` å±æ€§èµ‹å€¼ã€‚
* ä¸Šæ–‡æˆ‘ä»¬æåˆ° `AbstractInstanceRegistry.overriddenInstanceStatusMap`  æ¯æ¬¡è®¿é—®åˆ·æ–°æœ‰æ•ˆæœŸï¼Œå¦‚æœè°ƒç”¨åˆ° OverrideExistsRule ï¼Œåˆ™ä¼šä¸æ–­åˆ·æ–°ã€‚ä» DownOrStartingRule çœ‹åˆ°ï¼Œ`instanceInfo` å¤„äº `InstanceInfo.InstanceStatus.DOWN` æˆ–è€… `InstanceInfo.InstanceStatus.STARTING` æ‰ä¸ä¼šç»§ç»­è°ƒç”¨ OverrideExistsRule åŒ¹é…ï¼Œ`AbstractInstanceRegistry.overriddenInstanceStatusMap` æ‰æœ‰å¯èƒ½è¿‡æœŸã€‚

### 4.1.4 LeaseExistsRule

`com.netflix.eureka.registry.rule.LeaseExistsRule` ï¼ŒåŒ¹é…å·²å­˜åœ¨ç§Ÿçº¦çš„åº”ç”¨å®ä¾‹çš„ `nstanceStatus.OUT_OF_SERVICE` æˆ–è€… `InstanceInfo.InstanceStatus.UP` çŠ¶æ€ã€‚å®ç° `#apply(...)` ä»£ç å¦‚ä¸‹ï¼š

```Java
public StatusOverrideResult apply(InstanceInfo instanceInfo,
                                 Lease<InstanceInfo> existingLease,
                                 boolean isReplication) {
   // This is for backward compatibility until all applications have ASG
   // names, otherwise while starting up
   // the client status may override status replicated from other servers
   if (!isReplication) { // é Eureka-Server è¯·æ±‚
       InstanceInfo.InstanceStatus existingStatus = null;
       if (existingLease != null) {
           existingStatus = existingLease.getHolder().getStatus();
       }
       // Allow server to have its way when the status is UP or OUT_OF_SERVICE
       if ((existingStatus != null)
               && (InstanceInfo.InstanceStatus.OUT_OF_SERVICE.equals(existingStatus)
               || InstanceInfo.InstanceStatus.UP.equals(existingStatus))) {
           logger.debug("There is already an existing lease with status {}  for instance {}",
                   existingLease.getHolder().getStatus().name(),
                   existingLease.getHolder().getId());
           return StatusOverrideResult.matchingStatus(existingLease.getHolder().getStatus());
       }
   }
   return StatusOverrideResult.NO_MATCH;
}
```

* **æ³¨æ„**ï¼Œä½¿ç”¨çš„æ˜¯ `existingLease` ï¼Œå¹¶ä¸”é Eureka-Server è¯·æ±‚ã€‚

### 4.1.5 AlwaysMatchInstanceStatusRule

`com.netflix.eureka.registry.rule.AlwaysMatchInstanceStatusRule` ï¼Œæ€»æ˜¯åŒ¹é…**å…³æ³¨çŠ¶æ€çš„å®ä¾‹å¯¹è±¡**( `instanceInfo` )çš„çŠ¶æ€ã€‚å®ç° `#apply(...)` ä»£ç å¦‚ä¸‹ï¼š

```Java
@Override
public StatusOverrideResult apply(InstanceInfo instanceInfo,
                                 Lease<InstanceInfo> existingLease,
                                 boolean isReplication) {
   logger.debug("Returning the default instance status {} for instance {}", instanceInfo.getStatus(),
           instanceInfo.getId());
   return StatusOverrideResult.matchingStatus(instanceInfo.getStatus());
}
```

* **æ³¨æ„**ï¼Œä½¿ç”¨çš„æ˜¯ `instanceInfo` ã€‚

### 4.1.6 æ€»ç»“

æˆ‘ä»¬å°† PeerAwareInstanceRegistryImpl çš„åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€è§„åˆ™æ¢³ç†å¦‚ä¸‹ï¼š

![](http://www.iocoder.cn/images/Eureka/2018_07_10/02.png)

* åº”ç”¨å®ä¾‹çŠ¶æ€æ˜¯**æœ€é‡è¦**çš„å±æ€§ï¼Œæ²¡æœ‰ä¹‹ä¸€ï¼Œå› è€Œåœ¨æœ€ç»ˆå®ä¾‹çŠ¶æ€çš„è®¡ç®—ï¼Œä»¥**å¯ä¿¡èµ–**ä¸ºä¸»ã€‚
* DownOrStartingRule ï¼Œ`instanceInfo` å¤„äº `STARTING` æˆ–è€… `DOWN` çŠ¶æ€ï¼Œåº”ç”¨å®ä¾‹å¯èƒ½ä¸é€‚åˆæä¾›æœåŠ¡( è¢«è¯·æ±‚ )ï¼Œè€ƒè™‘**å¯ä¿¡èµ–**ï¼Œè¿”å› `instanceInfo` çš„çŠ¶æ€ã€‚
* OverrideExistsRule ï¼Œå½“å­˜åœ¨è¦†ç›–çŠ¶æ€( `statusoverrides` ) ï¼Œä½¿ç”¨è¯¥çŠ¶æ€ï¼Œæ¯”è¾ƒå¥½ç†è§£ã€‚
* LeaseExistsRule ï¼Œæ¥è‡ª Eureka-Client çš„è¯·æ±‚( é Eureka-Server é›†ç¾¤è¯·æ±‚)ï¼Œå½“ Eureka-Server çš„å®ä¾‹çŠ¶æ€**å­˜åœ¨**ï¼Œå¹¶ä¸”å¤„äº `UP` æˆ–åˆ™ `OUT_OF_SERVICE` ï¼Œä¿ç•™å½“å‰çŠ¶æ€ã€‚åŸå› ï¼Œ**ç¦æ­¢ Eureka-Client ä¸»åŠ¨åœ¨è¿™ä¸¤ä¸ªçŠ¶æ€ä¹‹é—´åˆ‡æ¢ã€‚å¦‚æœè¦åˆ‡æ¢ï¼Œä½¿ç”¨åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€å˜æ›´ä¸åˆ é™¤æ¥å£**ã€‚
* AlwaysMatchInstanceStatusRule ï¼Œä½¿ç”¨ `instanceInfo` çš„çŠ¶æ€è¿”å›ï¼Œä»¥ä¿è¯èƒ½åŒ¹é…åˆ°çŠ¶æ€ã€‚
* åœ¨ä¸‹æ–‡ä¸­ï¼Œä½ ä¼šçœ‹åˆ°ï¼Œ`#getOverriddenInstanceStatus()` æ–¹æ³•ä¼šåœ¨**æ³¨å†Œ**å’Œ**ç»­ç§Ÿ**ä½¿ç”¨åˆ°ã€‚ç»“åˆä¸Šå›¾ï¼Œæˆ‘ä»¬åœ¨ [ã€Œ4.2 æ³¨å†Œåœºæ™¯ã€](#) å’Œ [ã€Œ4.3 ç»­ç§Ÿåœºæ™¯ã€](#) ä¹Ÿä¼šè¯¦ç»†è§£æã€‚



* åœ¨ä¸‹æ–‡ä¸­ï¼Œä½ ä¼šçœ‹åˆ°ï¼Œ`#getOverriddenInstanceStatus()` æ–¹æ³•ä¼šåœ¨**æ³¨å†Œ**å’Œ**ç»­ç§Ÿ**ä½¿ç”¨åˆ°ï¼Œæ–¹æ³•å‚æ•° `instanceInfo` æƒ…å†µå¦‚ä¸‹ï¼š
    * **æ³¨å†Œæ—¶** ï¼šè¯·æ±‚å‚æ•° `instanceInfo` ï¼Œå’Œ `existingLease` çš„åº”ç”¨å®ä¾‹å±æ€§ä¸ç›¸ç­‰( å¦‚æœè€ƒè™‘ Eureka-Server çš„ `LastDirtyTimestamp` æ›´å¤§çš„æƒ…å†µï¼Œåˆ™ç±»ä¼¼ **ç»­ç§Ÿæ—¶çš„æƒ…å†µ** ) ã€‚
    * **ç»­ç§Ÿæ—¶** ï¼šä½¿ç”¨ Eureka-Server çš„ `existingLease` çš„åº”ç”¨å®ä¾‹ï¼Œä¸¤è€…ç›¸ç­‰ã€‚
    * **æ€»çš„æ¥è¯´ï¼Œå¯ä»¥å°† `instanceInfo` ç†è§£æˆè¯·æ±‚æ–¹çš„çŠ¶æ€**ã€‚
* DownOrStartingRule ï¼Œ

## 4.2 æ³¨å†Œåœºæ™¯

```Java
// AbstractInstanceRegistry.java
  1: public void register(InstanceInfo registrant, int leaseDuration, boolean isReplication) {
  2:     try {
  3:         // ï¼ˆ(çœç•¥ä»£ç ) ï¼‰è·å–é”
  4:         Map<String, Lease<InstanceInfo>> gMap = registry.get(registrant.getAppName());
  5:         // (çœç•¥ä»£ç ) å¢åŠ  æ³¨å†Œæ¬¡æ•° åˆ° ç›‘æ§
  6:         // (çœç•¥ä»£ç ) è·å¾— åº”ç”¨å®ä¾‹ä¿¡æ¯ å¯¹åº”çš„ ç§Ÿçº¦
  7:         Lease<InstanceInfo> existingLease = gMap.get(registrant.getId());
  8:         // Retain the last dirty timestamp without overwriting it, if there is already a lease
  9:         if (existingLease != null && (existingLease.getHolder() != null)) { // (çœç•¥ä»£ç ) å·²å­˜åœ¨æ—¶ï¼Œä½¿ç”¨æ•°æ®ä¸ä¸€è‡´çš„æ—¶é—´å¤§çš„åº”ç”¨æ³¨å†Œä¿¡æ¯ä¸ºæœ‰æ•ˆçš„
 10:         } else {
 11:             // The lease does not exist and hence it is a new registration
 12:             // (çœç•¥ä»£ç ) ã€è‡ªæˆ‘ä¿æŠ¤æœºåˆ¶ã€‘å¢åŠ  `numberOfRenewsPerMinThreshold` ã€`expectedNumberOfRenewsPerMin`
 13:         }
 14:         // åˆ›å»º ç§Ÿçº¦
 15:         Lease<InstanceInfo> lease = new Lease<InstanceInfo>(registrant, leaseDuration);
 16:         if (existingLease != null) { // è‹¥ç§Ÿçº¦å·²å­˜åœ¨ï¼Œè®¾ç½® ç§Ÿçº¦çš„å¼€å§‹æœåŠ¡çš„æ—¶é—´æˆ³
 17:             lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());
 18:         }
 19:         // æ·»åŠ åˆ° ç§Ÿçº¦æ˜ å°„
 20:         gMap.put(registrant.getId(), lease);
 21:         // (çœç•¥ä»£ç ) æ·»åŠ åˆ° æœ€è¿‘æ³¨å†Œçš„è°ƒè¯•é˜Ÿåˆ—
 22:         // (çœç•¥ä»£ç ) æ·»åŠ åˆ° åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€æ˜ å°„ï¼ˆEureka-Server åˆå§‹åŒ–ä½¿ç”¨ï¼‰
 23:         // è®¾ç½® åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€
 24:         InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(registrant.getId());
 25:         if (overriddenStatusFromMap != null) {
 26:             logger.info("Storing overridden status {} from map", overriddenStatusFromMap);
 27:             registrant.setOverriddenStatus(overriddenStatusFromMap);
 28:         }
 29: 
 30:         // è·å¾— åº”ç”¨å®ä¾‹çŠ¶æ€
 31:         // Set the status based on the overridden status rules
 32:         InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(registrant, existingLease, isReplication);
 33:         // è®¾ç½® åº”ç”¨å®ä¾‹çŠ¶æ€
 34:         registrant.setStatusWithoutDirty(overriddenInstanceStatus);
 35: 
 36:         // (çœç•¥ä»£ç ) è®¾ç½® ç§Ÿçº¦çš„å¼€å§‹æœåŠ¡çš„æ—¶é—´æˆ³ï¼ˆåªæœ‰ç¬¬ä¸€æ¬¡æœ‰æ•ˆï¼‰
 37:         // (çœç•¥ä»£ç ) è®¾ç½® åº”ç”¨å®ä¾‹ä¿¡æ¯çš„æ“ä½œç±»å‹ ä¸º æ·»åŠ 
 38:         // (çœç•¥ä»£ç ) æ·»åŠ åˆ° æœ€è¿‘ç§Ÿçº¦å˜æ›´è®°å½•é˜Ÿåˆ—
 39:         // (çœç•¥ä»£ç ) è®¾ç½® ç§Ÿçº¦çš„æœ€åæ›´æ–°æ—¶é—´æˆ³
 40:         // (çœç•¥ä»£ç ) è®¾ç½® å“åº”ç¼“å­˜ è¿‡æœŸ
 41:     } finally {
 42:         // (çœç•¥ä»£ç ) é‡Šæ”¾é”
 43:     }
 44: }
```

* ç¬¬ 7 è¡Œ ï¼šè·å¾—**å·²å­˜åœ¨**çš„ç§Ÿçº¦( `existingLease` ) ã€‚
* ç¬¬ 15 è¡Œ ï¼šåˆ›å»º**æ–°çš„**ç§Ÿçº¦( `lease` )ã€‚
* ç¬¬ 24 è‡³ 28 è¡Œ ï¼šè®¾ç½®åº”ç”¨å®ä¾‹çš„è¦†ç›–çŠ¶æ€( `overridestatus` )ï¼Œé¿å…æ³¨å†Œåº”ç”¨å®ä¾‹åï¼Œä¸¢å¤±è¦†ç›–çŠ¶æ€ã€‚
* ç¬¬ 30 è‡³ 32 è¡Œ ï¼š**è·å¾—åº”ç”¨å®ä¾‹æœ€ç»ˆçŠ¶æ€**ã€‚æ³¨æ„ä¸‹ï¼Œä¸è€ƒè™‘ç¬¬ 9 è¡Œä»£ç çš„æƒ…å†µï¼Œ`registrant` å’Œ `existingLease` çš„åº”ç”¨å®ä¾‹ä¸æ˜¯åŒä¸€ä¸ªå¯¹è±¡ã€‚
* ç¬¬ 33 åª 34 è¡Œ ï¼šè®¾ç½®åº”ç”¨å®ä¾‹çš„çŠ¶æ€ã€‚

## 4.3 ç»­ç§Ÿåœºæ™¯

```Java
// AbstractInstanceRegistry.java
  1: public boolean renew(String appName, String id, boolean isReplication) {
  2:     // ï¼ˆçœç•¥ä»£ç ï¼‰å¢åŠ  ç»­ç§Ÿæ¬¡æ•° åˆ° ç›‘æ§
  3:     // è·å¾— ç§Ÿçº¦
  4:     Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
  5:     Lease<InstanceInfo> leaseToRenew = null;
  6:     if (gMap != null) {
  7:         leaseToRenew = gMap.get(id);
  8:     }
  9:     // ï¼ˆçœç•¥ä»£ç ï¼‰ç§Ÿçº¦ä¸å­˜åœ¨
 10:     if (leaseToRenew == null) {
 11:         return false;
 12:     } else {
 13:         InstanceInfo instanceInfo = leaseToRenew.getHolder();
 14:         if (instanceInfo != null) {
 15:             // è·å¾— åº”ç”¨å®ä¾‹çŠ¶æ€
 16:             InstanceStatus overriddenInstanceStatus = this.getOverriddenInstanceStatus(
 17:                     instanceInfo, leaseToRenew, isReplication);
 18:             // åº”ç”¨å®ä¾‹çŠ¶æ€æœªçŸ¥ï¼Œæ— æ³•ç»­çº¦
 19:             if (overriddenInstanceStatus == InstanceStatus.UNKNOWN) {
 20:                 logger.info("Instance status UNKNOWN possibly due to deleted override for instance {}"
 21:                         + "; re-register required", instanceInfo.getId());
 22:                 RENEW_NOT_FOUND.increment(isReplication);
 23:                 return false;
 24:             }
 25:             // è®¾ç½® åº”ç”¨å®ä¾‹çŠ¶æ€
 26:             if (!instanceInfo.getStatus().equals(overriddenInstanceStatus)) {
 27:                 Object[] args = {
 28:                         instanceInfo.getStatus().name(),
 29:                         instanceInfo.getOverriddenStatus().name(),
 30:                         instanceInfo.getId()
 31:                 };
 32:                 logger.info(
 33:                         "The instance status {} is different from overridden instance status {} for instance {}. "
 34:                                 + "Hence setting the status to overridden status", args);
 35:                 instanceInfo.setStatusWithoutDirty(overriddenInstanceStatus);
 36:             }
 37:         }
 38:         // ï¼ˆçœç•¥ä»£ç ï¼‰æ–°å¢ ç»­ç§Ÿæ¯åˆ†é’Ÿæ¬¡æ•°
 39:         // ï¼ˆçœç•¥ä»£ç ï¼‰è®¾ç½® ç§Ÿçº¦æœ€åæ›´æ–°æ—¶é—´ï¼ˆç»­ç§Ÿï¼‰
 40:         return true;
 41:     }
 42: }
```

* ç¬¬ 15 è‡³ 17 è¡Œ ï¼šè·å¾—åº”ç”¨å®ä¾‹çš„**æœ€ç»ˆçŠ¶æ€**ã€‚
* ç¬¬ 18 è‡³ 24 è¡Œ ï¼šåº”ç”¨å®ä¾‹çš„**æœ€ç»ˆçŠ¶æ€**ä¸º `UNKNOWN`ï¼Œæ— æ³•ç»­çº¦ ã€‚è¿”å› `false` åï¼Œè¯·æ±‚æ–¹( Eureka-Client æˆ–è€… Eureka-Server é›†ç¾¤å…¶ä»–èŠ‚ç‚¹ )ä¼šå‘èµ·æ³¨å†Œï¼Œåœ¨ [ã€ŠEureka æºç è§£æ â€”â€” åº”ç”¨å®ä¾‹æ³¨å†Œå‘ç°ï¼ˆäºŒï¼‰ä¹‹ç»­ç§Ÿã€‹](http://www.iocoder.cn/Eureka/instance-registry-renew/) æœ‰è¯¦ç»†è§£æã€‚**ä¸ºä»€ä¹ˆä¼šæ˜¯ `UNKNOWN` å‘¢**ï¼Ÿåœ¨ [ã€Œ3. åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€åˆ é™¤æ¥å£ã€](#) ä¼ é€’åº”ç”¨å®ä¾‹çŠ¶æ€ä¸º `UNKNOWN` ã€‚
* ç¬¬ 25 è‡³ 36 è¡Œ ï¼šåº”ç”¨å®ä¾‹çš„çŠ¶æ€ä¸**æœ€ç»ˆçŠ¶æ€**ä¸ç›¸ç­‰ï¼Œä½¿ç”¨**æœ€ç»ˆçŠ¶æ€**è¦†ç›–åº”ç”¨å®ä¾‹çš„çŠ¶æ€ã€‚**ä¸ºä»€ä¹ˆä¼šä¸ç›¸ç­‰**å‘¢ï¼Ÿ`#renew(...)` å’Œ `#statusUpdate(...)` å¯ä»¥æ— é”ï¼Œå¹¶è¡Œæ‰§è¡Œï¼Œå¦‚æœ 
    * `#renew(...)` æ‰§è¡Œå®Œç¬¬ 16 è¡Œä»£ç ï¼Œè·å–åˆ° `overriddenInstanceStatus` åï¼Œæ°å·§ `#statusUpdate(...)` æ‰§è¡Œå®Œæ›´æ–°åº”ç”¨å®ä¾‹çŠ¶æ€ `newStatus`ï¼Œåˆæ°å¥½ä¸¤è€…ä¸ç›¸ç­‰ï¼Œä½¿ç”¨ `overriddenInstanceStatus` è¦†ç›–æ‰åº”ç”¨å®ä¾‹çš„ `newStatus` çŠ¶æ€ã€‚
    * **é‚£å²‚ä¸æ˜¯è¦†ç›–çŠ¶æ€( `overriddenstatus` )åå€’è¢«è¦†ç›–**ï¼Ÿï¼Ÿï¼Ÿä¸ä¼šï¼Œåœ¨ä¸‹ä¸€æ¬¡å¿ƒè·³ï¼Œåº”ç”¨å®ä¾‹çš„çŠ¶æ€ä¼šè¢«ä¿®æ­£å›æ¥ã€‚å½“ç„¶ï¼Œå¦‚æœåº”ç”¨å®ä¾‹çŠ¶æ€å¦‚æœä¸º `UP` æˆ–è€… `STARTING` ä¸ä¼šè¢«ä¿®æ­£ï¼Œä¹Ÿä¸åº”è¯¥è¢«ä¿®æ­£ã€‚

## 4.4 ä¸‹çº¿åœºæ™¯

```Java
// AbstractInstanceRegistry.java
protected boolean internalCancel(String appName, String id, boolean isReplication) {

    // ... çœç•¥æ— å…³ä»£ç 
    
    // ç§»é™¤ åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€æ˜ å°„
    InstanceStatus instanceStatus = overriddenInstanceStatusMap.remove(id);
    if (instanceStatus != null) {
        logger.debug("Removed instance id {} from the overridden map which has value {}", id, instanceStatus.name());
    }

}
```

## 4.5 è¿‡æœŸåœºæ™¯

åŒ [ã€Œ4.4 ä¸‹çº¿åœºæ™¯ã€](#) ç›¸åŒã€‚

# 5. å®¢æˆ·ç«¯è°ƒç”¨æ¥å£

å¯¹åº”ç”¨å®ä¾‹è¦†ç›–çŠ¶æ€çš„å˜æ›´å’Œåˆ é™¤æ¥å£è°ƒç”¨ï¼Œç‚¹å‡»å¦‚ä¸‹æ–¹æ³•æŸ¥çœ‹ï¼Œéå¸¸æ˜“æ‡‚ï¼Œæœ¬æ–‡å°±ä¸å•°å—¦äº†ï¼š

* [`AbstractJerseyEurekaHttpClient#statusUpdate(...)`](https://github.com/Netflix/eureka/blob/d2dbee8a79b3c6dd9b553eb3f702f7721797bcd6/eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/AbstractJerseyEurekaHttpClient.java#L119)
* [`AbstractJerseyEurekaHttpClient#deleteStatusOverride(...)`](https://github.com/Netflix/eureka/blob/d2dbee8a79b3c6dd9b553eb3f702f7721797bcd6/eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/AbstractJerseyEurekaHttpClient.java#L142)

# 666. å½©è›‹

![çŸ¥è¯†æ˜Ÿçƒ](http://www.iocoder.cn/images/Architecture/2017_12_29/01.png)

çŒœæµ‹è¦†ç›–çŠ¶æ€çš„èŠ±è´¹äº†è¾ƒé•¿æ—¶é—´ï¼Œæ¢³ç†åº”ç”¨å®ä¾‹è¦†ç›–è§„åˆ™è€—è´¹å¤§é‡è„‘ç»†èƒã€‚

ä¸‹ä¸€ç¯‡ï¼Œè®©æˆ‘é¸¡é¸¡åŠ¨åŠ¨çš„ï¼ŒEureka-Server é›†ç¾¤åŒæ­¥èµ°èµ·ï¼

èƒ–å‹ï¼Œåˆ†äº«æˆ‘çš„å…¬ä¼—å·( **èŠ‹é“æºç ** ) ç»™ä½ çš„èƒ–å‹å¯å¥½ï¼Ÿ


