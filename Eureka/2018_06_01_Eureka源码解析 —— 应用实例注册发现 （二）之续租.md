title: Eureka æºç è§£æ â€”â€” åº”ç”¨å®ä¾‹æ³¨å†Œå‘ç°ï¼ˆäºŒï¼‰ä¹‹ç»­ç§Ÿ
date: 2018-06-01
tags:
categories: Eureka
permalink: Eureka/instance-registry-renew

---

æ‘˜è¦: åŸåˆ›å‡ºå¤„ http://www.iocoder.cn/Eureka/instance-registry-renew/ ã€ŒèŠ‹é“æºç ã€æ¬¢è¿è½¬è½½ï¼Œä¿ç•™æ‘˜è¦ï¼Œè°¢è°¢ï¼

**æœ¬æ–‡ä¸»è¦åŸºäº Eureka 1.8.X ç‰ˆæœ¬** 

- [1. æ¦‚è¿°](http://www.iocoder.cn/Eureka/instance-registry-renew/)
- [2. Eureka-Client å‘èµ·ç»­ç§Ÿ](http://www.iocoder.cn/Eureka/instance-registry-renew/)
  - [2.1 åˆå§‹åŒ–å®šæ—¶ä»»åŠ¡](http://www.iocoder.cn/Eureka/instance-registry-renew/)
  - [2.2 HeartbeatThread](http://www.iocoder.cn/Eureka/instance-registry-renew/)
  - [2.3 TimedSupervisorTask](http://www.iocoder.cn/Eureka/instance-registry-renew/)
- [3. Eureka-Server æ¥æ”¶ç»­ç§Ÿ](http://www.iocoder.cn/Eureka/instance-registry-renew/)
  - [3.1 æ¥æ”¶ç»­ç§Ÿè¯·æ±‚](http://www.iocoder.cn/Eureka/instance-registry-renew/)
  - [3.2 ç»­ç§Ÿåº”ç”¨å®ä¾‹ä¿¡æ¯](http://www.iocoder.cn/Eureka/instance-registry-renew/)
- [666. å½©è›‹](http://www.iocoder.cn/Eureka/instance-registry-renew/)

-------

![](http://www.iocoder.cn/images/common/wechat_mp_2018_05_18.jpg)

> ğŸ™‚ğŸ™‚ğŸ™‚å…³æ³¨**å¾®ä¿¡å…¬ä¼—å·ï¼šã€èŠ‹é“æºç ã€‘**æœ‰ç¦åˆ©ï¼š  
> 1. RocketMQ / MyCAT / Sharding-JDBC **æ‰€æœ‰**æºç åˆ†ææ–‡ç« åˆ—è¡¨  
> 2. RocketMQ / MyCAT / Sharding-JDBC **ä¸­æ–‡æ³¨é‡Šæºç  GitHub åœ°å€**  
> 3. æ‚¨å¯¹äºæºç çš„ç–‘é—®æ¯æ¡ç•™è¨€**éƒ½**å°†å¾—åˆ°**è®¤çœŸ**å›å¤ã€‚**ç”šè‡³ä¸çŸ¥é“å¦‚ä½•è¯»æºç ä¹Ÿå¯ä»¥è¯·æ•™å™¢**ã€‚  
> 4. **æ–°çš„**æºç è§£ææ–‡ç« **å®æ—¶**æ”¶åˆ°é€šçŸ¥ã€‚**æ¯å‘¨æ›´æ–°ä¸€ç¯‡å·¦å³**ã€‚  
> 5. **è®¤çœŸçš„**æºç äº¤æµå¾®ä¿¡ç¾¤ã€‚

-------


# 1. æ¦‚è¿°

æœ¬æ–‡ä¸»è¦åˆ†äº« **Eureka-Client å‘ Eureka-Server ç»­ç§Ÿåº”ç”¨å®ä¾‹çš„è¿‡ç¨‹**ã€‚

> FROM [ã€Šæ·±åº¦å‰–ææœåŠ¡å‘ç°ç»„ä»¶Netflix Eurekaã€‹](ã€Šhttp://techshow.ctrip.com/archives/1699.htmlã€‹) äºŒæ¬¡ç¼–è¾‘    
> ![](http://www.iocoder.cn/images/Eureka/2018_06_01/01.jpeg)

* **è“æ¡†**éƒ¨åˆ†ï¼Œä¸ºæœ¬æ–‡é‡ç‚¹ã€‚
* é**è“æ¡†**éƒ¨åˆ†ï¼ŒEureka-Server é›†ç¾¤é—´å¤åˆ¶æ³¨å†Œçš„åº”ç”¨å®ä¾‹ä¿¡æ¯ï¼Œä¸åœ¨æœ¬æ–‡å†…å®¹èŒƒç•´ã€‚

**æ¨è Spring Cloud ä¹¦ç±**ï¼š

* è¯·æ”¯æŒæ­£ç‰ˆã€‚ä¸‹è½½ç›—ç‰ˆï¼Œ**ç­‰äºä¸»åŠ¨ç¼–å†™ä½çº§ BUG** ã€‚
* ç¨‹åºçŒ¿DD â€”â€” [ã€ŠSpring Cloudå¾®æœåŠ¡å®æˆ˜ã€‹](https://union-click.jd.com/jdc?d=505Twi)
* å‘¨ç«‹ â€”â€” [ã€ŠSpring Cloudä¸Dockerå¾®æœåŠ¡æ¶æ„å®æˆ˜ã€‹](https://union-click.jd.com/jdc?d=k3sAaK)



# 2. Eureka-Client å‘èµ·ç»­ç§Ÿ

Eureka-Client å‘ Eureka-Server å‘èµ·æ³¨å†Œåº”ç”¨å®ä¾‹æˆåŠŸåè·å¾—ç§Ÿçº¦ ( Lease )ã€‚
Eureka-Client **å›ºå®šé—´éš”**å‘ Eureka-Server å‘èµ·**ç»­ç§Ÿ**( renew )ï¼Œé¿å…ç§Ÿçº¦è¿‡æœŸã€‚

é»˜è®¤æƒ…å†µä¸‹ï¼Œç§Ÿçº¦æœ‰æ•ˆæœŸä¸º 90 ç§’ï¼Œç»­ç§Ÿé¢‘ç‡ä¸º 30 ç§’ã€‚ä¸¤è€…æ¯”ä¾‹ä¸º 1 : 3 ï¼Œä¿è¯åœ¨ç½‘ç»œå¼‚å¸¸ç­‰æƒ…å†µä¸‹ï¼Œæœ‰ä¸‰æ¬¡é‡è¯•çš„æœºä¼šã€‚

## 2.1 åˆå§‹åŒ–å®šæ—¶ä»»åŠ¡

Eureka-Client åœ¨[åˆå§‹åŒ–](http://www.iocoder.cn/Eureka/eureka-client-init-third/?self)è¿‡ç¨‹ä¸­ï¼Œåˆ›å»º**å¿ƒè·³**çº¿ç¨‹ï¼Œ**å›ºå®šé—´éš”**å‘ Eureka-Server å‘èµ·**ç»­ç§Ÿ**( renew )ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
// DiscoveryClient.java

DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,
               Provider<BackupRegistry> backupRegistryProvider) {
    // ... çœç•¥æ— å…³ä»£ç 
    scheduler = Executors.newScheduledThreadPool(2,
               new ThreadFactoryBuilder()
                       .setNameFormat("DiscoveryClient-%d")
                       .setDaemon(true)
                       .build());

    heartbeatExecutor = new ThreadPoolExecutor(
              1, clientConfig.getHeartbeatExecutorThreadPoolSize(), 0, TimeUnit.SECONDS,
              new SynchronousQueue<Runnable>(),
              new ThreadFactoryBuilder()
                      .setNameFormat("DiscoveryClient-HeartbeatExecutor-%d")
                      .setDaemon(true)
                      .build()
    );  // use direct handoff
      
    // ... çœç•¥æ— å…³ä»£ç 
  
    // ã€3.2.14ã€‘åˆå§‹åŒ–å®šæ—¶ä»»åŠ¡
    initScheduledTasks();
}

private void initScheduledTasks() {

    // å‘ Eureka-Server å¿ƒè·³ï¼ˆç»­ç§Ÿï¼‰æ‰§è¡Œå™¨
    if (clientConfig.shouldRegisterWithEureka()) {
        int renewalIntervalInSecs = instanceInfo.getLeaseInfo().getRenewalIntervalInSecs(); // ç»­ç§Ÿé¢‘ç‡
        int expBackOffBound = clientConfig.getHeartbeatExecutorExponentialBackOffBound(); //
        logger.info("Starting heartbeat executor: " + "renew interval is: " + renewalIntervalInSecs);

        // Heartbeat timer
        scheduler.schedule(
               new TimedSupervisorTask(
                       "heartbeat",
                       scheduler,
                       heartbeatExecutor,
                       renewalIntervalInSecs,
                       TimeUnit.SECONDS,
                       expBackOffBound,
                       new HeartbeatThread()
               ),
               renewalIntervalInSecs, TimeUnit.SECONDS);
               
          // ... çœç•¥æ— å…³ä»£ç 
     }
     // ... çœç•¥æ— å…³ä»£ç 
}
```

* `scheduler`ï¼Œå®šæ—¶ä»»åŠ¡æœåŠ¡ï¼Œç”¨äºå®šæ—¶è§¦å‘å¿ƒè·³( ç»­ç§Ÿ )ã€‚ç»†å¿ƒå¦‚ä½ ï¼Œä¼šå‘ç°ä»»åŠ¡æäº¤çš„æ–¹å¼æ˜¯ `ScheduledExecutorService#schedule(...)` æ–¹æ³•ï¼Œ**åªå»¶è¿Ÿæ‰§è¡Œä¸€æ¬¡å¿ƒè·³ï¼Œè¯´å¥½çš„å›ºå®šé¢‘ç‡æ‰§è¡Œå¿ƒè·³å‘¢**ï¼ï¼ï¼ç­”æ¡ˆåœ¨ [ã€Œ2.3 TimedSupervisorTaskã€](#) æ­æ™“ã€‚
* `heartbeatExecutor`ï¼Œå¿ƒè·³ä»»åŠ¡æ‰§è¡Œçº¿ç¨‹æ± ã€‚ä¸ºä»€ä¹ˆæœ‰ `scheduler` çš„æƒ…å†µä¸‹ï¼Œè¿˜æœ‰ `heartbeatExecutor` ï¼Ÿï¼Ÿï¼Ÿç­”æ¡ˆä¹Ÿåœ¨ [ã€Œ2.3 TimedSupervisorTaskã€](#) æ­æ™“ã€‚
* HeartbeatThreadï¼Œå¿ƒè·³çº¿ç¨‹ï¼Œåœ¨[ã€Œ2.2 TimedSupervisorTaskã€](#) è¯¦ç»†è§£æã€‚

## 2.2 HeartbeatThread

`com.netflix.discovery.DiscoveryClient.HeartbeatThread`ï¼Œå¿ƒè·³çº¿ç¨‹ï¼Œ**å®ç°**æ‰§è¡Œ Eureka-Client å‘ Eureka-Server å‘èµ·**ç»­ç§Ÿ**( renew )è¯·æ±‚ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
// DiscoveryClient.java
/**
* æœ€åæˆåŠŸå‘ Eureka-Server å¿ƒè·³æ—¶é—´æˆ³
*/
private volatile long lastSuccessfulHeartbeatTimestamp = -1;

private class HeartbeatThread implements Runnable {

   public void run() {
       if (renew()) {
           lastSuccessfulHeartbeatTimestamp = System.currentTimeMillis();
       }
   }
}
```

* è°ƒç”¨ `#renew` æ–¹æ³•ï¼Œæ‰§è¡Œç»­ç§Ÿé€»è¾‘ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    // DiscoveryClient.java
    boolean renew() {
       EurekaHttpResponse<InstanceInfo> httpResponse;
       try {
           httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, null);
           logger.debug("{} - Heartbeat status: {}", PREFIX + appPathIdentifier, httpResponse.getStatusCode());
           if (httpResponse.getStatusCode() == 404) {
               REREGISTER_COUNTER.increment();
               logger.info("{} - Re-registering apps/{}", PREFIX + appPathIdentifier, instanceInfo.getAppName());
               long timestamp = instanceInfo.setIsDirtyWithTime();
               // å‘èµ·æ³¨å†Œ
               boolean success = register();
               if (success) {
                   instanceInfo.unsetIsDirty(timestamp);
               }
               return success;
           }
           return httpResponse.getStatusCode() == 200;
       } catch (Throwable e) {
           logger.error("{} - was unable to send heartbeat!", PREFIX + appPathIdentifier, e);
           return false;
       }
    }
    ```
    * è°ƒç”¨ `AbstractJerseyEurekaHttpClient#sendHeartBeat(...)` æ–¹æ³•ï¼Œå‘èµ·**ç»­ç§Ÿè¯·æ±‚**ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

        ```Java
        // AbstractJerseyEurekaHttpClient.java
        @Override
        public EurekaHttpResponse<InstanceInfo> sendHeartBeat(String appName, String id, InstanceInfo info, InstanceStatus overriddenStatus) {
           String urlPath = "apps/" + appName + '/' + id;
           ClientResponse response = null;
           try {
               WebResource webResource = jerseyClient.resource(serviceUrl)
                       .path(urlPath)
                       .queryParam("status", info.getStatus().toString())
                       .queryParam("lastDirtyTimestamp", info.getLastDirtyTimestamp().toString());
               if (overriddenStatus != null) {
                   webResource = webResource.queryParam("overriddenstatus", overriddenStatus.name());
               }
               Builder requestBuilder = webResource.getRequestBuilder();
               addExtraHeaders(requestBuilder);
               response = requestBuilder.put(ClientResponse.class);
               EurekaHttpResponseBuilder<InstanceInfo> eurekaResponseBuilder = anEurekaHttpResponse(response.getStatus(), InstanceInfo.class).headers(headersOf(response));
               if (response.hasEntity()) {
                   eurekaResponseBuilder.entity(response.getEntity(InstanceInfo.class));
               }
               return eurekaResponseBuilder.build();
           } finally {
               if (logger.isDebugEnabled()) {
                   logger.debug("Jersey HTTP PUT {}/{}; statusCode={}", serviceUrl, urlPath, response == null ? "N/A" : response.getStatus());
               }
               if (response != null) {
                   response.close();
               }
           }
        }
        ```
        * PUT è¯·æ±‚ Eureka-Server çš„ `apps/${APP_NAME}/${INSTANCE_INFO_ID}` æ¥å£ï¼Œå‚æ•°ä¸º `status`ã€`lastDirtyTimestamp`ã€`overriddenstatus`ï¼Œå®ç°ç»­ç§Ÿã€‚
    
    * è°ƒç”¨ `AbstractJerseyEurekaHttpClient#register(...)` æ–¹æ³•ï¼Œå½“ Eureka-Server **ä¸å­˜åœ¨ç§Ÿçº¦**æ—¶ï¼Œé‡æ–°å‘èµ·æ³¨å†Œï¼Œåœ¨[ã€ŠEureka æºç è§£æ â€”â€” åº”ç”¨å®ä¾‹æ³¨å†Œå‘ç° ï¼ˆä¸€ï¼‰ä¹‹æ³¨å†Œã€‹](http://www.iocoder.cn/Eureka/instance-registry-register/?self)æœ‰è¯¦ç»†è§£æã€‚

## 2.3 TimedSupervisorTask

`com.netflix.discovery.TimedSupervisorTask`ï¼Œç›‘ç®¡**å®šæ—¶ä»»åŠ¡**çš„ä»»åŠ¡ã€‚

> A supervisor task that schedules subtasks while enforce a timeout.

åˆ›å»º TimedSupervisorTask ä»£ç å¦‚ä¸‹ï¼š

```Java
public class TimedSupervisorTask extends TimerTask {

    private final Counter timeoutCounter;
    private final Counter rejectedCounter;
    private final Counter throwableCounter;
    private final LongGauge threadPoolLevelGauge;

    /**
     * å®šæ—¶ä»»åŠ¡æœåŠ¡
     */
    private final ScheduledExecutorService scheduler;
    /**
     * æ‰§è¡Œå­ä»»åŠ¡çº¿ç¨‹æ± 
     */
    private final ThreadPoolExecutor executor;
    /**
     * å­ä»»åŠ¡æ‰§è¡Œè¶…æ—¶æ—¶é—´
     */
    private final long timeoutMillis;
    /**
     * å­ä»»åŠ¡
     */
    private final Runnable task;
    /**
     * å½“å‰ä»»å­åŠ¡æ‰§è¡Œé¢‘ç‡
     */
    private final AtomicLong delay;
    /**
     * æœ€å¤§å­ä»»åŠ¡æ‰§è¡Œé¢‘ç‡
     *
     * å­ä»»åŠ¡æ‰§è¡Œè¶…æ—¶æƒ…å†µä¸‹ä½¿ç”¨
     */
    private final long maxDelay;

    public TimedSupervisorTask(String name, ScheduledExecutorService scheduler, ThreadPoolExecutor executor,
                               int timeout, TimeUnit timeUnit, int expBackOffBound, Runnable task) {
        this.scheduler = scheduler;
        this.executor = executor;
        this.timeoutMillis = timeUnit.toMillis(timeout);
        this.task = task;
        this.delay = new AtomicLong(timeoutMillis);
        this.maxDelay = timeoutMillis * expBackOffBound;

        // Initialize the counters and register.
        timeoutCounter = Monitors.newCounter("timeouts");
        rejectedCounter = Monitors.newCounter("rejectedExecutions");
        throwableCounter = Monitors.newCounter("throwables");
        threadPoolLevelGauge = new LongGauge(MonitorConfig.builder("threadPoolUsed").build());
        Monitors.registerObject(name, this);
    }

}
```

* `scheduler` ï¼Œå®šæ—¶ä»»åŠ¡æœåŠ¡ï¼Œç”¨äºå®šæ—¶ã€**å‘èµ·**ã€‘å­ä»»åŠ¡ã€‚
* `executor` ï¼Œæ‰§è¡Œå­ä»»åŠ¡çº¿ç¨‹æ± ï¼Œç”¨äºã€**æäº¤**ã€‘å­ä»»åŠ¡æ‰§è¡Œã€‚
* `task` ï¼Œå­ä»»åŠ¡ã€‚
* `timeoutMillis` ï¼Œå­ä»»åŠ¡æ‰§è¡Œè¶…æ—¶æ—¶é—´ï¼Œå•ä½ï¼šæ¯«ç§’ã€‚
* `delay` ï¼Œå½“å‰å­ä»»åŠ¡æ‰§è¡Œé¢‘ç‡ï¼Œå•ä½ï¼šæ¯«ç§’ã€‚å€¼ç­‰äº `timeout` å‚æ•°ã€‚
* `maxDelay` ï¼Œ**æœ€å¤§**å­ä»»åŠ¡æ‰§è¡Œé¢‘ç‡ï¼Œå•ä½ï¼šæ¯«ç§’ã€‚å€¼ç­‰äº `timeout * expBackOffBound` å‚æ•°ã€‚

![](http://www.iocoder.cn/images/Eureka/2018_06_01/02.png)

* `scheduler` åˆå§‹åŒ–å»¶è¿Ÿæ‰§è¡Œ TimedSupervisorTask ã€‚
* TimedSupervisorTask æ‰§è¡Œæ—¶ï¼Œæäº¤ `task` åˆ° `executor` æ‰§è¡Œä»»åŠ¡ã€‚
    * å½“ `task` æ‰§è¡Œæ­£å¸¸ï¼ŒTimedSupervisorTask **å†æ¬¡**æäº¤**è‡ªå·±**åˆ°`scheduler` å»¶è¿Ÿ `timeoutMillis` æ‰§è¡Œã€‚
    * å½“ `task` æ‰§è¡Œè¶…æ—¶ï¼Œé‡æ–°è®¡ç®—å»¶è¿Ÿæ—¶é—´( ä¸å…è®¸è¶…è¿‡ `maxDelay` )ï¼Œ**å†æ¬¡**æäº¤**è‡ªå·±**åˆ°`scheduler` å»¶è¿Ÿæ‰§è¡Œã€‚

å®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
// TimedSupervisorTask.java
  1: @Override
  2: public void run() {
  3:     Future<?> future = null;
  4:     try {
  5:         // æäº¤ ä»»åŠ¡
  6:         future = executor.submit(task);
  7:         //
  8:         threadPoolLevelGauge.set((long) executor.getActiveCount());
  9:         // ç­‰å¾…ä»»åŠ¡ æ‰§è¡Œå®Œæˆ æˆ– è¶…æ—¶
 10:         future.get(timeoutMillis, TimeUnit.MILLISECONDS);  // block until done or timeout
 11:         // è®¾ç½® ä¸‹ä¸€æ¬¡ä»»åŠ¡æ‰§è¡Œé¢‘ç‡
 12:         delay.set(timeoutMillis);
 13:         //
 14:         threadPoolLevelGauge.set((long) executor.getActiveCount());
 15:     } catch (TimeoutException e) {
 16:         logger.error("task supervisor timed out", e);
 17:         timeoutCounter.increment(); //
 18: 
 19:         // è®¾ç½® ä¸‹ä¸€æ¬¡ä»»åŠ¡æ‰§è¡Œé¢‘ç‡
 20:         long currentDelay = delay.get();
 21:         long newDelay = Math.min(maxDelay, currentDelay * 2);
 22:         delay.compareAndSet(currentDelay, newDelay);
 23: 
 24:     } catch (RejectedExecutionException e) {
 25:         if (executor.isShutdown() || scheduler.isShutdown()) {
 26:             logger.warn("task supervisor shutting down, reject the task", e);
 27:         } else {
 28:             logger.error("task supervisor rejected the task", e);
 29:         }
 30: 
 31:         rejectedCounter.increment(); //
 32:     } catch (Throwable e) {
 33:         if (executor.isShutdown() || scheduler.isShutdown()) {
 34:             logger.warn("task supervisor shutting down, can't accept the task");
 35:         } else {
 36:             logger.error("task supervisor threw an exception", e);
 37:         }
 38: 
 39:         throwableCounter.increment(); //
 40:     } finally {
 41:         // å–æ¶ˆ æœªå®Œæˆçš„ä»»åŠ¡
 42:         if (future != null) {
 43:             future.cancel(true);
 44:         }
 45: 
 46:         // è°ƒåº¦ ä¸‹æ¬¡ä»»åŠ¡
 47:         if (!scheduler.isShutdown()) {
 48:             scheduler.schedule(this, delay.get(), TimeUnit.MILLISECONDS);
 49:         }
 50:     }
 51: }
```

* ç¬¬ 5 è‡³ 6 è¡Œ ï¼šæäº¤å­ä»»åŠ¡ `task` åˆ°æ‰§è¡Œå­ä»»åŠ¡çº¿ç¨‹æ±  `executor` ã€‚
* ç¬¬ 9 è‡³ 10 è¡Œ ï¼šç­‰å¾…å­ä»»åŠ¡ `task` æ‰§è¡Œå®Œæˆæˆ–æ‰§è¡Œè¶…æ—¶ã€‚
* ç¬¬ 11 è‡³ 12 è¡Œ ï¼šå­ä»»åŠ¡ `task` æ‰§è¡Œå®Œæˆï¼Œè®¾ç½®ä¸‹ä¸€æ¬¡æ‰§è¡Œå»¶è¿Ÿ `delay` ã€‚
* ç¬¬ 19 è‡³ 22 è¡Œ ï¼šå­ä»»åŠ¡ `task` æ‰§è¡Œè¶…æ—¶ï¼Œé‡æ–°è®¡ç®—ä¸‹ä¸€æ¬¡æ‰§è¡Œå»¶è¿Ÿ `delay` ã€‚è®¡ç®—å…¬å¼ä¸º `Math.min(maxDelay, currentDelay * 2)` ã€‚å¦‚æœå¤šæ¬¡è¶…æ—¶ï¼Œè¶…æ—¶æ—¶é—´ä¸æ–­ä¹˜ä»¥ 2 ï¼Œä¸å…è®¸è¶…è¿‡æœ€å¤§å»¶è¿Ÿæ—¶é—´( `maxDelay` )ã€‚
* ç¬¬ 41 è‡³ 44 è¡Œ ï¼š**å¼ºåˆ¶**å–æ¶ˆæœªå®Œæˆçš„å­ä»»åŠ¡ã€‚
* ç¬¬ 46 è‡³ 49 è¡Œ ï¼šè°ƒåº¦ä¸‹ä¸€æ¬¡ TimedSupervisorTask ã€‚


# 3. Eureka-Server æ¥æ”¶ç»­ç§Ÿ

## 3.1 æ¥æ”¶ç»­ç§Ÿè¯·æ±‚

`com.netflix.eureka.resources.InstanceResource`ï¼Œå¤„ç†**å•ä¸ª**åº”ç”¨å®ä¾‹ä¿¡æ¯çš„è¯·æ±‚æ“ä½œçš„ Resource ( Controller )ã€‚

ç»­ç§Ÿåº”ç”¨å®ä¾‹ä¿¡æ¯çš„è¯·æ±‚ï¼Œæ˜ å°„ `InstanceResource#renewLease()` æ–¹æ³•ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
  1: @PUT
  2: public Response renewLease(
  3:         @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication,
  4:         @QueryParam("overriddenstatus") String overriddenStatus,
  5:         @QueryParam("status") String status,
  6:         @QueryParam("lastDirtyTimestamp") String lastDirtyTimestamp) {
  7:     boolean isFromReplicaNode = "true".equals(isReplication);
  8:     // ç»­ç§Ÿ
  9:     boolean isSuccess = registry.renew(app.getName(), id, isFromReplicaNode);
 10: 
 11:     // ç»­ç§Ÿå¤±è´¥
 12:     // Not found in the registry, immediately ask for a register
 13:     if (!isSuccess) {
 14:         logger.warn("Not Found (Renew): {} - {}", app.getName(), id);
 15:         return Response.status(Status.NOT_FOUND).build();
 16:     }
 17: 
 18:     // æ¯”è¾ƒ InstanceInfo çš„ lastDirtyTimestamp å±æ€§
 19:     // Check if we need to sync based on dirty time stamp, the client
 20:     // instance might have changed some value
 21:     Response response = null;
 22:     if (lastDirtyTimestamp != null && serverConfig.shouldSyncWhenTimestampDiffers()) {
 23:         response = this.validateDirtyTimestamp(Long.valueOf(lastDirtyTimestamp), isFromReplicaNode);
 24:         // Store the overridden status since the validation found out the node that replicates wins
 25:         if (response.getStatus() == Response.Status.NOT_FOUND.getStatusCode()
 26:                 && (overriddenStatus != null)
 27:                 && !(InstanceStatus.UNKNOWN.name().equals(overriddenStatus))
 28:                 && isFromReplicaNode) {
 29:             registry.storeOverriddenStatusIfRequired(app.getAppName(), id, InstanceStatus.valueOf(overriddenStatus));
 30:         }
 31:     } else { // æˆåŠŸ
 32:         response = Response.ok().build();
 33:     }
 34:     logger.debug("Found (Renew): {} - {}; reply status={}" + app.getName(), id, response.getStatus());
 35:     return response;
 36: }
```

* ç¬¬ 8 è‡³ 9 è¡Œ ï¼šè°ƒç”¨ `PeerAwareInstanceRegistryImpl#renew(...)` æ–¹æ³•ï¼Œç»­ç§Ÿã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    // PeerAwareInstanceRegistryImpl.java
    public boolean renew(final String appName, final String id, final boolean isReplication) {
       if (super.renew(appName, id, isReplication)) { // ç»­ç§Ÿ
           // Eureka-Server å¤åˆ¶
           replicateToPeers(Action.Heartbeat, appName, id, null, null, isReplication);
           return true;
       }
       return false;
    }
    ```
    * è°ƒç”¨çˆ¶ç±» `AbstractInstanceRegistry#renew(...)` æ–¹æ³•ï¼Œæ³¨å†Œåº”ç”¨å®ä¾‹ä¿¡æ¯ã€‚

* ç¬¬ 11 è‡³ 16 è¡Œ ï¼šç»­ç§Ÿå¤±è´¥ï¼Œè¿”å› 404 å“åº”ã€‚å½“ Eureka-Client æ”¶åˆ° 404 å“åº”åï¼Œä¼šé‡æ–°å‘èµ· InstanceInfo çš„æ³¨å†Œã€‚
* ç¬¬ 18 è‡³ 30 è¡Œ ï¼šæ¯”è¾ƒè¯·æ±‚çš„ `lastDirtyTimestamp` å’Œ Server çš„ InstanceInfo çš„ `lastDirtyTimestamp` å±æ€§å·®å¼‚ï¼Œéœ€è¦é…ç½® `eureka.syncWhenTimestampDiffers = true` ( é»˜è®¤å¼€å¯ )ã€‚
    * ç¬¬ 23 è¡Œ ï¼šè°ƒç”¨ `#validateDirtyTimestamp(...)` æ–¹æ³•ï¼Œæ¯”è¾ƒ `lastDirtyTimestamp` çš„å·®å¼‚ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

        ```Java
        // InstanceResource.java
          1: private Response validateDirtyTimestamp(Long lastDirtyTimestamp, boolean isReplication) {
          2:     // è·å– InstanceInfo
          3:     InstanceInfo appInfo = registry.getInstanceByAppAndId(app.getName(), id, false);
          4:     if (appInfo != null) {
          5:         if ((lastDirtyTimestamp != null) && (!lastDirtyTimestamp.equals(appInfo.getLastDirtyTimestamp()))) {
          6:             Object[] args = {id, appInfo.getLastDirtyTimestamp(), lastDirtyTimestamp, isReplication};
          7:             // è¯·æ±‚ çš„ è¾ƒå¤§
          8:             if (lastDirtyTimestamp > appInfo.getLastDirtyTimestamp()) {
          9:                 logger.debug("Time to sync, since the last dirty timestamp differs -"
         10:                                 + " ReplicationInstance id : {},Registry : {} Incoming: {} Replication: {}", args);
         11:                 return Response.status(Status.NOT_FOUND).build();
         12:             // Server çš„ è¾ƒå¤§
         13:             } else if (appInfo.getLastDirtyTimestamp() > lastDirtyTimestamp) {
         14:                 // In the case of replication, send the current instance info in the registry for the
         15:                 // replicating node to sync itself with this one.
         16:                 if (isReplication) {
         17:                     logger.debug(
         18:                             "Time to sync, since the last dirty timestamp differs -"
         19:                                     + " ReplicationInstance id : {},Registry : {} Incoming: {} Replication: {}",
         20:                             args);
         21:                     return Response.status(Status.CONFLICT).entity(appInfo).build();
         22:                 } else {
         23:                     return Response.ok().build();
         24:                 }
         25:             }
         26:         }
         27: 
         28:     }
         29:     return Response.ok().build();
         30: }   
        ```
        * ç¬¬ 7 è‡³ 11 è¡Œ ï¼šè¯·æ±‚çš„ `lastDirtyTimestamp` è¾ƒå¤§ï¼Œ**æ„å‘³ç€è¯·æ±‚æ–¹( å¯èƒ½æ˜¯ Eureka-Client ï¼Œä¹Ÿå¯èƒ½æ˜¯ Eureka-Server é›†ç¾¤å†…çš„å…¶ä»– Server )å­˜åœ¨ InstanceInfo å’Œ Eureka-Server çš„ InstanceInfo çš„æ•°æ®ä¸ä¸€è‡´ï¼Œè¿”å› 404 å“åº”ã€‚è¯·æ±‚æ–¹æ”¶åˆ° 404 å“åº”åé‡æ–°å‘èµ·æ³¨å†Œ**ã€‚
        * ç¬¬ 16 è‡³ 21 è¡Œ ï¼š[ã€ŠEureka æºç è§£æ â€”â€” Eureka-Server é›†ç¾¤åŒæ­¥ã€‹](http://www.iocoder.cn/Eureka/server-cluster/?self) æœ‰è¯¦ç»†è§£æã€‚
        * ç¬¬ 22 è‡³ 24 è¡Œ ï¼šServer çš„ `lastDirtyTimestamp` è¾ƒå¤§ï¼Œå¹¶ä¸”è¯·æ±‚æ–¹ä¸º Eureka-Clientï¼Œç»­ç§ŸæˆåŠŸï¼Œè¿”å› 200 æˆåŠŸå“åº”ã€‚
        * ç¬¬ 29 è¡Œ ï¼š`lastDirtyTimestamp` ä¸€è‡´ï¼Œè¿”å› 200 æˆåŠŸå“åº”ã€‚
   
   * ç¬¬ 24 è‡³ 30 è¡Œ ï¼š[ã€ŠEureka æºç è§£æ â€”â€” Eureka-Server é›†ç¾¤åŒæ­¥ã€‹](http://www.iocoder.cn/Eureka/server-cluster/?self) æœ‰è¯¦ç»†è§£æã€‚

* ç¬¬ 31 è‡³ 33 è¡Œ ï¼šç»­ç§ŸæˆåŠŸï¼Œè¿”å› 200 æˆåŠŸå“åº”ã€‚

## 3.2 ç»­ç§Ÿåº”ç”¨å®ä¾‹ä¿¡æ¯

è°ƒç”¨ `AbstractInstanceRegistry#renew(...)` æ–¹æ³•ï¼Œç»­ç§Ÿåº”ç”¨å®ä¾‹ä¿¡æ¯ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
  1: public boolean renew(String appName, String id, boolean isReplication) {
  2:     // å¢åŠ  ç»­ç§Ÿæ¬¡æ•° åˆ° ç›‘æ§
  3:     RENEW.increment(isReplication);
  4:     // è·å¾— ç§Ÿçº¦
  5:     Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
  6:     Lease<InstanceInfo> leaseToRenew = null;
  7:     if (gMap != null) {
  8:         leaseToRenew = gMap.get(id);
  9:     }
 10:     // ç§Ÿçº¦ä¸å­˜åœ¨
 11:     if (leaseToRenew == null) {
 12:         RENEW_NOT_FOUND.increment(isReplication);
 13:         logger.warn("DS: Registry: lease doesn't exist, registering resource: {} - {}", appName, id);
 14:         return false;
 15:     } else {
 16:         InstanceInfo instanceInfo = leaseToRenew.getHolder();
 17:         if (instanceInfo != null) {
 18:             // touchASGCache(instanceInfo.getASGName());
 19:             // override status
 20:             InstanceStatus overriddenInstanceStatus = this.getOverriddenInstanceStatus(
 21:                     instanceInfo, leaseToRenew, isReplication);
 22:             if (overriddenInstanceStatus == InstanceStatus.UNKNOWN) {
 23:                 logger.info("Instance status UNKNOWN possibly due to deleted override for instance {}"
 24:                         + "; re-register required", instanceInfo.getId());
 25:                 RENEW_NOT_FOUND.increment(isReplication);
 26:                 return false;
 27:             }
 28:             if (!instanceInfo.getStatus().equals(overriddenInstanceStatus)) {
 29:                 Object[] args = {
 30:                         instanceInfo.getStatus().name(),
 31:                         instanceInfo.getOverriddenStatus().name(),
 32:                         instanceInfo.getId()
 33:                 };
 34:                 logger.info(
 35:                         "The instance status {} is different from overridden instance status {} for instance {}. "
 36:                                 + "Hence setting the status to overridden status", args);
 37:                 instanceInfo.setStatusWithoutDirty(overriddenInstanceStatus);
 38:             }
 39:         }
 40:         // æ–°å¢ ç»­ç§Ÿæ¯åˆ†é’Ÿæ¬¡æ•°
 41:         renewsLastMin.increment();
 42:         // è®¾ç½® ç§Ÿçº¦æœ€åæ›´æ–°æ—¶é—´ï¼ˆç»­ç§Ÿï¼‰
 43:         leaseToRenew.renew();
 44:         return true;
 45:     }
 46: }
```

* ç¬¬ 2 è‡³ 3 è¡Œ ï¼šå¢åŠ ç»­ç§Ÿæ¬¡æ•°åˆ°ç›‘æ§ã€‚é…åˆ [Netflix Servo](https://github.com/Netflix/servo) å®ç°ç›‘æ§ä¿¡æ¯é‡‡é›†ã€‚
* ç¬¬ 4 è‡³ 9 è¡Œ ï¼šè·å¾—ç§Ÿçº¦( Lease )ã€‚
* ç¬¬ 10 è‡³ 14 è¡Œ ï¼šç§Ÿçº¦ä¸å­˜åœ¨ï¼Œè¿”å›ç»­ç§Ÿå¤±è´¥( `false` )ã€‚
* ç¬¬ 19 è‡³ 21 è¡Œ ï¼šè·å¾—åº”ç”¨å®ä¾‹çš„**æœ€ç»ˆçŠ¶æ€**ã€‚åœ¨[ã€Šåº”ç”¨å®ä¾‹æ³¨å†Œå‘ç° ï¼ˆå…«ï¼‰ä¹‹è¦†ç›–çŠ¶æ€ã€‹](http://www.iocoder.cn/Eureka/instance-registry-override-status/?self)è¯¦ç»†è§£æã€‚
* ç¬¬ 22 è‡³ 27 è¡Œ ï¼šåº”ç”¨å®ä¾‹çš„**æœ€ç»ˆçŠ¶æ€**ä¸º `UNKNOWN`ï¼Œæ— æ³•ç»­çº¦ï¼Œè¿”å› `false` ã€‚åœ¨[ã€Šåº”ç”¨å®ä¾‹æ³¨å†Œå‘ç° ï¼ˆå…«ï¼‰ä¹‹è¦†ç›–çŠ¶æ€ã€‹](http://www.iocoder.cn/Eureka/instance-registry-override-status/?self)è¯¦ç»†è§£æã€‚
* ç¬¬ 28 è‡³ 37 è¡Œ ï¼šåº”ç”¨å®ä¾‹çš„çŠ¶æ€ä¸**æœ€ç»ˆçŠ¶æ€**ä¸ç›¸ç­‰ï¼Œä½¿ç”¨**æœ€ç»ˆçŠ¶æ€**è¦†ç›–åº”ç”¨å®ä¾‹çš„çŠ¶æ€ã€‚åœ¨[ã€Šåº”ç”¨å®ä¾‹æ³¨å†Œå‘ç° ï¼ˆå…«ï¼‰ä¹‹è¦†ç›–çŠ¶æ€ã€‹](http://www.iocoder.cn/Eureka/instance-registry-override-status/?self)è¯¦ç»†è§£æã€‚
* ç¬¬ 40 è‡³ 41 è¡Œ ï¼šæ–°å¢ç»­ç§Ÿæ¯åˆ†é’Ÿæ¬¡æ•°( `renewsLastMin` )ã€‚`com.netflix.eureka.util.MeasuredRate`ï¼Œé€Ÿåº¦æµ‹é‡ç±»ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    // AbstractInstanceRegistry.java
    /**
     * ç»­ç§Ÿæ¯åˆ†é’Ÿæ¬¡æ•°
     */
    private final MeasuredRate renewsLastMin;
    
    // MeasuredRate.java
    public class MeasuredRate {
        /**
         * ä¸Šä¸€ä¸ªé—´éš”æ¬¡æ•°
         */
        private final AtomicLong lastBucket = new AtomicLong(0);
        /**
         * å½“å‰é—´éš”æ¬¡æ•°
         */
        private final AtomicLong currentBucket = new AtomicLong(0);
        /**
         * é—´éš”
         */
        private final long sampleInterval;
        /**
         * å®šæ—¶å™¨
         */
        private final Timer timer;
    
        private volatile boolean isActive;
        
        public MeasuredRate(long sampleInterval) {
            this.sampleInterval = sampleInterval;
            this.timer = new Timer("Eureka-MeasureRateTimer", true);
            this.isActive = false;
        }
    
        public synchronized void start() {
            if (!isActive) {
                timer.schedule(new TimerTask() {
    
                    @Override
                    public void run() {
                        try {
                            // Zero out the current bucket.
                            lastBucket.set(currentBucket.getAndSet(0));
                        } catch (Throwable e) {
                            logger.error("Cannot reset the Measured Rate", e);
                        }
                    }
                }, sampleInterval, sampleInterval);
    
                isActive = true;
            }
        }
    
        public synchronized void stop() {
            if (isActive) {
                timer.cancel();
                isActive = false;
            }
        }
    
        /**
         * Returns the count in the last sample interval.
         */
        public long getCount() {
            return lastBucket.get();
        }
    
        /**
         * Increments the count in the current sample interval.
         */
        public void increment() {
            currentBucket.incrementAndGet();
        }
    }  
    ```
    * `timer` ï¼Œå®šæ—¶å™¨ï¼Œè´Ÿè´£æ¯ä¸ª `sampleInterval` é—´éš”é‡ç½®**å½“å‰æ¬¡æ•°**( `currentBucket` )ï¼Œå¹¶å°†**åŸå½“å‰æ¬¡æ•°**è®¾ç½®åˆ°**ä¸Šä¸€ä¸ªæ¬¡æ•°**( `lastBucket` )ã€‚
    * `#increment()` æ–¹æ³•ï¼Œè¿”å›**å½“å‰æ¬¡æ•°**( `currentBucket` )ã€‚
    * `#getCount()` æ–¹æ³•ï¼Œè¿”å›**ä¸Šä¸€ä¸ªæ¬¡æ•°**( `lastBucket` )ã€‚
    * `renewsLastMin` æœ‰å¦‚ä¸‹ç”¨é€”ï¼š
        * é…åˆ [Netflix Servo](https://github.com/Netflix/servo) å®ç°ç›‘æ§ä¿¡æ¯é‡‡é›†**ç»­ç§Ÿæ¯åˆ†é’Ÿæ¬¡æ•°**ã€‚
        * Eureka-Server è¿ç»´ç•Œé¢çš„æ˜¾ç¤º**ç»­ç§Ÿæ¯åˆ†é’Ÿæ¬¡æ•°**ã€‚
        * è‡ªæˆ‘ä¿æŠ¤æœºåˆ¶ï¼Œåœ¨ [ã€ŠEureka æºç è§£æ â€”â€” åº”ç”¨å®ä¾‹æ³¨å†Œå‘ç° ï¼ˆå››ï¼‰ä¹‹è‡ªæˆ‘ä¿æŠ¤æœºåˆ¶ã€‹](http://www.iocoder.cn/Eureka/instance-registry-self-preservation/?self) è¯¦ç»†è§£æã€‚

* ç¬¬ 42 è‡³ 43 è¡Œ ï¼šè°ƒç”¨ `Lease#renew()` æ–¹æ³•ï¼Œè®¾ç½®ç§Ÿçº¦æœ€åæ›´æ–°æ—¶é—´( ç»­ç§Ÿ )ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    public void renew() {
        lastUpdateTimestamp = System.currentTimeMillis() + duration;
    }
    ```
    * x

* ç¬¬ 44 è¡Œ ï¼šè¿”å›ç»­ç§ŸæˆåŠŸ( `true` )ã€‚
* **æ•´ä¸ªè¿‡ç¨‹ä¿®æ”¹çš„ç§Ÿçº¦çš„è¿‡æœŸæ—¶é—´ï¼Œå³ä½¿å¹¶å‘è¯·æ±‚ï¼Œä¹Ÿä¸ä¼šå¯¹æ•°æ®çš„ä¸€è‡´æ€§äº§ç”Ÿä¸ä¸€è‡´çš„å½±å“ï¼Œå› æ­¤åƒæ³¨å†Œæ“ä½œä¸€æ ·åŠ é”**ã€‚

# 666. å½©è›‹

![çŸ¥è¯†æ˜Ÿçƒ](http://www.iocoder.cn/images/Architecture/2017_12_29/01.png)

æ•ˆç‡æ¯”æƒ³è±¡çš„ä½ä¸€äº›ï¼ŒåŠ æ²¹ç»§ç»­æ›´æ–°ä¸‹ä¸€ç¯‡ã€‚

èƒ–å‹ï¼Œåˆ†äº«æˆ‘çš„å…¬ä¼—å·( **èŠ‹é“æºç ** ) ç»™ä½ çš„èƒ–å‹å¯å¥½ï¼Ÿ


