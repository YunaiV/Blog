title: Eureka æºç è§£æ â€”â€” åº”ç”¨å®ä¾‹æ³¨å†Œå‘ç°ï¼ˆå…­ï¼‰ä¹‹å…¨é‡è·å–
date: 2018-06-29
tags:
categories: Eureka
permalink: Eureka/instance-registry-fetch-all

---

æ‘˜è¦: åŸåˆ›å‡ºå¤„ http://www.iocoder.cn/Eureka/instance-registry-fetch-all/ ã€ŒèŠ‹é“æºç ã€æ¬¢è¿è½¬è½½ï¼Œä¿ç•™æ‘˜è¦ï¼Œè°¢è°¢ï¼

**æœ¬æ–‡ä¸»è¦åŸºäº Eureka 1.8.X ç‰ˆæœ¬** 

- [1. æ¦‚è¿°](http://www.iocoder.cn/Eureka/instance-registry-fetch-all/)
- [2. Eureka-Client å‘èµ·å…¨é‡è·å–](http://www.iocoder.cn/Eureka/instance-registry-fetch-all/)
  - [2.1 åˆå§‹åŒ–å…¨é‡è·å–](http://www.iocoder.cn/Eureka/instance-registry-fetch-all/)
  - [2.2 å®šæ—¶è·å–](http://www.iocoder.cn/Eureka/instance-registry-fetch-all/)
  - [2.3 åˆ·æ–°æ³¨å†Œä¿¡æ¯ç¼“å­˜](http://www.iocoder.cn/Eureka/instance-registry-fetch-all/)
  - [2.4 å‘èµ·è·å–æ³¨å†Œä¿¡æ¯](http://www.iocoder.cn/Eureka/instance-registry-fetch-all/)
- [3. Eureka-Server æ¥æ”¶å…¨é‡è·å–](http://www.iocoder.cn/Eureka/instance-registry-fetch-all/)
  - [3.1 æ¥æ”¶å…¨é‡è·å–è¯·æ±‚](http://www.iocoder.cn/Eureka/instance-registry-fetch-all/)
  - [3.2 å“åº”ç¼“å­˜ ResponseCache](http://www.iocoder.cn/Eureka/instance-registry-fetch-all/)
  - [3.3 ç¼“å­˜è¯»å–](http://www.iocoder.cn/Eureka/instance-registry-fetch-all/)
  - [3.4 ä¸»åŠ¨è¿‡æœŸè¯»å†™ç¼“å­˜](http://www.iocoder.cn/Eureka/instance-registry-fetch-all/)
  - [3.5 è¢«åŠ¨è¿‡æœŸè¯»å†™ç¼“å­˜](http://www.iocoder.cn/Eureka/instance-registry-fetch-all/)
  - [3.6 å®šæ—¶åˆ·æ–°åªè¯»ç¼“å­˜](http://www.iocoder.cn/Eureka/instance-registry-fetch-all/)
- [666. å½©è›‹](http://www.iocoder.cn/Eureka/instance-registry-fetch-all/)

---

![](http://www.iocoder.cn/images/common/wechat_mp_2018_05_18.jpg)

> ğŸ™‚ğŸ™‚ğŸ™‚å…³æ³¨**å¾®ä¿¡å…¬ä¼—å·ï¼šã€èŠ‹é“æºç ã€‘**æœ‰ç¦åˆ©ï¼š  
> 1. RocketMQ / MyCAT / Sharding-JDBC **æ‰€æœ‰**æºç åˆ†ææ–‡ç« åˆ—è¡¨  
> 2. RocketMQ / MyCAT / Sharding-JDBC **ä¸­æ–‡æ³¨é‡Šæºç  GitHub åœ°å€**  
> 3. æ‚¨å¯¹äºæºç çš„ç–‘é—®æ¯æ¡ç•™è¨€**éƒ½**å°†å¾—åˆ°**è®¤çœŸ**å›å¤ã€‚**ç”šè‡³ä¸çŸ¥é“å¦‚ä½•è¯»æºç ä¹Ÿå¯ä»¥è¯·æ•™å™¢**ã€‚  
> 4. **æ–°çš„**æºç è§£ææ–‡ç« **å®æ—¶**æ”¶åˆ°é€šçŸ¥ã€‚**æ¯å‘¨æ›´æ–°ä¸€ç¯‡å·¦å³**ã€‚  
> 5. **è®¤çœŸçš„**æºç äº¤æµå¾®ä¿¡ç¾¤ã€‚

---

# 1. æ¦‚è¿°

æœ¬æ–‡ä¸»è¦åˆ†äº« **Eureka-Client å‘ Eureka-Server è·å–å…¨é‡æ³¨å†Œä¿¡æ¯çš„è¿‡ç¨‹**ã€‚

> FROM [ã€Šæ·±åº¦å‰–ææœåŠ¡å‘ç°ç»„ä»¶Netflix Eurekaã€‹](ã€Šhttp://techshow.ctrip.com/archives/1699.htmlã€‹)    
> ![](http://www.iocoder.cn/images/Eureka/2018_06_29/01.png)

Eureka-Client è·å–æ³¨å†Œä¿¡æ¯ï¼Œåˆ†æˆ**å…¨é‡è·å–**å’Œ**å¢é‡è·å–**ã€‚é»˜è®¤é…ç½®ä¸‹ï¼ŒEureka-Client å¯åŠ¨æ—¶ï¼Œé¦–å…ˆæ‰§è¡Œä¸€æ¬¡**å…¨é‡**è·å–è¿›è¡Œ**æœ¬åœ°ç¼“å­˜**æ³¨å†Œä¿¡æ¯ï¼Œè€Œåæ¯ **30** ç§’**å¢é‡**è·å–åˆ·æ–°**æœ¬åœ°ç¼“å­˜**( éâ€œ**æ­£å¸¸**â€æƒ…å†µä¸‹ä¼šæ˜¯å…¨é‡è·å– )ã€‚

æœ¬æ–‡é‡ç‚¹åœ¨äº**å…¨é‡è·å–**ã€‚

**æ¨è Spring Cloud ä¹¦ç±**ï¼š

* è¯·æ”¯æŒæ­£ç‰ˆã€‚ä¸‹è½½ç›—ç‰ˆï¼Œ**ç­‰äºä¸»åŠ¨ç¼–å†™ä½çº§ BUG** ã€‚
* ç¨‹åºçŒ¿DD â€”â€” [ã€ŠSpring Cloudå¾®æœåŠ¡å®æˆ˜ã€‹](https://union-click.jd.com/jdc?d=505Twi)
* å‘¨ç«‹ â€”â€” [ã€ŠSpring Cloudä¸Dockerå¾®æœåŠ¡æ¶æ„å®æˆ˜ã€‹](https://union-click.jd.com/jdc?d=k3sAaK)
* ä¸¤ä¹¦é½ä¹°ï¼Œäº¬ä¸œåŒ…é‚®ã€‚



# 2. Eureka-Client å‘èµ·å…¨é‡è·å–

æœ¬å°èŠ‚è°ƒç”¨å…³ç³»å¦‚ä¸‹ï¼š

![](http://www.iocoder.cn/images/Eureka/2018_06_29/03.png)

## 2.1 åˆå§‹åŒ–å…¨é‡è·å–

Eureka-Client å¯åŠ¨æ—¶ï¼Œé¦–å…ˆæ‰§è¡Œä¸€æ¬¡**å…¨é‡**è·å–è¿›è¡Œ**æœ¬åœ°ç¼“å­˜**æ³¨å†Œä¿¡æ¯ï¼Œé¦–å…ˆä»£ç å¦‚ä¸‹ï¼š

```Java
// DiscoveryClient.java
/**
* Applications åœ¨æœ¬åœ°çš„ç¼“å­˜
*/
private final AtomicReference<Applications> localRegionApps = new AtomicReference<Applications>();

DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,
                    Provider<BackupRegistry> backupRegistryProvider) {
                    
     // ... çœç•¥æ— å…³ä»£ç 
     
    // ã€3.2.5ã€‘åˆå§‹åŒ–åº”ç”¨é›†åˆåœ¨æœ¬åœ°çš„ç¼“å­˜
    localRegionApps.set(new Applications());
     
    // ... çœç•¥æ— å…³ä»£ç      
     
    // ã€3.2.12ã€‘ä» Eureka-Server æ‹‰å–æ³¨å†Œä¿¡æ¯
    if (clientConfig.shouldFetchRegistry() && !fetchRegistry(false)) {
        fetchRegistryFromBackup();
    }
     
     // ... çœç•¥æ— å…³ä»£ç        
}
```

* `com.netflix.discovery.shared.Applications`ï¼Œæ³¨å†Œçš„åº”ç”¨é›†åˆã€‚è¾ƒä¸ºå®¹æ˜“ç†è§£ï¼Œç‚¹å‡» [é“¾æ¥](https://github.com/YunaiV/eureka/blob/512697015ef081233c5cb7c472250bca6b779ab4/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java) é“¾æ¥æŸ¥çœ‹å¸¦ä¸­æ–‡æ³¨é‡Šçš„ç±»ï¼Œè¿™é‡Œå°±ä¸å•°å—¦äº†ã€‚Applications ä¸ InstanceInfo ç±»å…³ç³»å¦‚ä¸‹ï¼š

    ![](http://www.iocoder.cn/images/Eureka/2018_06_29/02.png)

* é…ç½® `eureka.shouldFetchRegistry = true`ï¼Œå¼€å¯ä» Eureka-Server è·å–æ³¨å†Œä¿¡æ¯ã€‚é»˜è®¤å€¼ï¼š`true` ã€‚
* è°ƒç”¨ `#fetchRegistry(false)` æ–¹æ³•ï¼Œä» Eureka-Server **å…¨é‡**è·å–æ³¨å†Œä¿¡æ¯ï¼Œåœ¨ [ã€Œ2.4 å‘èµ·è·å–æ³¨å†Œä¿¡æ¯ã€](#) è¯¦ç»†è§£æã€‚

## 2.2 å®šæ—¶è·å–

Eureka-Client åœ¨[åˆå§‹åŒ–](http://www.iocoder.cn/Eureka/eureka-client-init-third/?self)è¿‡ç¨‹ä¸­ï¼Œåˆ›å»º**è·å–æ³¨å†Œä¿¡æ¯**çº¿ç¨‹ï¼Œ**å›ºå®šé—´éš”**å‘ Eureka-Server å‘èµ·**è·å–æ³¨å†Œä¿¡æ¯**( fetch )ï¼Œ**åˆ·æ–°**æœ¬åœ°æ³¨å†Œä¿¡æ¯**ç¼“å­˜**ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
// DiscoveryClient.java
DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,
               Provider<BackupRegistry> backupRegistryProvider) {
    // ... çœç•¥æ— å…³ä»£ç 
               
    // ã€3.2.9ã€‘åˆå§‹åŒ–çº¿ç¨‹æ± 
    // default size of 2 - 1 each for heartbeat and cacheRefresh
    scheduler = Executors.newScheduledThreadPool(2,
         new ThreadFactoryBuilder()
                 .setNameFormat("DiscoveryClient-%d")
                 .setDaemon(true)
                 .build());
    
    cacheRefreshExecutor = new ThreadPoolExecutor(
         1, clientConfig.getCacheRefreshExecutorThreadPoolSize(), 0, TimeUnit.SECONDS,
         new SynchronousQueue<Runnable>(),
         new ThreadFactoryBuilder()
                 .setNameFormat("DiscoveryClient-CacheRefreshExecutor-%d")
                 .setDaemon(true)
                 .build()
     );  // use direct handoff
    
    // ... çœç•¥æ— å…³ä»£ç 
    
    // ã€3.2.14ã€‘åˆå§‹åŒ–å®šæ—¶ä»»åŠ¡
    initScheduledTasks();
    
    // ... çœç•¥æ— å…³ä»£ç 
}

private void initScheduledTasks() {
    // å‘ Eureka-Server å¿ƒè·³ï¼ˆç»­ç§Ÿï¼‰æ‰§è¡Œå™¨
    if (clientConfig.shouldFetchRegistry()) {
       // registry cache refresh timer
       int registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();
       int expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();
       scheduler.schedule(
               new TimedSupervisorTask(
                       "cacheRefresh",
                       scheduler,
                       cacheRefreshExecutor,
                       registryFetchIntervalSeconds,
                       TimeUnit.SECONDS,
                       expBackOffBound,
                       new CacheRefreshThread()
               ),
               registryFetchIntervalSeconds, TimeUnit.SECONDS);
     }
     // ... çœç•¥æ— å…³ä»£ç 
}
```

* åˆå§‹åŒ–å®šæ—¶ä»»åŠ¡ä»£ç ï¼Œå’Œ**ç»­ç§Ÿ**çš„å®šæ—¶ä»»åŠ¡ä»£ç ç±»ä¼¼ï¼Œåœ¨ [ã€ŠEureka æºç è§£æ â€”â€” åº”ç”¨å®ä¾‹æ³¨å†Œå‘ç°ï¼ˆäºŒï¼‰ä¹‹ç»­ç§Ÿ
ã€‹](http://www.iocoder.cn/Eureka/instance-registry-renew/?self) æœ‰è¯¦ç»†è§£æï¼Œè¿™é‡Œä¸é‡å¤åˆ†äº«ã€‚
* `com.netflix.discovery.DiscoveryClient.CacheRefreshThread`ï¼Œæ³¨å†Œä¿¡æ¯ç¼“å­˜åˆ·æ–°ä»»åŠ¡ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    class CacheRefreshThread implements Runnable {
        public void run() {
            refreshRegistry();
        }
    }
    ```
    * è°ƒç”¨ `#refreshRegistry(false)` æ–¹æ³•ï¼Œåˆ·æ–°æ³¨å†Œä¿¡æ¯ç¼“å­˜ï¼Œåœ¨ [ã€Œ2.3 åˆ·æ–°æ³¨å†Œä¿¡æ¯ç¼“å­˜ã€](#) è¯¦ç»†è§£æã€‚

## 2.3 åˆ·æ–°æ³¨å†Œä¿¡æ¯ç¼“å­˜

è°ƒç”¨ `#refreshRegistry(false)` æ–¹æ³•ï¼Œåˆ·æ–°æ³¨å†Œä¿¡æ¯ç¼“å­˜ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
// DiscoveryClient.java
  1: void refreshRegistry() {
  2:     try {
  3:         // TODO èŠ‹è‰¿ï¼šTODO[0009]ï¼šRemoteRegionRegistry
  4:         boolean isFetchingRemoteRegionRegistries = isFetchingRemoteRegionRegistries();
  5: 
  6:         boolean remoteRegionsModified = false;
  7:         // This makes sure that a dynamic change to remote regions to fetch is honored.
  8:         String latestRemoteRegions = clientConfig.fetchRegistryForRemoteRegions();
  9:         if (null != latestRemoteRegions) {
 10:             String currentRemoteRegions = remoteRegionsToFetch.get();
 11:             if (!latestRemoteRegions.equals(currentRemoteRegions)) {
 12:                 // Both remoteRegionsToFetch and AzToRegionMapper.regionsToFetch need to be in sync
 13:                 synchronized (instanceRegionChecker.getAzToRegionMapper()) {
 14:                     if (remoteRegionsToFetch.compareAndSet(currentRemoteRegions, latestRemoteRegions)) {
 15:                         String[] remoteRegions = latestRemoteRegions.split(",");
 16:                         remoteRegionsRef.set(remoteRegions);
 17:                         instanceRegionChecker.getAzToRegionMapper().setRegionsToFetch(remoteRegions);
 18:                         remoteRegionsModified = true;
 19:                     } else {
 20:                         logger.info("Remote regions to fetch modified concurrently," +
 21:                                 " ignoring change from {} to {}", currentRemoteRegions, latestRemoteRegions);
 22:                     }
 23:                 }
 24:             } else {
 25:                 // Just refresh mapping to reflect any DNS/Property change
 26:                 instanceRegionChecker.getAzToRegionMapper().refreshMapping();
 27:             }
 28:         }
 29: 
 30:         boolean success = fetchRegistry(remoteRegionsModified);
 31:         if (success) {
 32:             // è®¾ç½® æ³¨å†Œä¿¡æ¯çš„åº”ç”¨å®ä¾‹æ•°
 33:             registrySize = localRegionApps.get().size();
 34:             // è®¾ç½® æœ€åè·å–æ³¨å†Œä¿¡æ¯æ—¶é—´
 35:             lastSuccessfulRegistryFetchTimestamp = System.currentTimeMillis();
 36:         }
 37: 
 38:         // æ‰“å°æ—¥å¿—
 39:         if (logger.isDebugEnabled()) {
 40:             StringBuilder allAppsHashCodes = new StringBuilder();
 41:             allAppsHashCodes.append("Local region apps hashcode: ");
 42:             allAppsHashCodes.append(localRegionApps.get().getAppsHashCode());
 43:             allAppsHashCodes.append(", is fetching remote regions? ");
 44:             allAppsHashCodes.append(isFetchingRemoteRegionRegistries);
 45:             for (Map.Entry<String, Applications> entry : remoteRegionVsApps.entrySet()) {
 46:                 allAppsHashCodes.append(", Remote region: ");
 47:                 allAppsHashCodes.append(entry.getKey());
 48:                 allAppsHashCodes.append(" , apps hashcode: ");
 49:                 allAppsHashCodes.append(entry.getValue().getAppsHashCode());
 50:             }
 51:             logger.debug("Completed cache refresh task for discovery. All Apps hash code is {} ",
 52:                     allAppsHashCodes.toString());
 53:         }
 54:     } catch (Throwable e) {
 55:         logger.error("Cannot fetch registry from server", e);
 56:     }        
 57: }
```

* ç¬¬ 3 è‡³ 28 è¡Œ ï¼šTODO[0009]ï¼šRemoteRegionRegistry
* ç¬¬ 30 è¡Œ ï¼šè°ƒç”¨ `#fetchRegistry(false)` æ–¹æ³•ï¼Œä» Eureka-Server è·å–æ³¨å†Œä¿¡æ¯ï¼Œåœ¨ [ã€Œ2.4 å‘èµ·è·å–æ³¨å†Œä¿¡æ¯ã€](#) è¯¦ç»†è§£æã€‚
* ç¬¬ 31 è‡³ 36 è¡Œ ï¼šè·å–æ³¨å†Œä¿¡æ¯æˆåŠŸï¼Œè®¾ç½®æ³¨å†Œä¿¡æ¯çš„åº”ç”¨å®ä¾‹æ•°ï¼Œæœ€åè·å–æ³¨å†Œä¿¡æ¯æ—¶é—´ã€‚å˜é‡ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    /**
    * æ³¨å†Œä¿¡æ¯çš„åº”ç”¨å®ä¾‹æ•°
    */
    private volatile int registrySize = 0;
    /**
    * æœ€åæˆåŠŸä» Eureka-Server æ‹‰å–æ³¨å†Œä¿¡æ¯æ—¶é—´æˆ³
    */
    private volatile long lastSuccessfulRegistryFetchTimestamp = -1;
    ```

* ç¬¬ 38 è‡³ 53 è¡Œ ï¼šæ‰“å°è°ƒè¯•æ—¥å¿—ã€‚
* ç¬¬ 54 è‡³ 56 è¡Œ ï¼šæ‰“å°**å¼‚å¸¸**æ—¥å¿—ã€‚

## 2.4 å‘èµ·è·å–æ³¨å†Œä¿¡æ¯

è°ƒç”¨ `#fetchRegistry(false)` æ–¹æ³•ï¼Œä» Eureka-Server è·å–æ³¨å†Œä¿¡æ¯( æ ¹æ®æ¡ä»¶åˆ¤æ–­ï¼Œå¯èƒ½æ˜¯**å…¨é‡**ï¼Œä¹Ÿå¯èƒ½æ˜¯**å¢é‡** )ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
  1: private boolean fetchRegistry(boolean forceFullRegistryFetch) {
  2:     Stopwatch tracer = FETCH_REGISTRY_TIMER.start();
  3: 
  4:     try {
  5:         // è·å– æœ¬åœ°ç¼“å­˜çš„æ³¨å†Œçš„åº”ç”¨å®ä¾‹é›†åˆ
  6:         // If the delta is disabled or if it is the first time, get all
  7:         // applications
  8:         Applications applications = getApplications();
  9: 
 10:         // å…¨é‡è·å–
 11:         if (clientConfig.shouldDisableDelta() // ç¦ç”¨å¢é‡è·å–
 12:                 || (!Strings.isNullOrEmpty(clientConfig.getRegistryRefreshSingleVipAddress()))
 13:                 || forceFullRegistryFetch
 14:                 || (applications == null) // ç©º
 15:                 || (applications.getRegisteredApplications().size() == 0) // ç©º
 16:                 || (applications.getVersion() == -1)) //Client application does not have latest library supporting delta
 17:         {
 18:             logger.info("Disable delta property : {}", clientConfig.shouldDisableDelta());
 19:             logger.info("Single vip registry refresh property : {}", clientConfig.getRegistryRefreshSingleVipAddress());
 20:             logger.info("Force full registry fetch : {}", forceFullRegistryFetch);
 21:             logger.info("Application is null : {}", (applications == null));
 22:             logger.info("Registered Applications size is zero : {}",
 23:                     (applications.getRegisteredApplications().size() == 0));
 24:             logger.info("Application version is -1: {}", (applications.getVersion() == -1));
 25:             // æ‰§è¡Œ å…¨é‡è·å–
 26:             getAndStoreFullRegistry();
 27:         } else {
 28:             // æ‰§è¡Œ å¢é‡è·å–
 29:             getAndUpdateDelta(applications);
 30:         }
 31:         // è®¾ç½® åº”ç”¨é›†åˆ hashcode
 32:         applications.setAppsHashCode(applications.getReconcileHashCode());
 33:         // æ‰“å° æœ¬åœ°ç¼“å­˜çš„æ³¨å†Œçš„åº”ç”¨å®ä¾‹æ•°é‡
 34:         logTotalInstances();
 35:     } catch (Throwable e) {
 36:         logger.error(PREFIX + appPathIdentifier + " - was unable to refresh its cache! status = " + e.getMessage(), e);
 37:         return false;
 38:     } finally {
 39:         if (tracer != null) {
 40:             tracer.stop();
 41:         }
 42:     }
 43: 
 44:     // Notify about cache refresh before updating the instance remote status
 45:     onCacheRefreshed();
 46: 
 47:     // Update remote status based on refreshed data held in the cache
 48:     updateInstanceRemoteStatus();
 49: 
 50:     // registry was fetched successfully, so return true
 51:     return true;
 52: }
```

* ç¬¬ 5 è‡³ 8 è¡Œ ï¼šè·å–æœ¬åœ°ç¼“å­˜çš„æ³¨å†Œçš„åº”ç”¨å®ä¾‹é›†åˆï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    public Applications getApplications() {
       return localRegionApps.get();
    }
    ```

* ç¬¬ 10 è‡³ 26 è¡Œ ï¼š**å…¨é‡**è·å–æ³¨å†Œä¿¡æ¯ã€‚
    * ç¬¬ 11 è¡Œ ï¼šé…ç½® `eureka.disableDelta = true` ï¼Œç¦ç”¨**å¢é‡**è·å–æ³¨å†Œä¿¡æ¯ã€‚é»˜è®¤å€¼ï¼š`false` ã€‚
    * ç¬¬ 12 è¡Œ ï¼šåªè·å¾—ä¸€ä¸ª `vipAddress` å¯¹åº”çš„åº”ç”¨å®ä¾‹ä»¬çš„æ³¨å†Œä¿¡æ¯ã€‚
    * ç¬¬ 13 è¡Œ ï¼šæ–¹æ³•å‚æ•° `forceFullRegistryFetch` å¼ºåˆ¶**å…¨é‡**è·å–æ³¨å†Œä¿¡æ¯ã€‚
    * ç¬¬ 14 è‡³ 15 è¡Œ ï¼šæœ¬åœ°ç¼“å­˜ä¸ºç©ºã€‚
    * ç¬¬ 25 è‡³ 26 è¡Œ ï¼šè°ƒç”¨ `#getAndStoreFullRegistry()` æ–¹æ³•ï¼Œ**å…¨é‡**è·å–æ³¨å†Œä¿¡æ¯ï¼Œå¹¶è®¾ç½®åˆ°æœ¬åœ°ç¼“å­˜ã€‚ä¸‹æ–‡è¯¦ç»†è§£æã€‚
* ç¬¬ 27 è‡³ 30 è¡Œ ï¼š**å¢é‡**è·å–æ³¨å†Œä¿¡æ¯ï¼Œå¹¶åˆ·æ–°æœ¬åœ°ç¼“å­˜ï¼Œåœ¨ [ã€ŠEureka æºç è§£æ â€”â€” åº”ç”¨å®ä¾‹æ³¨å†Œå‘ç° ï¼ˆä¸ƒï¼‰ä¹‹å¢é‡è·å–ã€‹](http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/) è¯¦ç»†è§£æã€‚
* ç¬¬ 31 è‡³ 32 è¡Œ ï¼šè®¡ç®—åº”ç”¨é›†åˆ `hashcode` ã€‚è¯¥å˜é‡ç”¨äºæ ¡éªŒ**å¢é‡**è·å–çš„æ³¨å†Œä¿¡æ¯å’Œ Eureka-Server **å…¨é‡**çš„æ³¨å†Œä¿¡æ¯æ˜¯å¦ä¸€è‡´( å®Œæ•´ )ï¼Œåœ¨ [ã€ŠEureka æºç è§£æ â€”â€” åº”ç”¨å®ä¾‹æ³¨å†Œå‘ç° ï¼ˆä¸ƒï¼‰ä¹‹å¢é‡è·å–ã€‹](http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/) è¯¦ç»†è§£æã€‚
* ç¬¬ 33 è‡³ 34 è¡Œ ï¼šæ‰“å°è°ƒè¯•æ—¥å¿—ï¼Œè¾“å‡ºæœ¬åœ°ç¼“å­˜çš„æ³¨å†Œçš„åº”ç”¨å®ä¾‹æ•°é‡ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    private void logTotalInstances() {
       if (logger.isDebugEnabled()) {
           int totInstances = 0;
           for (Application application : getApplications().getRegisteredApplications()) {
               totInstances += application.getInstancesAsIsFromEureka().size();
           }
           logger.debug("The total number of all instances in the client now is {}", totInstances);
       }
    }
    ```

* ç¬¬ 44 è‡³ 45 è¡Œ ï¼šè§¦å‘ CacheRefreshedEvent äº‹ä»¶ï¼Œäº‹ä»¶ç›‘å¬å™¨æ‰§è¡Œã€‚ç›®å‰ Eureka æœªæä¾›é»˜è®¤çš„è¯¥äº‹ä»¶ç›‘å¬å™¨ã€‚
    * `#onCacheRefreshed()` æ–¹æ³•ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

        ```Java
        /**
         * Eureka äº‹ä»¶ç›‘å¬å™¨
         */
        private final CopyOnWriteArraySet<EurekaEventListener> eventListeners = new CopyOnWriteArraySet<>();
        
        protected void onCacheRefreshed() {
            fireEvent(new CacheRefreshedEvent());
        }
        
        protected void fireEvent(final EurekaEvent event) {
            for (EurekaEventListener listener : eventListeners) {
                listener.onEvent(event);
            }
        }
        ```
        * x
    
    * **ç¬”è€…çš„YY** ï¼šä½ å¯ä»¥å®ç°è‡ªå®šä¹‰çš„äº‹ä»¶ç›‘å¬å™¨ç›‘å¬ CacheRefreshedEvent äº‹ä»¶ï¼Œä»¥è¾¾åˆ°**æŒä¹…åŒ–**æœ€æ–°çš„æ³¨å†Œä¿¡æ¯åˆ°å­˜å‚¨å™¨( ä¾‹å¦‚ï¼Œæœ¬åœ°æ–‡ä»¶ )ï¼Œé€šè¿‡è¿™æ ·çš„æ–¹å¼ï¼Œé…åˆå®ç° BackupRegistry æ¥å£è¯»å–å­˜å‚¨å™¨ã€‚BackupRegistry æ¥å£è°ƒç”¨å¦‚ä¸‹ï¼š

        ```Java
        // ã€3.2.12ã€‘ä» Eureka-Server æ‹‰å–æ³¨å†Œä¿¡æ¯
        if (clientConfig.shouldFetchRegistry() && !fetchRegistry(false)) {
            fetchRegistryFromBackup();
        }
        ```
* ç¬¬47 è‡³ 48 è¡Œ ï¼šæ›´æ–°**æœ¬åœ°ç¼“å­˜**çš„å½“å‰åº”ç”¨å®ä¾‹åœ¨ Eureka-Server çš„çŠ¶æ€ã€‚

    ```Java
      1: private volatile InstanceInfo.InstanceStatus lastRemoteInstanceStatus = InstanceInfo.InstanceStatus.UNKNOWN; 
      2: 
      3: private synchronized void updateInstanceRemoteStatus() {
      4:     // Determine this instance's status for this app and set to UNKNOWN if not found
      5:     InstanceInfo.InstanceStatus currentRemoteInstanceStatus = null;
      6:     if (instanceInfo.getAppName() != null) {
      7:         Application app = getApplication(instanceInfo.getAppName());
      8:         if (app != null) {
      9:             InstanceInfo remoteInstanceInfo = app.getByInstanceId(instanceInfo.getId());
     10:             if (remoteInstanceInfo != null) {
     11:                 currentRemoteInstanceStatus = remoteInstanceInfo.getStatus();
     12:             }
     13:         }
     14:     }
     15:     if (currentRemoteInstanceStatus == null) {
     16:         currentRemoteInstanceStatus = InstanceInfo.InstanceStatus.UNKNOWN;
     17:     }
     18: 
     19:     // Notify if status changed
     20:     if (lastRemoteInstanceStatus != currentRemoteInstanceStatus) {
     21:         onRemoteStatusChanged(lastRemoteInstanceStatus, currentRemoteInstanceStatus);
     22:         lastRemoteInstanceStatus = currentRemoteInstanceStatus;
     23:     }
     24: }
    ```
    * ç¬¬ 4 è‡³ 14 è¡Œ ï¼šä»æ³¨å†Œä¿¡æ¯ä¸­è·å–å½“å‰åº”ç”¨åœ¨ Eureka-Server çš„çŠ¶æ€ã€‚
    * ç¬¬ 19 è‡³ 23 è¡Œ ï¼šå¯¹æ¯”**æœ¬åœ°ç¼“å­˜**å’Œ**æœ€æ–°çš„**çš„å½“å‰åº”ç”¨å®ä¾‹åœ¨ Eureka-Server çš„çŠ¶æ€ï¼Œè‹¥ä¸åŒï¼Œæ›´æ–°**æœ¬åœ°ç¼“å­˜**( **æ³¨æ„ï¼Œåªæ›´æ–°è¯¥ç¼“å­˜å˜é‡ï¼Œä¸æ›´æ–°æœ¬åœ°å½“å‰åº”ç”¨å®ä¾‹çš„çŠ¶æ€( `instanceInfo.status` )** )ï¼Œè§¦å‘ StatusChangeEvent äº‹ä»¶ï¼Œäº‹ä»¶ç›‘å¬å™¨æ‰§è¡Œã€‚ç›®å‰ Eureka æœªæä¾›é»˜è®¤çš„è¯¥äº‹ä»¶ç›‘å¬å™¨ã€‚`#onRemoteStatusChanged(...)` å®ç°ä»£ç å¦‚ä¸‹ï¼š
    
        ```Java
        protected void onRemoteStatusChanged(InstanceInfo.InstanceStatus oldStatus, InstanceInfo.InstanceStatus newStatus) {
           fireEvent(new StatusChangeEvent(oldStatus, newStatus));
        }
        ```
        * Eureka-Client æœ¬åœ°åº”ç”¨å®ä¾‹ä¸ Eureka-Server çš„è¯¥åº”ç”¨å®ä¾‹çŠ¶æ€ä¸åŒçš„åŸå› ï¼Œå› ä¸ºåº”ç”¨å®ä¾‹çš„è¦†ç›–çŠ¶æ€ï¼Œåœ¨ [ã€ŠEureka æºç è§£æ â€”â€” åº”ç”¨å®ä¾‹æ³¨å†Œå‘ç° ï¼ˆå…«ï¼‰ä¹‹è¦†ç›–çŠ¶æ€ã€‹](http://www.iocoder.cn/Eureka/instance-registry-override-status/?self) æœ‰è¯¦ç»†è§£æã€‚

### 2.4.1 å…¨é‡è·å–æ³¨å†Œä¿¡æ¯ï¼Œå¹¶è®¾ç½®åˆ°æœ¬åœ°ç¼“å­˜

è°ƒç”¨ `#getAndStoreFullRegistry()` æ–¹æ³•ï¼Œ**å…¨é‡**è·å–æ³¨å†Œä¿¡æ¯ï¼Œå¹¶è®¾ç½®åˆ°æœ¬åœ°ç¼“å­˜ã€‚ä¸‹å®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
  1: private void getAndStoreFullRegistry() throws Throwable {
  2:     long currentUpdateGeneration = fetchRegistryGeneration.get();
  3: 
  4:     logger.info("Getting all instance registry info from the eureka server");
  5: 
  6:     // å…¨é‡è·å–æ³¨å†Œä¿¡æ¯
  7:     Applications apps = null;
  8:     EurekaHttpResponse<Applications> httpResponse = clientConfig.getRegistryRefreshSingleVipAddress() == null
  9:             ? eurekaTransport.queryClient.getApplications(remoteRegionsRef.get())
 10:             : eurekaTransport.queryClient.getVip(clientConfig.getRegistryRefreshSingleVipAddress(), remoteRegionsRef.get());
 11:     if (httpResponse.getStatusCode() == Status.OK.getStatusCode()) {
 12:         apps = httpResponse.getEntity();
 13:     }
 14:     logger.info("The response status is {}", httpResponse.getStatusCode());
 15: 
 16:     // è®¾ç½®åˆ°æœ¬åœ°ç¼“å­˜
 17:     if (apps == null) {
 18:         logger.error("The application is null for some reason. Not storing this information");
 19:     } else if (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + 1)) {
 20:         localRegionApps.set(this.filterAndShuffle(apps));
 21:         logger.debug("Got full registry with apps hashcode {}", apps.getAppsHashCode());
 22:     } else {
 23:         logger.warn("Not updating applications as another thread is updating it already");
 24:     }
 25: }
```

* ç¬¬ 6 è‡³ 14 è¡Œ ï¼š**å…¨é‡**è·å–æ³¨å†Œä¿¡æ¯ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    // AbstractJerseyEurekaHttpClient.java
    @Override
    public EurekaHttpResponse<Applications> getApplications(String... regions) {
       return getApplicationsInternal("apps/", regions);
    }
    
    private EurekaHttpResponse<Applications> getApplicationsInternal(String urlPath, String[] regions) {
       ClientResponse response = null;
       String regionsParamValue = null;
       try {
           WebResource webResource = jerseyClient.resource(serviceUrl).path(urlPath);
           if (regions != null && regions.length > 0) {
               regionsParamValue = StringUtil.join(regions);
               webResource = webResource.queryParam("regions", regionsParamValue);
           }
           Builder requestBuilder = webResource.getRequestBuilder();
           addExtraHeaders(requestBuilder);
           response = requestBuilder.accept(MediaType.APPLICATION_JSON_TYPE).get(ClientResponse.class); // JSON
    
           Applications applications = null;
           if (response.getStatus() == Status.OK.getStatusCode() && response.hasEntity()) {
               applications = response.getEntity(Applications.class);
           }
           return anEurekaHttpResponse(response.getStatus(), Applications.class)
                   .headers(headersOf(response))
                   .entity(applications)
                   .build();
       } finally {
           if (logger.isDebugEnabled()) {
               logger.debug("Jersey HTTP GET {}/{}?{}; statusCode={}",
                       serviceUrl, urlPath,
                       regionsParamValue == null ? "" : "regions=" + regionsParamValue,
                       response == null ? "N/A" : response.getStatus()
               );
           }
           if (response != null) {
               response.close();
           }
       }
    }
    ```
    * è°ƒç”¨ `AbstractJerseyEurekaHttpClient#getApplications(...)` æ–¹æ³•ï¼ŒGET è¯·æ±‚ Eureka-Server çš„ `apps/` æ¥å£ï¼Œå‚æ•°ä¸º `regions` ï¼Œè¿”å›æ ¼å¼ä¸º JSON ï¼Œå®ç°**å…¨é‡è·å–æ³¨å†Œä¿¡æ¯**ã€‚

* ç¬¬ 16 è‡³ 24 è¡Œ ï¼šè®¾ç½®åˆ°æœ¬åœ°æ³¨å†Œä¿¡æ¯**ç¼“å­˜**ã€‚
    * ç¬¬ 19 è¡Œ ï¼šTODO[0025] ï¼šå¹¶å‘æ›´æ–°çš„æƒ…å†µï¼Ÿï¼Ÿï¼Ÿ
    * ç¬¬ 20 è¡Œ ï¼šè°ƒç”¨ `#filterAndShuffle(...)` æ–¹æ³•ï¼Œæ ¹æ®é…ç½® `eureka.shouldFilterOnlyUpInstances = true` ( é»˜è®¤å€¼ ï¼š`true` ) è¿‡æ»¤åªä¿ç•™çŠ¶æ€ä¸ºå¼€å¯( UP )çš„åº”ç”¨å®ä¾‹ï¼Œå¹¶**éšæœºæ‰“ä¹±**åº”ç”¨å®ä¾‹é¡ºåºã€‚æ‰“ä¹±åï¼Œå®ç°è°ƒç”¨åº”ç”¨æœåŠ¡çš„éšæœºæ€§ã€‚ä»£ç æ¯”è¾ƒæ˜“æ‡‚ï¼Œç‚¹å‡»[é“¾æ¥](https://github.com/YunaiV/eureka/blob/512697015ef081233c5cb7c472250bca6b779ab4/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java#L1603)æŸ¥çœ‹æ–¹æ³•å®ç°ã€‚

# 3. Eureka-Server æ¥æ”¶å…¨é‡è·å–

## 3.1 æ¥æ”¶å…¨é‡è·å–è¯·æ±‚

`com.netflix.eureka.resources.ApplicationsResource`ï¼Œå¤„ç†**æ‰€æœ‰**åº”ç”¨çš„è¯·æ±‚æ“ä½œçš„ Resource ( Controller )ã€‚

æ¥æ”¶å…¨é‡è·å–è¯·æ±‚ï¼Œæ˜ å°„ `ApplicationsResource#getContainers()` æ–¹æ³•ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
  1: @GET
  2: public Response getContainers(@PathParam("version") String version,
  3:                               @HeaderParam(HEADER_ACCEPT) String acceptHeader,
  4:                               @HeaderParam(HEADER_ACCEPT_ENCODING) String acceptEncoding,
  5:                               @HeaderParam(EurekaAccept.HTTP_X_EUREKA_ACCEPT) String eurekaAccept,
  6:                               @Context UriInfo uriInfo,
  7:                               @Nullable @QueryParam("regions") String regionsStr) {
  8:     // TODO[0009]ï¼šRemoteRegionRegistry
  9:     boolean isRemoteRegionRequested = null != regionsStr && !regionsStr.isEmpty();
 10:     String[] regions = null;
 11:     if (!isRemoteRegionRequested) {
 12:         EurekaMonitors.GET_ALL.increment();
 13:     } else {
 14:         regions = regionsStr.toLowerCase().split(",");
 15:         Arrays.sort(regions); // So we don't have different caches for same regions queried in different order.
 16:         EurekaMonitors.GET_ALL_WITH_REMOTE_REGIONS.increment();
 17:     }
 18: 
 19:     // åˆ¤æ–­æ˜¯å¦å¯ä»¥è®¿é—®
 20:     // Check if the server allows the access to the registry. The server can
 21:     // restrict access if it is not
 22:     // ready to serve traffic depending on various reasons.
 23:     if (!registry.shouldAllowAccess(isRemoteRegionRequested)) {
 24:         return Response.status(Status.FORBIDDEN).build();
 25:     }
 26: 
 27:     // API ç‰ˆæœ¬
 28:     CurrentRequestVersion.set(Version.toEnum(version));
 29: 
 30:     // è¿”å›æ•°æ®æ ¼å¼
 31:     KeyType keyType = Key.KeyType.JSON;
 32:     String returnMediaType = MediaType.APPLICATION_JSON;
 33:     if (acceptHeader == null || !acceptHeader.contains(HEADER_JSON_VALUE)) {
 34:         keyType = Key.KeyType.XML;
 35:         returnMediaType = MediaType.APPLICATION_XML;
 36:     }
 37: 
 38:     // å“åº”ç¼“å­˜é”®( KEY )
 39:     Key cacheKey = new Key(Key.EntityType.Application,
 40:             ResponseCacheImpl.ALL_APPS,
 41:             keyType, CurrentRequestVersion.get(), EurekaAccept.fromString(eurekaAccept), regions
 42:     );
 43: 
 44:     //
 45:     Response response;
 46:     if (acceptEncoding != null && acceptEncoding.contains(HEADER_GZIP_VALUE)) {
 47:         response = Response.ok(responseCache.getGZIP(cacheKey))
 48:                 .header(HEADER_CONTENT_ENCODING, HEADER_GZIP_VALUE)
 49:                 .header(HEADER_CONTENT_TYPE, returnMediaType)
 50:                 .build();
 51:     } else {
 52:         response = Response.ok(responseCache.get(cacheKey))
 53:                 .build();
 54:     }
 55:     return response;
 56: }
```
* ç¬¬ 8 è‡³ 17 è¡Œ ï¼šTODO[0009]ï¼šRemoteRegionRegistry
* ç¬¬ 19 è‡³ 25 è¡Œ ï¼šEureka-Server å¯åŠ¨å®Œæˆï¼Œä½†æ˜¯æœªå¤„äºå°±ç»ª( Ready )çŠ¶æ€ï¼Œä¸æ¥å—è¯·æ±‚å…¨é‡åº”ç”¨æ³¨å†Œä¿¡æ¯çš„è¯·æ±‚ï¼Œä¾‹å¦‚ï¼ŒEureka-Server å¯åŠ¨æ—¶ï¼Œæœªèƒ½ä»å…¶ä»– Eureka-Server é›†ç¾¤çš„èŠ‚ç‚¹è·å–åˆ°åº”ç”¨æ³¨å†Œä¿¡æ¯ã€‚
* ç¬¬ 27 è‡³ 28 è¡Œ ï¼šè®¾ç½® API ç‰ˆæœ¬å·ã€‚**é»˜è®¤**æœ€æ–° API ç‰ˆæœ¬ä¸º V2ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    public enum Version {
        V1, V2;
    
        public static Version toEnum(String v) {
            for (Version version : Version.values()) {
                if (version.name().equalsIgnoreCase(v)) {
                    return version;
                }
            }
            //Defaults to v2
            return V2;
        }
    }
    ```

* ç¬¬ 30 è‡³ 36 è¡Œ ï¼šè®¾ç½®è¿”å›æ•°æ®æ ¼å¼ï¼Œé»˜è®¤ JSON ã€‚
* ç¬¬ 38 è‡³ 42 è¡Œ ï¼šåˆ›å»ºå“åº”ç¼“å­˜( ResponseCache ) çš„é”®( KEY )ï¼Œåœ¨ [ã€Œ3.2.1 ç¼“å­˜é”®ã€](#)è¯¦ç»†è§£æã€‚ 
* ç¬¬ 44 è‡³ 55 è¡Œ ï¼šä»å“åº”ç¼“å­˜è¯»å–**å…¨é‡**æ³¨å†Œä¿¡æ¯ï¼Œåœ¨ [ã€Œ3.3 ç¼“å­˜è¯»å–ã€](#)è¯¦ç»†è§£æã€‚ 

## 3.2 å“åº”ç¼“å­˜ ResponseCache

`com.netflix.eureka.registry.ResponseCache`ï¼Œå“åº”ç¼“å­˜**æ¥å£**ï¼Œæ¥å£ä»£ç å¦‚ä¸‹ï¼š

```Java
public interface ResponseCache {

    String get(Key key);
    
    byte[] getGZIP(Key key);
    
    void invalidate(String appName, @Nullable String vipAddress, @Nullable String secureVipAddress);

    AtomicLong getVersionDelta();
    
    AtomicLong getVersionDeltaWithRegions();

}
```

* å…¶ä¸­ï¼Œ`#getVersionDelta()` å’Œ `#getVersionDeltaWithRegions()` å·²ç»åºŸå¼ƒã€‚è¿™é‡Œä¿ç•™çš„åŸå› ä¸»è¦æ˜¯è€ƒè™‘å…¼å®¹æ€§ã€‚åˆ¤æ–­ä¾æ®æ¥è‡ªå¦‚ä¸‹ä»£ç ï¼š

    ```Java
    // Applications.java
    @Deprecated
    public void setVersion(Long version) {
       this.versionDelta = version;
    }
    
    // AbstractInstanceRegistry.java
    public Applications getApplicationDeltas() {
        // ... çœç•¥å…¶å®ƒæ— å…³ä»£ç 
        apps.setVersion(responseCache.getVersionDelta().get()); // å”¯ä¸€è°ƒç”¨åˆ° ResponseCache#getVersionDelta() æ–¹æ³•çš„åœ°æ–¹
        // ... çœç•¥å…¶å®ƒæ— å…³ä»£ç 
    }
    ```

* `#get()` ï¼šè·å¾—ç¼“å­˜ã€‚
* `#getGZIP()` ï¼šè·å¾—ç¼“å­˜ï¼Œå¹¶ GZIP ã€‚
* `#invalidate()` ï¼šè¿‡æœŸç¼“å­˜ã€‚

### 3.2.1 ç¼“å­˜é”®

`com.netflix.eureka.registry.Key`ï¼Œç¼“å­˜é”®ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
public class Key {

    public enum KeyType {
        JSON, XML
    }

    /**
     * An enum to define the entity that is stored in this cache for this key.
     */
    public enum EntityType {
        Application, VIP, SVIP
    }

    /**
     * å®ä½“å
     */
    private final String entityName;
    /**
     * TODO[0009]ï¼šRemoteRegionRegistry
     */
    private final String[] regions;
    /**
     * è¯·æ±‚å‚æ•°ç±»å‹
     */
    private final KeyType requestType;
    /**
     * è¯·æ±‚ API ç‰ˆæœ¬å·
     */
    private final Version requestVersion;
    /**
     * hashKey
     */
    private final String hashKey;
    /**
     * å®ä½“ç±»å‹
     *
     * {@link EntityType}
     */
    private final EntityType entityType;
    /**
     * {@link EurekaAccept}
     */
    private final EurekaAccept eurekaAccept;
    
    public Key(EntityType entityType, String entityName, KeyType type, Version v, EurekaAccept eurekaAccept, @Nullable String[] regions) {
        this.regions = regions;
        this.entityType = entityType;
        this.entityName = entityName;
        this.requestType = type;
        this.requestVersion = v;
        this.eurekaAccept = eurekaAccept;
        hashKey = this.entityType + this.entityName + (null != this.regions ? Arrays.toString(this.regions) : "")
                + requestType.name() + requestVersion.name() + this.eurekaAccept.name();
    }
    
    public Key(EntityType entityType, String entityName, KeyType type, Version v, EurekaAccept eurekaAccept, @Nullable String[] regions) {
        this.regions = regions;
        this.entityType = entityType;
        this.entityName = entityName;
        this.requestType = type;
        this.requestVersion = v;
        this.eurekaAccept = eurekaAccept;
        hashKey = this.entityType + this.entityName + (null != this.regions ? Arrays.toString(this.regions) : "")
                + requestType.name() + requestVersion.name() + this.eurekaAccept.name();
    }
    
    @Override
    public int hashCode() {
        String hashKey = getHashKey();
        return hashKey.hashCode();
    }

    @Override
    public boolean equals(Object other) {
        if (other instanceof Key) {
            return getHashKey().equals(((Key) other).getHashKey());
        } else {
            return false;
        }
    }
    
}
```

### 3.2.2 å“åº”ç¼“å­˜å®ç°ç±»

`com.netflix.eureka.registry.ResponseCacheImpl`ï¼Œå“åº”ç¼“å­˜å®ç°ç±»ã€‚

åœ¨ ResponseCacheImpl é‡Œï¼Œå°†ç¼“å­˜æ‹†åˆ†æˆä¸¤å±‚ ï¼š

* **åªè¯»ç¼“å­˜**( `readOnlyCacheMap` )
* **å›ºå®šè¿‡æœŸ** + **å›ºå®šå¤§å°**çš„**è¯»å†™ç¼“å­˜**( `readWriteCacheMap` )

é»˜è®¤é…ç½®ä¸‹ï¼Œ**ç¼“å­˜è¯»å–ç­–ç•¥**å¦‚ä¸‹ï¼š

![](http://www.iocoder.cn/images/Eureka/2018_06_29/04.png)

**ç¼“å­˜è¿‡æœŸç­–ç•¥**å¦‚ä¸‹ï¼š

* åº”ç”¨å®ä¾‹æ³¨å†Œã€ä¸‹çº¿ã€è¿‡æœŸæ—¶ï¼Œ**åªåªåª**è¿‡æœŸ `readWriteCacheMap` ã€‚
* `readWriteCacheMap` å†™å…¥ä¸€æ®µæ—¶é—´( å¯é…ç½® )åè‡ªåŠ¨è¿‡æœŸã€‚
* **å®šæ—¶**ä»»åŠ¡å¯¹æ¯” `readWriteCacheMap` å’Œ `readOnlyCacheMap` çš„ç¼“å­˜å€¼ï¼Œè‹¥ä¸ä¸€è‡´ï¼Œä»¥å‰è€…ä¸ºä¸»ã€‚é€šè¿‡è¿™æ ·çš„æ–¹å¼ï¼Œå®ç°äº† `readOnlyCacheMap` çš„å®šæ—¶è¿‡æœŸã€‚

**æ³¨æ„**ï¼šåº”ç”¨å®ä¾‹æ³¨å†Œã€ä¸‹çº¿ã€è¿‡æœŸæ—¶ï¼Œä¸ä¼šå¾ˆå¿«åˆ·æ–°åˆ° `readWriteCacheMap` ç¼“å­˜é‡Œã€‚é»˜è®¤é…ç½®ä¸‹ï¼Œæœ€å¤§å»¶è¿Ÿåœ¨ 30 ç§’ã€‚

**ä¸ºä»€ä¹ˆå¯ä»¥ä½¿ç”¨ç¼“å­˜ï¼Ÿ**

åœ¨ [CAP](https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86) çš„é€‰æ‹©ä¸Šï¼ŒEureka é€‰æ‹©äº† AP ï¼Œä¸åŒäº Zookeeper é€‰æ‹©äº† CP ã€‚

æ¨èé˜…è¯»ï¼š

* [ã€Šä¸ºä»€ä¹ˆä¸åº”è¯¥ä½¿ç”¨ZooKeeperåšæœåŠ¡å‘ç°ã€‹](http://dockone.io/article/78)
* [ã€ŠSpring Cloud Netflix Eurekaæºç å¯¼è¯»ä¸åŸç†åˆ†æã€‹ã€Œ4. ä½œä¸ºæœåŠ¡æ³¨å†Œä¸­å¿ƒï¼ŒEurekaæ¯”Zookeeperå¥½åœ¨å“ªé‡Œã€](http://blog.spring-cloud.io/blog/sc-eureka.html)

## 3.3 ç¼“å­˜è¯»å–

è°ƒç”¨ `ResponseCacheImpl#get(...)` æ–¹æ³•( `#getGzip(...)` ç±»ä¼¼ )ï¼Œè¯»å–ç¼“å­˜ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
  1: private final ConcurrentMap<Key, Value> readOnlyCacheMap = new ConcurrentHashMap<Key, Value>();
  2: 
  3: private final LoadingCache<Key, Value> readWriteCacheMap;
  4: 
  5: public String get(final Key key) {
  6:     return get(key, shouldUseReadOnlyResponseCache);
  7: }
  8: 
  9: String get(final Key key, boolean useReadOnlyCache) {
 10:     Value payload = getValue(key, useReadOnlyCache);
 11:     if (payload == null || payload.getPayload().equals(EMPTY_PAYLOAD)) {
 12:         return null;
 13:     } else {
 14:         return payload.getPayload();
 15:     }
 16: }
 17: 
 18: Value getValue(final Key key, boolean useReadOnlyCache) {
 19:     Value payload = null;
 20:     try {
 21:         if (useReadOnlyCache) {
 22:             final Value currentPayload = readOnlyCacheMap.get(key);
 23:             if (currentPayload != null) {
 24:                 payload = currentPayload;
 25:             } else {
 26:                 payload = readWriteCacheMap.get(key);
 27:                 readOnlyCacheMap.put(key, payload);
 28:             }
 29:         } else {
 30:             payload = readWriteCacheMap.get(key);
 31:         }
 32:     } catch (Throwable t) {
 33:         logger.error("Cannot get value for key :" + key, t);
 34:     }
 35:     return payload;
 36: }
```

* ç¬¬ 5 è‡³ 7 è¡Œ ï¼šè°ƒç”¨ `#get(key, useReadOnlyCache)` æ–¹æ³•ï¼Œè¯»å–ç¼“å­˜ã€‚å…¶ä¸­ `shouldUseReadOnlyResponseCache` é€šè¿‡é…ç½® `eureka.shouldUseReadOnlyResponseCache = true` (é»˜è®¤å€¼ ï¼š`true` ) å¼€å¯åªè¯»ç¼“å­˜ã€‚å¦‚æœä½ å¯¹æ•°æ®çš„ä¸€è‡´æ€§æœ‰ç›¸å¯¹é«˜çš„è¦æ±‚ï¼Œå¯ä»¥å…³é—­è¿™ä¸ªå¼€å…³ï¼Œå½“ç„¶å› ä¸ºå°‘äº† `readOnlyCacheMap` ï¼Œæ€§èƒ½ä¼šæœ‰ä¸€å®šçš„ä¸‹é™ã€‚
* ç¬¬ 9 è‡³ 16 è¡Œ ï¼šè°ƒç”¨ `getValue(key, useReadOnlyCache)` æ–¹æ³•ï¼Œè¯»å–ç¼“å­˜ã€‚ä» `readOnlyCacheMap` å’Œ `readWriteCacheMap` å˜é‡å¯ä»¥çœ‹åˆ°ç¼“å­˜å€¼çš„ç±»ä¸º `com.netflix.eureka.registry.ResponseCacheImpl.Value` ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    public class Value {
    
       /**
        * åŸå§‹å€¼
        */
       private final String payload;
       /**
        * GZIP å‹ç¼©åçš„å€¼
        */
       private byte[] gzipped;
    
       public Value(String payload) {
           this.payload = payload;
           if (!EMPTY_PAYLOAD.equals(payload)) {
               // ... çœç•¥ GZIP å‹ç¼©ä»£ç 
               gzipped = bos.toByteArray();
           } else {
               gzipped = null;
           }
       }
    
       public String getPayload() {
           return payload;
       }
    
       public byte[] getGzipped() {
           return gzipped;
       }
    
    }
    ```

* ç¬¬ 21 è‡³ 31 è¡Œ ï¼šè¯»å–ç¼“å­˜ã€‚
    * ç¬¬ 21 è‡³ 28 è¡Œ ï¼šå…ˆè¯»å– `readOnlyCacheMap` ã€‚è¯»å–ä¸åˆ°ï¼Œè¯»å– `readWriteCacheMap` ï¼Œå¹¶è®¾ç½®åˆ° `readOnlyCacheMap` ã€‚
    * ç¬¬ 29 è‡³ 31 è¡Œ ï¼šè¯»å– `readWriteCacheMap` ã€‚
    * `readWriteCacheMap` å®ç°ä»£ç å¦‚ä¸‹ï¼š

        ```Java
        this.readWriteCacheMap =
              CacheBuilder.newBuilder().initialCapacity(1000)
                      .expireAfterWrite(serverConfig.getResponseCacheAutoExpirationInSeconds(), TimeUnit.SECONDS)
                      .removalListener(new RemovalListener<Key, Value>() {
                          @Override
                          public void onRemoval(RemovalNotification<Key, Value> notification) {
                              // TODO[0009]ï¼šRemoteRegionRegistry
                              Key removedKey = notification.getKey();
                              if (removedKey.hasRegions()) {
                                  Key cloneWithNoRegions = removedKey.cloneWithoutRegions();
                                  regionSpecificKeys.remove(cloneWithNoRegions, removedKey);
                              }
                          }
                      })
                      .build(new CacheLoader<Key, Value>() {
                          @Override
                          public Value load(Key key) throws Exception {
                              // // TODO[0009]ï¼šRemoteRegionRegistry
                              if (key.hasRegions()) {
                                  Key cloneWithNoRegions = key.cloneWithoutRegions();
                                  regionSpecificKeys.put(cloneWithNoRegions, key);
                              }
                              Value value = generatePayload(key);
                              return value;
                          }
                      });
        ```
        * `readWriteCacheMap` æœ€å¤§ç¼“å­˜æ•°é‡ä¸º 1000 ã€‚
        * è°ƒç”¨ `#generatePayload(key)` æ–¹æ³•ï¼Œç”Ÿæˆç¼“å­˜å€¼ã€‚

* `#generatePayload(key)` æ–¹æ³•ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
      1: private Value generatePayload(Key key) {
      2:     Stopwatch tracer = null;
      3:     try {
      4:         String payload;
      5:         switch (key.getEntityType()) {
      6:             case Application:
      7:                 boolean isRemoteRegionRequested = key.hasRegions();
      8: 
      9:                 if (ALL_APPS.equals(key.getName())) {
     10:                     if (isRemoteRegionRequested) { // TODO[0009]ï¼šRemoteRegionRegistry
     11:                         tracer = serializeAllAppsWithRemoteRegionTimer.start();
     12:                         payload = getPayLoad(key, registry.getApplicationsFromMultipleRegions(key.getRegions()));
     13:                     } else {
     14:                         tracer = serializeAllAppsTimer.start();
     15:                         payload = getPayLoad(key, registry.getApplications());
     16:                     }
     17:                 } else if (ALL_APPS_DELTA.equals(key.getName())) {
     18:                     // ... çœç•¥å¢é‡è·å–ç›¸å…³çš„ä»£ç 
     19:                  } else {
     20:                     tracer = serializeOneApptimer.start();
     21:                     payload = getPayLoad(key, registry.getApplication(key.getName()));
     22:                 }
     23:                 break;
     24:             // ... çœç•¥éƒ¨åˆ†ä»£ç  
     25:         }
     26:         return new Value(payload);
     27:     } finally {
     28:         if (tracer != null) {
     29:             tracer.stop();
     30:         }
     31:     }
     32: }
    ```
    * ç¬¬ 10 è‡³ 12 è¡Œ ï¼šTODO[0009]ï¼šRemoteRegionRegistry
    * ç¬¬ 13 è‡³ 16 è¡Œ ï¼šè°ƒç”¨ `AbstractInstanceRegistry#getApplications()` æ–¹æ³•ï¼Œè·å¾—æ³¨å†Œçš„åº”ç”¨é›†åˆã€‚åè°ƒç”¨ `#getPayLoad()` æ–¹æ³•ï¼Œå°†æ³¨å†Œçš„åº”ç”¨é›†åˆè½¬æ¢æˆç¼“å­˜å€¼ã€‚ğŸ™‚ è¿™ä¸¤ä¸ªæ–¹æ³•ä»£ç è¾ƒå¤šï¼Œä¸‹é¢è¯¦ç»†è§£æã€‚
    * ç¬¬ 17 è‡³ 18 è¡Œ ï¼šè·å–å¢é‡æ³¨å†Œä¿¡æ¯çš„ç¼“å­˜å€¼ï¼Œåœ¨ [ã€ŠEureka æºç è§£æ â€”â€” åº”ç”¨å®ä¾‹æ³¨å†Œå‘ç° ï¼ˆä¸ƒï¼‰ä¹‹å¢é‡è·å–ã€‹](http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/) è¯¦ç»†è§£æã€‚

### 3.3.1 è·å¾—æ³¨å†Œçš„åº”ç”¨é›†åˆ

è°ƒç”¨ `AbstractInstanceRegistry#getApplications()` æ–¹æ³•ï¼Œè·å¾—æ³¨å†Œçš„åº”ç”¨é›†åˆï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
  1: // AbstractInstanceRegistry.java
  2: 
  3: private static final String[] EMPTY_STR_ARRAY = new String[0];
  4: 
  5: public Applications getApplications() {
  6:    boolean disableTransparentFallback = serverConfig.disableTransparentFallbackToOtherRegion();
  7:    if (disableTransparentFallback) { // TODO[0009]ï¼šRemoteRegionRegistry
  8:        return getApplicationsFromLocalRegionOnly();
  9:    } else {
 10:        return getApplicationsFromAllRemoteRegions();  // Behavior of falling back to remote region can be disabled.
 11:    }
 12: }
 13: 
 14: public Applications getApplicationsFromLocalRegionOnly() {
 15:    return getApplicationsFromMultipleRegions(EMPTY_STR_ARRAY);
 16: }
```

* ç¬¬ 6 è‡³ 8 è¡Œ ï¼šTODO[0009]ï¼šRemoteRegionRegistry
* ç¬¬ 9 è‡³ 16 è¡Œ ï¼šè°ƒç”¨ `#getApplicationsFromMultipleRegions(...)` æ–¹æ³•ï¼Œè·å¾—æ³¨å†Œçš„åº”ç”¨é›†åˆï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
      1: public Applications getApplicationsFromMultipleRegions(String[] remoteRegions) {
      2:     // TODO[0009]ï¼šRemoteRegionRegistry
      3:     boolean includeRemoteRegion = null != remoteRegions && remoteRegions.length != 0;
      4:     logger.debug("Fetching applications registry with remote regions: {}, Regions argument {}",
      5:             includeRemoteRegion, Arrays.toString(remoteRegions));
      6:     if (includeRemoteRegion) {
      7:         GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS.increment();
      8:     } else {
      9:         GET_ALL_CACHE_MISS.increment();
     10:     }
     11:     // è·å¾—è·å¾—æ³¨å†Œçš„åº”ç”¨é›†åˆ
     12:     Applications apps = new Applications();
     13:     apps.setVersion(1L);
     14:     for (Entry<String, Map<String, Lease<InstanceInfo>>> entry : registry.entrySet()) {
     15:         Application app = null;
     16: 
     17:         if (entry.getValue() != null) {
     18:             for (Entry<String, Lease<InstanceInfo>> stringLeaseEntry : entry.getValue().entrySet()) {
     19:                 Lease<InstanceInfo> lease = stringLeaseEntry.getValue();
     20:                 if (app == null) {
     21:                     app = new Application(lease.getHolder().getAppName());
     22:                 }
     23:                 app.addInstance(decorateInstanceInfo(lease));
     24:             }
     25:         }
     26:         if (app != null) {
     27:             apps.addApplication(app);
     28:         }
     29:     }
     30:     // TODO[0009]ï¼šRemoteRegionRegistry
     31:     if (includeRemoteRegion) {
     32:         for (String remoteRegion : remoteRegions) {
     33:             RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);
     34:             if (null != remoteRegistry) {
     35:                 Applications remoteApps = remoteRegistry.getApplications();
     36:                 for (Application application : remoteApps.getRegisteredApplications()) {
     37:                     if (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) {
     38:                         logger.info("Application {}  fetched from the remote region {}",
     39:                                 application.getName(), remoteRegion);
     40: 
     41:                         Application appInstanceTillNow = apps.getRegisteredApplications(application.getName());
     42:                         if (appInstanceTillNow == null) {
     43:                             appInstanceTillNow = new Application(application.getName());
     44:                             apps.addApplication(appInstanceTillNow);
     45:                         }
     46:                         for (InstanceInfo instanceInfo : application.getInstances()) {
     47:                             appInstanceTillNow.addInstance(instanceInfo);
     48:                         }
     49:                     } else {
     50:                         logger.debug("Application {} not fetched from the remote region {} as there exists a "
     51:                                         + "whitelist and this app is not in the whitelist.",
     52:                                 application.getName(), remoteRegion);
     53:                     }
     54:                 }
     55:             } else {
     56:                 logger.warn("No remote registry available for the remote region {}", remoteRegion);
     57:             }
     58:         }
     59:     }
     60:     // è®¾ç½® åº”ç”¨é›†åˆ hashcode
     61:     apps.setAppsHashCode(apps.getReconcileHashCode());
     62:     return apps;
     63: }
    ```
    * ç¬¬ 2 è‡³ ç¬¬ 10 è¡Œ ï¼šTODO[0009]ï¼šRemoteRegionRegistry
    * ç¬¬ 11 è‡³ 29 è¡Œ ï¼šè·å¾—è·å¾—æ³¨å†Œçš„åº”ç”¨é›†åˆã€‚
    * ç¬¬ 30 è‡³ 59 è¡Œ ï¼šTODO[0009]ï¼šRemoteRegionRegistry
    * ç¬¬ 61 è¡Œ ï¼šè®¡ç®—åº”ç”¨é›†åˆ `hashcode` ã€‚è¯¥å˜é‡ç”¨äºæ ¡éªŒ**å¢é‡**è·å–çš„æ³¨å†Œä¿¡æ¯å’Œ Eureka-Server **å…¨é‡**çš„æ³¨å†Œä¿¡æ¯æ˜¯å¦ä¸€è‡´( å®Œæ•´ )ï¼Œåœ¨ [ã€ŠEureka æºç è§£æ â€”â€” åº”ç”¨å®ä¾‹æ³¨å†Œå‘ç° ï¼ˆä¸ƒï¼‰ä¹‹å¢é‡è·å–ã€‹](http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/) è¯¦ç»†è§£æã€‚

### 3.3.2 è½¬æ¢æˆç¼“å­˜å€¼

è°ƒç”¨ `#getPayLoad()` æ–¹æ³•ï¼Œå°†æ³¨å†Œçš„åº”ç”¨é›†åˆè½¬æ¢æˆç¼“å­˜å€¼ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
/**
* Generate pay load with both JSON and XML formats for all applications.
*/
private String getPayLoad(Key key, Applications apps) {
   // è·å¾—ç¼–ç å™¨
   EncoderWrapper encoderWrapper = serverCodecs.getEncoder(key.getType(), key.getEurekaAccept());
   String result;
   try {
       // ç¼–ç 
       result = encoderWrapper.encode(apps);
   } catch (Exception e) {
       logger.error("Failed to encode the payload for all apps", e);
       return "";
   }
   if(logger.isDebugEnabled()) {
       logger.debug("New application cache entry {} with apps hashcode {}", key.toStringCompact(), apps.getAppsHashCode());
   }
   return result;
}
```

## 3.4 ä¸»åŠ¨è¿‡æœŸè¯»å†™ç¼“å­˜

åº”ç”¨å®ä¾‹æ³¨å†Œã€ä¸‹çº¿ã€è¿‡æœŸæ—¶ï¼Œè°ƒç”¨ `ResponseCacheImpl#invalidate()` æ–¹æ³•ï¼Œä¸»åŠ¨è¿‡æœŸè¯»å†™ç¼“å­˜( `readWriteCacheMap` )ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
public void invalidate(String appName, @Nullable String vipAddress, @Nullable String secureVipAddress) {
   for (Key.KeyType type : Key.KeyType.values()) {
       for (Version v : Version.values()) {
           invalidate(
                   new Key(Key.EntityType.Application, appName, type, v, EurekaAccept.full),
                   new Key(Key.EntityType.Application, appName, type, v, EurekaAccept.compact),
                   new Key(Key.EntityType.Application, ALL_APPS, type, v, EurekaAccept.full),
                   new Key(Key.EntityType.Application, ALL_APPS, type, v, EurekaAccept.compact),
                   new Key(Key.EntityType.Application, ALL_APPS_DELTA, type, v, EurekaAccept.full),
                   new Key(Key.EntityType.Application, ALL_APPS_DELTA, type, v, EurekaAccept.compact)
           );
           if (null != vipAddress) {
               invalidate(new Key(Key.EntityType.VIP, vipAddress, type, v, EurekaAccept.full));
           }
           if (null != secureVipAddress) {
               invalidate(new Key(Key.EntityType.SVIP, secureVipAddress, type, v, EurekaAccept.full));
           }
       }
   }
}
```

* è°ƒç”¨ `#invalidate(keys)` æ–¹æ³•ï¼Œé€ä¸ªè¿‡æœŸæ¯ä¸ªç¼“å­˜é”®å€¼ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    public void invalidate(Key... keys) {
       for (Key key : keys) {
           logger.debug("Invalidating the response cache key : {} {} {} {}, {}", key.getEntityType(), key.getName(), key.getVersion(), key.getType(), key.getEurekaAccept());
           // è¿‡æœŸè¯»å†™ç¼“å­˜
           readWriteCacheMap.invalidate(key);
           // TODO[0009]ï¼šRemoteRegionRegistry
           Collection<Key> keysWithRegions = regionSpecificKeys.get(key);
           if (null != keysWithRegions && !keysWithRegions.isEmpty()) {
               for (Key keysWithRegion : keysWithRegions) {
                   logger.debug("Invalidating the response cache key : {} {} {} {} {}",
                           key.getEntityType(), key.getName(), key.getVersion(), key.getType(), key.getEurekaAccept());
                   readWriteCacheMap.invalidate(keysWithRegion);
               }
           }
       }
    }
    ```

## 3.5 è¢«åŠ¨è¿‡æœŸè¯»å†™ç¼“å­˜

è¯»å†™ç¼“å­˜( `readWriteCacheMap` ) å†™å…¥åï¼Œä¸€æ®µæ—¶é—´è‡ªåŠ¨è¿‡æœŸï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
expireAfterWrite(serverConfig.getResponseCacheAutoExpirationInSeconds())
```

* é…ç½® `eureka.responseCacheAutoExpirationInSeconds` ï¼Œè®¾ç½®å†™å…¥è¿‡æœŸæ—¶é•¿ã€‚é»˜è®¤å€¼ ï¼š180 ç§’ã€‚

## 3.6 å®šæ—¶åˆ·æ–°åªè¯»ç¼“å­˜

**å®šæ—¶**ä»»åŠ¡å¯¹æ¯” `readWriteCacheMap` å’Œ `readOnlyCacheMap` çš„ç¼“å­˜å€¼ï¼Œè‹¥ä¸ä¸€è‡´ï¼Œä»¥å‰è€…ä¸ºä¸»ã€‚é€šè¿‡è¿™æ ·çš„æ–¹å¼ï¼Œå®ç°äº† `readOnlyCacheMap` çš„å®šæ—¶è¿‡æœŸã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
  1: ResponseCacheImpl(EurekaServerConfig serverConfig, ServerCodecs serverCodecs, AbstractInstanceRegistry registry) {
  2:     // ... çœç•¥æ— å…³ä»£ç  
  3: 
  4:     long responseCacheUpdateIntervalMs = serverConfig.getResponseCacheUpdateIntervalMs();
  5:     // ... çœç•¥æ— å…³ä»£ç 
  6: 
  7:     if (shouldUseReadOnlyResponseCache) {
  8:         timer.schedule(getCacheUpdateTask(),
  9:                 new Date(((System.currentTimeMillis() / responseCacheUpdateIntervalMs) * responseCacheUpdateIntervalMs)
 10:                         + responseCacheUpdateIntervalMs),
 11:                 responseCacheUpdateIntervalMs);
 12:     }
 13: 
 14:     // ... çœç•¥æ— å…³ä»£ç 
 15: }
 16: 
 17: private TimerTask getCacheUpdateTask() {
 18:     return new TimerTask() {
 19:         @Override
 20:         public void run() {
 21:             logger.debug("Updating the client cache from response cache");
 22:             for (Key key : readOnlyCacheMap.keySet()) { // å¾ªç¯ readOnlyCacheMap çš„ç¼“å­˜é”®
 23:                 if (logger.isDebugEnabled()) {
 24:                     Object[] args = {key.getEntityType(), key.getName(), key.getVersion(), key.getType()};
 25:                     logger.debug("Updating the client cache from response cache for key : {} {} {} {}", args);
 26:                 }
 27:                 try {
 28:                     CurrentRequestVersion.set(key.getVersion());
 29:                     Value cacheValue = readWriteCacheMap.get(key);
 30:                     Value currentCacheValue = readOnlyCacheMap.get(key);
 31:                     if (cacheValue != currentCacheValue) { // ä¸ä¸€è‡´æ—¶ï¼Œè¿›è¡Œæ›¿æ¢
 32:                         readOnlyCacheMap.put(key, cacheValue);
 33:                     }
 34:                 } catch (Throwable th) {
 35:                     logger.error("Error while updating the client cache from response cache for key {}", key.toStringCompact(), th);
 36:                 }
 37:             }
 38:         }
 39:     };
 40: }
```

* ç¬¬ 7 è‡³ 12 è¡Œ ï¼šåˆå§‹åŒ–å®šæ—¶ä»»åŠ¡ã€‚é…ç½® `eureka.responseCacheUpdateIntervalMs`ï¼Œè®¾ç½®ä»»åŠ¡æ‰§è¡Œé¢‘ç‡ï¼Œé»˜è®¤å€¼ ï¼š30 * 1000 æ¯«ç§’ã€‚
* ç¬¬ 17 è‡³ 39 è¡Œ ï¼šåˆ›å»ºå®šæ—¶ä»»åŠ¡ã€‚
    * ç¬¬ 22 è¡Œ ï¼šå¾ªç¯ `readOnlyCacheMap` çš„ç¼“å­˜é”®ã€‚**ä¸ºä»€ä¹ˆä¸å¾ªç¯ `readWriteCacheMap` å‘¢**ï¼Ÿ `readOnlyCacheMap` çš„ç¼“å­˜è¿‡æœŸä¾èµ–  `readWriteCacheMap`ï¼Œå› æ­¤ç¼“å­˜é”®ä¼šæ›´å¤šã€‚
    * ç¬¬ 28 è¡Œ è‡³ 33 è¡Œ ï¼šå¯¹æ¯” `readWriteCacheMap` å’Œ `readOnlyCacheMap` çš„ç¼“å­˜å€¼ï¼Œè‹¥ä¸ä¸€è‡´ï¼Œä»¥å‰è€…ä¸ºä¸»ã€‚é€šè¿‡è¿™æ ·çš„æ–¹å¼ï¼Œå®ç°äº† `readOnlyCacheMap` çš„å®šæ—¶è¿‡æœŸã€‚

# 666. å½©è›‹

![çŸ¥è¯†æ˜Ÿçƒ](http://www.iocoder.cn/images/Architecture/2017_12_29/01.png)

æ¯”é¢„æœŸï¼Œæ¯”æƒ³æƒ³ï¼Œé•¿è€å¤šè€å¤šçš„ä¸€ç¯‡æ–‡ç« ã€‚ç»†æ€ææã€‚

ä¼°è®¡ä¸‹ä¸€ç¯‡å¢é‡è·å–ä¼šç®€æ´å¾ˆå¤šã€‚

èƒ–å‹ï¼Œåˆ†äº«æˆ‘çš„å…¬ä¼—å·( **èŠ‹é“æºç ** ) ç»™ä½ çš„èƒ–å‹å¯å¥½ï¼Ÿ


