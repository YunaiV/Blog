title: Eureka æºç è§£æ â€”â€” åº”ç”¨å®ä¾‹æ³¨å†Œå‘ç°ï¼ˆäº”ï¼‰ä¹‹è¿‡æœŸ
date: 2018-06-22
tags:
categories: Eureka
permalink: Eureka/instance-registry-evict

---

æ‘˜è¦: åŸåˆ›å‡ºå¤„ http://www.iocoder.cn/Eureka/instance-registry-evict/ ã€ŒèŠ‹é“æºç ã€æ¬¢è¿è½¬è½½ï¼Œä¿ç•™æ‘˜è¦ï¼Œè°¢è°¢ï¼

**æœ¬æ–‡ä¸»è¦åŸºäº Eureka 1.8.X ç‰ˆæœ¬** 

- [1. æ¦‚è¿°](http://www.iocoder.cn/Eureka/instance-registry-evict/)
- [2. ä¸ºä»€ä¹ˆéœ€è¦è¿‡æœŸ](http://www.iocoder.cn/Eureka/instance-registry-evict/)
- [3. EvictionTask](http://www.iocoder.cn/Eureka/instance-registry-evict/)
- [4. è¿‡æœŸé€»è¾‘](http://www.iocoder.cn/Eureka/instance-registry-evict/)
- [666. å½©è›‹](http://www.iocoder.cn/Eureka/instance-registry-evict/)

---

![](http://www.iocoder.cn/images/common/wechat_mp_2018_05_18.jpg)

> ğŸ™‚ğŸ™‚ğŸ™‚å…³æ³¨**å¾®ä¿¡å…¬ä¼—å·ï¼šã€èŠ‹é“æºç ã€‘**æœ‰ç¦åˆ©ï¼š  
> 1. RocketMQ / MyCAT / Sharding-JDBC **æ‰€æœ‰**æºç åˆ†ææ–‡ç« åˆ—è¡¨  
> 2. RocketMQ / MyCAT / Sharding-JDBC **ä¸­æ–‡æ³¨é‡Šæºç  GitHub åœ°å€**  
> 3. æ‚¨å¯¹äºæºç çš„ç–‘é—®æ¯æ¡ç•™è¨€**éƒ½**å°†å¾—åˆ°**è®¤çœŸ**å›å¤ã€‚**ç”šè‡³ä¸çŸ¥é“å¦‚ä½•è¯»æºç ä¹Ÿå¯ä»¥è¯·æ•™å™¢**ã€‚  
> 4. **æ–°çš„**æºç è§£ææ–‡ç« **å®æ—¶**æ”¶åˆ°é€šçŸ¥ã€‚**æ¯å‘¨æ›´æ–°ä¸€ç¯‡å·¦å³**ã€‚  
> 5. **è®¤çœŸçš„**æºç äº¤æµå¾®ä¿¡ç¾¤ã€‚

---

# 1. æ¦‚è¿°

æœ¬æ–‡ä¸»è¦åˆ†äº« **Eureka-Server è¿‡æœŸè¶…æ—¶ç»­ç§Ÿçš„ç§Ÿçº¦**ã€‚

> FROM [ã€Šæ·±åº¦å‰–ææœåŠ¡å‘ç°ç»„ä»¶Netflix Eurekaã€‹](ã€Šhttp://techshow.ctrip.com/archives/1699.htmlã€‹)    
> ![](http://www.iocoder.cn/images/Eureka/2018_06_22/01.png)

**æ¨è Spring Cloud ä¹¦ç±**ï¼š

* è¯·æ”¯æŒæ­£ç‰ˆã€‚ä¸‹è½½ç›—ç‰ˆï¼Œ**ç­‰äºä¸»åŠ¨ç¼–å†™ä½çº§ BUG** ã€‚
* ç¨‹åºçŒ¿DD â€”â€” [ã€ŠSpring Cloudå¾®æœåŠ¡å®æˆ˜ã€‹](https://union-click.jd.com/jdc?d=505Twi)
* å‘¨ç«‹ â€”â€” [ã€ŠSpring Cloudä¸Dockerå¾®æœåŠ¡æ¶æ„å®æˆ˜ã€‹](https://union-click.jd.com/jdc?d=k3sAaK)
* ä¸¤ä¹¦é½ä¹°ï¼Œäº¬ä¸œåŒ…é‚®ã€‚



# 2. ä¸ºä»€ä¹ˆéœ€è¦è¿‡æœŸ

æ­£å¸¸æƒ…å†µä¸‹ï¼Œåº”ç”¨å®ä¾‹ä¸‹çº¿æ—¶å€™ä¼šä¸»åŠ¨å‘ Eureka-Server å‘èµ·ä¸‹çº¿è¯·æ±‚ã€‚ä½†å®é™…æƒ…å†µä¸‹ï¼Œåº”ç”¨å®ä¾‹å¯èƒ½å¼‚å¸¸å´©æºƒï¼Œåˆæˆ–è€…æ˜¯ç½‘ç»œå¼‚å¸¸ç­‰åŸå› ï¼Œå¯¼è‡´ä¸‹çº¿è¯·æ±‚æ— æ³•è¢«æˆåŠŸæäº¤ã€‚

ä»‹äºè¿™ç§æƒ…å†µï¼Œé€šè¿‡ Eureka-Client å¿ƒè·³å»¶é•¿ç§Ÿçº¦ï¼Œé…åˆ Eureka-Server æ¸…ç†è¶…æ—¶çš„ç§Ÿçº¦è§£å†³ä¸Šè¿°å¼‚å¸¸ã€‚

# 3. EvictionTask

`com.netflix.eureka.registry.AbstractInstanceRegistry.EvictionTask`ï¼Œæ¸…ç†ç§Ÿçº¦è¿‡æœŸä»»åŠ¡ã€‚åœ¨ Eureka-Server å¯åŠ¨æ—¶ï¼Œåˆå§‹åŒ– EvictionTask å®šæ—¶æ‰§è¡Œï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
// AbstractInstanceRegistry.java
/**
* æ¸…ç†ç§Ÿçº¦è¿‡æœŸä»»åŠ¡
*/
private final AtomicReference<EvictionTask> evictionTaskRef = new AtomicReference<EvictionTask>();

protected void postInit() {
   // .... çœç•¥æ— å…³ä»£ç 

   // åˆå§‹åŒ– æ¸…ç†ç§Ÿçº¦è¿‡æœŸä»»åŠ¡
   if (evictionTaskRef.get() != null) {
       evictionTaskRef.get().cancel();
   }
   evictionTaskRef.set(new EvictionTask());
   evictionTimer.schedule(evictionTaskRef.get(),
           serverConfig.getEvictionIntervalTimerInMs(),
           serverConfig.getEvictionIntervalTimerInMs());
}
```

* é…ç½® `eureka.evictionIntervalTimerInMs` ï¼Œæ¸…ç†ç§Ÿçº¦è¿‡æœŸä»»åŠ¡æ‰§è¡Œé¢‘ç‡ï¼Œå•ä½ï¼šæ¯«ç§’ã€‚é»˜è®¤ï¼Œ60000 æ¯«ç§’ã€‚
* EvictionTask å®ç°ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    class EvictionTask extends TimerTask {
    
       @Override
       public void run() {
           try {
               // è·å– è¡¥å¿æ—¶é—´æ¯«ç§’æ•°
               long compensationTimeMs = getCompensationTimeMs();
               logger.info("Running the evict task with compensationTime {}ms", compensationTimeMs);
               // æ¸…ç†è¿‡æœŸç§Ÿçº¦é€»è¾‘
               evict(compensationTimeMs);
           } catch (Throwable e) {
               logger.error("Could not run the evict task", e);
           }
       }
    
    }
    ```
    * è°ƒç”¨ `#compensationTimeMs()` æ–¹æ³•ï¼Œè·å¾—è¡¥å¿æ—¶é—´æ¯«ç§’æ•°ã€‚è®¡ç®—å…¬å¼ = å½“å‰æ—¶é—´ - æœ€åä»»åŠ¡æ‰§è¡Œæ—¶é—´ - ä»»åŠ¡æ‰§è¡Œé¢‘ç‡ã€‚ä¸ºä»€ä¹ˆéœ€è¦è¡¥å¿æ—¶é—´æ¯«ç§’æ•°ï¼Œåœ¨ [ã€Œ4. è¿‡æœŸé€»è¾‘ã€`Lease#isisExpired(additionalLeaseMs)` æ–¹æ³•](#) æ­æ™“ã€‚`#compensationTimeMs()` å®ç°ä»£ç å¦‚ä¸‹ï¼š
    
        ```Java
        /**
        * æœ€åä»»åŠ¡æ‰§è¡Œæ—¶é—´
        */
        private final AtomicLong lastExecutionNanosRef = new AtomicLong(0L);
        
        long getCompensationTimeMs() {
            long currNanos = getCurrentTimeNano();
            long lastNanos = lastExecutionNanosRef.getAndSet(currNanos);
            if (lastNanos == 0L) {
                return 0L;
            }
            long elapsedMs = TimeUnit.NANOSECONDS.toMillis(currNanos - lastNanos);
            long compensationTime = elapsedMs - serverConfig.getEvictionIntervalTimerInMs();
            return compensationTime <= 0L ? 0L : compensationTime;
        }
        ```
        * ç”±äº JVM GC ï¼Œåˆæˆ–æ˜¯æ—¶é—´åç§»( clock skew ) ç­‰åŸå› ï¼Œå®šæ—¶å™¨æ‰§è¡Œå®é™…æ¯”é¢„æœŸä¼š**ç•¥æœ‰å»¶è¿Ÿ**ã€‚ç¬”è€…åœ¨æœ¬æœº**ä½è´Ÿè½½**è¿è¡Œï¼Œå¤§æ¦‚ 10 ms å†…ã€‚
        
            > compute a compensation time defined as the actual time this task was executed since the prev iteration, vs the configured amount of time for execution. This is useful for cases where changes in time (due to clock skew or gc for example) causes the actual eviction task to execute later than the desired time according to the configured cycle.
    
    * è°ƒç”¨ `#evict(compensationTime)` æ–¹æ³•ï¼Œæ‰§è¡Œæ¸…ç†è¿‡æœŸç§Ÿçº¦é€»è¾‘ï¼Œåœ¨ [ã€Œ4. è¿‡æœŸé€»è¾‘ã€](#) è¯¦ç»†è§£æã€‚

# 4. è¿‡æœŸé€»è¾‘

è°ƒç”¨ `#evict(compensationTime)` æ–¹æ³•ï¼Œæ‰§è¡Œæ¸…ç†è¿‡æœŸç§Ÿçº¦é€»è¾‘ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
  1: public void evict(long additionalLeaseMs) {
  2:     logger.debug("Running the evict task");
  3: 
  4:     if (!isLeaseExpirationEnabled()) {
  5:         logger.debug("DS: lease expiration is currently disabled.");
  6:         return;
  7:     }
  8: 
  9:     // è·å¾— æ‰€æœ‰è¿‡æœŸçš„ç§Ÿçº¦
 10:     // We collect first all expired items, to evict them in random order. For large eviction sets,
 11:     // if we do not that, we might wipe out whole apps before self preservation kicks in. By randomizing it,
 12:     // the impact should be evenly distributed across all applications.
 13:     List<Lease<InstanceInfo>> expiredLeases = new ArrayList<>();
 14:     for (Entry<String, Map<String, Lease<InstanceInfo>>> groupEntry : registry.entrySet()) {
 15:         Map<String, Lease<InstanceInfo>> leaseMap = groupEntry.getValue();
 16:         if (leaseMap != null) {
 17:             for (Entry<String, Lease<InstanceInfo>> leaseEntry : leaseMap.entrySet()) {
 18:                 Lease<InstanceInfo> lease = leaseEntry.getValue();
 19:                 if (lease.isExpired(additionalLeaseMs) && lease.getHolder() != null) { // è¿‡æœŸ
 20:                     expiredLeases.add(lease);
 21:                 }
 22:             }
 23:         }
 24:     }
 25: 
 26:     // è®¡ç®— æœ€å¤§å…è®¸æ¸…ç†ç§Ÿçº¦æ•°é‡
 27:     // To compensate for GC pauses or drifting local time, we need to use current registry size as a base for
 28:     // triggering self-preservation. Without that we would wipe out full registry.
 29:     int registrySize = (int) getLocalRegistrySize();
 30:     int registrySizeThreshold = (int) (registrySize * serverConfig.getRenewalPercentThreshold());
 31:     int evictionLimit = registrySize - registrySizeThreshold;
 32: 
 33:     // è®¡ç®— æ¸…ç†ç§Ÿçº¦æ•°é‡
 34:     int toEvict = Math.min(expiredLeases.size(), evictionLimit);
 35:     if (toEvict > 0) {
 36:         logger.info("Evicting {} items (expired={}, evictionLimit={})", toEvict, expiredLeases.size(), evictionLimit);
 37: 
 38:         // é€ä¸ªè¿‡æœŸ
 39:         Random random = new Random(System.currentTimeMillis());
 40:         for (int i = 0; i < toEvict; i++) {
 41:             // Pick a random item (Knuth shuffle algorithm)
 42:             int next = i + random.nextInt(expiredLeases.size() - i);
 43:             Collections.swap(expiredLeases, i, next);
 44:             Lease<InstanceInfo> lease = expiredLeases.get(i);
 45: 
 46:             String appName = lease.getHolder().getAppName();
 47:             String id = lease.getHolder().getId();
 48:             EXPIRED.increment();
 49:             logger.warn("DS: Registry: expired lease for {}/{}", appName, id);
 50:             internalCancel(appName, id, false);
 51:         }
 52:     }
 53: }
```

* ç¬¬ 3 è‡³ 7 è¡Œ ï¼šåˆ¤æ–­å…è®¸æ‰§è¡Œæ¸…ç†è¿‡æœŸç§Ÿçº¦é€»è¾‘ï¼Œä¸»è¦å’Œ**è‡ªæˆ‘ä¿æŠ¤æœºåˆ¶**æœ‰å…³ï¼Œåœ¨ [ã€ŠEureka æºç è§£æ â€”â€” åº”ç”¨å®ä¾‹æ³¨å†Œå‘ç°ï¼ˆå››ï¼‰ä¹‹è‡ªæˆ‘ä¿æŠ¤æœºåˆ¶ã€‹](http://www.iocoder.cn/Eureka/instance-registry-self-preservation/?self) æœ‰è¯¦ç»†è§£æã€‚
* ç¬¬ 9 è‡³ 24 è¡Œ ï¼šè·å¾—**æ‰€æœ‰è¿‡æœŸ**çš„ç§Ÿçº¦é›†åˆã€‚
    * ç¬¬ 19 è¡Œ ï¼šè°ƒç”¨ `Lease#isisExpired(additionalLeaseMs)` æ–¹æ³•ï¼Œåˆ¤æ–­ç§Ÿçº¦æ˜¯å¦è¿‡æœŸï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š

        ```Java
        // Lease.java
        public boolean isExpired(long additionalLeaseMs) {
           return (evictionTimestamp > 0 || System.currentTimeMillis() > (lastUpdateTimestamp + duration + additionalLeaseMs));
        }
        
        public void renew() {
           lastUpdateTimestamp = System.currentTimeMillis() + duration;
        }
        ```
        * ğŸ˜ˆ**æ³¨æ„**ï¼šåœ¨ä¸è€ƒè™‘ `additionalLeaseMs` å‚æ•°çš„æƒ…å†µä¸‹ï¼Œç§Ÿçº¦è¿‡æœŸæ—¶é—´æ¯”é¢„æœŸå¤šäº†**ä¸€ä¸ª** `duration`ï¼ŒåŸå› åœ¨äº `#renew()` æ–¹æ³•é”™è¯¯çš„è®¾ç½® `lastUpdateTimestamp = System.currentTimeMillis() + duration`ï¼Œæ­£ç¡®çš„è®¾ç½®åº”è¯¥æ˜¯ `lastUpdateTimestamp = System.currentTimeMillis()` ã€‚
        
            > Note that due to renew() doing the 'wrong" thing and setting lastUpdateTimestamp to +duration more than what it should be, the expiry will actually be 2 * duration. **This is a minor bug and should only affect instances that ungracefully shutdown. Due to possible wide ranging impact to existing usage, this will not be fixed**. 
            
        * TODO[0023]ï¼šadditionalLeaseMs

* ç¬¬ 26 è‡³ 34 è¡Œ ï¼šè®¡ç®—**æœ€å¤§å…è®¸**æ¸…ç†ç§Ÿçº¦çš„æ•°é‡ï¼Œåè®¡ç®—å…è®¸æ¸…ç†ç§Ÿçº¦çš„æ•°é‡ã€‚
    * ğŸ˜ˆ**æ³¨æ„**ï¼šå³ä½¿ Eureka-Server å…³é—­**è‡ªæˆ‘ä¿æŠ¤æœºåˆ¶**ï¼Œå¦‚æœä½¿ç”¨`renewalPercentThreshold = 0.85` é»˜è®¤é…ç½®ï¼Œç»“æœä¼šæ˜¯**åˆ†æ‰¹é€æ­¥**è¿‡æœŸã€‚ä¸¾ä¸ªä¾‹å­ï¼š

        ```Java
        // å‡è®¾ 20 ä¸ªç§Ÿçº¦ï¼Œå…¶ä¸­æœ‰ 10 ä¸ªç§Ÿçº¦è¿‡æœŸã€‚
        
        // ç¬¬ä¸€è½®æ‰§è¡Œå¼€å§‹
        int registrySize = 20;
        int registrySizeThreshold = (int) (20 * 0.85) = 17;
        int evictionLimit = 20 - 17 = 3;
        int toEvict = Math.min(10, 3) = 3;
        // ç¬¬ä¸€è½®æ‰§è¡Œç»“æŸï¼Œå‰©ä½™ 17 ä¸ªç§Ÿçº¦ï¼Œå…¶ä¸­æœ‰ 7 ä¸ªç§Ÿçº¦è¿‡æœŸã€‚
        
        // ç¬¬äºŒè½®æ‰§è¡Œå¼€å§‹
        int registrySize = 17;
        int registrySizeThreshold = (int) (17 * 0.85) = 14;
        int evictionLimit = 17 - 14 = 3;
        int toEvict = Math.min(7, 3) = 3;
        // ç¬¬äºŒè½®æ‰§è¡Œç»“æŸï¼Œå‰©ä½™ 14 ä¸ªç§Ÿçº¦ï¼Œå…¶ä¸­æœ‰ 4 ä¸ªç§Ÿçº¦è¿‡æœŸã€‚
        
        // ç¬¬ä¸‰è½®æ‰§è¡Œå¼€å§‹
        int registrySize = 14;
        int registrySizeThreshold = (int) (14 * 0.85) = 11;
        int evictionLimit = 14 - 11 = 3;
        int toEvict = Math.min(4, 3) = 3;
        // ç¬¬ä¸‰è½®æ‰§è¡Œç»“æŸï¼Œå‰©ä½™ 11 ä¸ªç§Ÿçº¦ï¼Œå…¶ä¸­æœ‰ 1 ä¸ªç§Ÿçº¦è¿‡æœŸã€‚
        
        // ç¬¬å››è½®æ‰§è¡Œå¼€å§‹
        int registrySize = 11;
        int registrySizeThreshold = (int) (11 * 0.85) = 9;
        int evictionLimit = 11 - 9 = 2;
        int toEvict = Math.min(1, 2) = 1;
        // ç¬¬å››è½®æ‰§è¡Œç»“æŸï¼Œå‰©ä½™ 10 ä¸ªç§Ÿçº¦ï¼Œå…¶ä¸­æœ‰ 0 ä¸ªç§Ÿçº¦è¿‡æœŸã€‚ç»“æŸã€‚
        ```
        * ç»“è®ºï¼šæ˜¯å¦å¼€å¯è‡ªæˆ‘ä¿æŠ¤çš„å·®åˆ«ï¼Œåœ¨äºæ˜¯å¦æ‰§è¡Œæ¸…ç†è¿‡æœŸç§Ÿçº¦é€»è¾‘ã€‚å¦‚æœæƒ³å…³é—­**åˆ†æ‰¹é€æ­¥**è¿‡æœŸï¼Œè®¾ç½® `renewalPercentThreshold = 0` ã€‚

    * ç”±äº JVM GC ï¼Œæˆ–æ˜¯æœ¬åœ°æ—¶é—´å·®å¼‚åŸå› ï¼Œå¯èƒ½è‡ªæˆ‘ä¿æŠ¤æœºåˆ¶çš„é˜€å€¼ `expectedNumberOfRenewsPerMin`ã€`numberOfRenewsPerMinThreshold` ä¸å¤Ÿæ­£ç¡®ï¼Œåœ¨**è¿‡æœŸ**è¿™ä¸ªç›¸å¯¹â€œå±é™©â€çš„æ“ä½œï¼Œ**é‡æ–°è®¡ç®—è‡ªæˆ‘ä¿æŠ¤**çš„é˜€å€¼ã€‚

* ç¬¬ 35 è‡³ 51 è¡Œ ï¼š**éšæœº**æ¸…ç†è¿‡æœŸçš„ç§Ÿçº¦ã€‚ç”±äºç§Ÿçº¦æ˜¯æŒ‰ç…§**åº”ç”¨é¡ºåº**æ·»åŠ åˆ°æ•°ç»„ï¼Œé€šè¿‡éšæœºçš„æ–¹å¼ï¼Œ**å°½é‡é¿å…å•ä¸ªåº”ç”¨è¢«å…¨éƒ¨è¿‡æœŸ**ã€‚
    * ç¬¬ 39 è¡Œ ï¼šä¼ å…¥å½“å‰æ—¶é—´ä¸ºç§å­ç”Ÿæˆéšæœºï¼Œé¿å… Java çš„ä¼ªéšæœºæƒ…å†µã€‚åœ¨ [ã€Šä¸ºä»€ä¹ˆè¯´Javaä¸­çš„éšæœºæ•°éƒ½æ˜¯ä¼ªéšæœºæ•°ï¼Ÿã€‹](http://www.cnblogs.com/greatfish/p/5845924.html) æœ‰è¯¦ç»†è§£æã€‚
    * ç¬¬ 41 è‡³ 43 è¡Œ ï¼šéšæœºè°ƒæ¢åé¢çš„å…ƒç´ åˆ°å½“å‰ä½ç½®( `i` )ã€‚
* ç¬¬ 50 è¡Œ ï¼šè°ƒç”¨ `#internalCancel()` æ–¹æ³•ï¼Œä¸‹çº¿å·²è¿‡æœŸçš„ç§Ÿçº¦ï¼Œåœ¨ [ã€ŠEureka æºç è§£æ â€”â€” åº”ç”¨å®ä¾‹æ³¨å†Œå‘ç°ï¼ˆå››ï¼‰ä¹‹è‡ªæˆ‘ä¿æŠ¤æœºåˆ¶ã€‹ã€Œ3.2 ä¸‹çº¿åº”ç”¨å®ä¾‹ä¿¡æ¯ã€](http://www.iocoder.cn/Eureka/instance-registry-self-preservation/?self) æœ‰è¯¦ç»†è§£æã€‚

# 666. å½©è›‹

![çŸ¥è¯†æ˜Ÿçƒ](http://www.iocoder.cn/images/Architecture/2017_12_29/01.png)

ğŸ˜« åŸæœ¬è§‰å¾—æ¯”è¾ƒå®¹æ˜“çš„ä¸€ç¯‡æ–‡ç« ï¼Œç»“æœæ¶ˆè€—äº†æ¯”æƒ³è±¡ä¸­çš„æ—¶é—´ï¼Œå¯èƒ½æœ‰å››ä¸ªå°æ—¶ã€‚ä¸»è¦å¡åœ¨è¡¥å¿æ—¶é—´ï¼Œç›®å‰ä¹Ÿæ²¡å¼„æ‡‚ã€‚å¦‚æœæœ‰çŸ¥é“çš„èƒ–å‹ï¼Œéº»çƒ¦å‘ŠçŸ¥ä¸‹ã€‚

èƒ–å‹ï¼Œåˆ†äº«æˆ‘çš„å…¬ä¼—å·( **èŠ‹é“æºç ** ) ç»™ä½ çš„èƒ–å‹å¯å¥½ï¼Ÿ


