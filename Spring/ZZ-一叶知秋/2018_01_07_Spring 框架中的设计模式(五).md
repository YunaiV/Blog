title: Spring æ¡†æ¶ä¸­çš„è®¾è®¡æ¨¡å¼(äº”)
date: 2018-01-07
tag: 
categories: Spring
permalink: Spring/DesignPattern-5
author: ä¸€å¶çŸ¥ç§‹
from_url: https://muyinchen.github.io/2017/08/01/Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%BA%94)/
wechat_url: 

-------

æ‘˜è¦: åŸåˆ›å‡ºå¤„ https://muyinchen.github.io/2017/08/01/Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%BA%94)/ ã€Œä¸€å¶çŸ¥ç§‹ã€æ¬¢è¿è½¬è½½ï¼Œä¿ç•™æ‘˜è¦ï¼Œè°¢è°¢ï¼

- [å‘½ä»¤æ¨¡å¼](http://www.iocoder.cn/Spring/DesignPattern-5/)
- [è®¿é—®è€…æ¨¡å¼](http://www.iocoder.cn/Spring/DesignPattern-5/)

-------

![](http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg)

> ğŸ™‚ğŸ™‚ğŸ™‚å…³æ³¨**å¾®ä¿¡å…¬ä¼—å·ï¼šã€èŠ‹é“æºç ã€‘**æœ‰ç¦åˆ©ï¼š
> 1. RocketMQ / MyCAT / Sharding-JDBC **æ‰€æœ‰**æºç åˆ†ææ–‡ç« åˆ—è¡¨
> 2. RocketMQ / MyCAT / Sharding-JDBC **ä¸­æ–‡æ³¨é‡Šæºç  GitHub åœ°å€**
> 3. æ‚¨å¯¹äºæºç çš„ç–‘é—®æ¯æ¡ç•™è¨€**éƒ½**å°†å¾—åˆ°**è®¤çœŸ**å›å¤ã€‚**ç”šè‡³ä¸çŸ¥é“å¦‚ä½•è¯»æºç ä¹Ÿå¯ä»¥è¯·æ•™å™¢**ã€‚
> 4. **æ–°çš„**æºç è§£ææ–‡ç« **å®æ—¶**æ”¶åˆ°é€šçŸ¥ã€‚**æ¯å‘¨æ›´æ–°ä¸€ç¯‡å·¦å³**ã€‚
> 5. **è®¤çœŸçš„**æºç äº¤æµå¾®ä¿¡ç¾¤ã€‚

-------

é€šè¿‡ä»¥å‰çš„4ç¯‡æ–‡ç« ï¼Œæˆ‘ä»¬çœ‹åˆ°Springé‡‡ç”¨äº†å¤§é‡çš„å…³äºåˆ›å»ºå’Œç»“æ„æ–¹é¢çš„è®¾è®¡æ¨¡å¼ã€‚

æœ¬æ–‡å°†æè¿°å±äºè¡Œä¸ºæ–¹é¢çš„ä¸¤ç§è®¾è®¡æ¨¡å¼ï¼šå‘½ä»¤å’Œè®¿é—®è€…ã€‚

## å‘½ä»¤æ¨¡å¼

è¿™ç¯‡æ–‡ç« æè¿°çš„ç¬¬ä¸€ä¸ªè¡Œä¸ºè®¾è®¡æ¨¡å¼æ˜¯**å‘½ä»¤**ã€‚å®ƒå…è®¸å°†è¯·æ±‚å°è£…åœ¨ä¸€ä¸ªå¯¹è±¡å†…å¹¶é™„åŠ ä¸€ä¸ªå›è°ƒåŠ¨ä½œ(æ¯æ¬¡é‡åˆ°æ‰€æ‰€è°“çš„å›è°ƒå¤§å®¶å°±åªéœ€è¦ç†è§£ä¸ºä¸€ä¸ªå‡½æ•°æ–¹æ³•å°±å¥½ï¼Œçœçš„å»æµªè´¹é‚£ä¹ˆå¤šè„‘å­)ã€‚è¯·æ±‚è¢«å°è£…åœ¨å‘½ä»¤å¯¹è±¡ä¹‹ä¸‹ï¼Œè€Œè¯·æ±‚çš„ç»“æœè¢«å‘é€åˆ°æ¥æ”¶è€…ã€‚å‘½ä»¤æœ¬èº«ä¸æ˜¯ç”±è°ƒç”¨è€…æ‰§è¡Œã€‚ä¸ºäº†ç›´ç™½äº†è§£å…¶ä¸­çš„ä¸»è¦æ€æƒ³ï¼Œæƒ³è±¡ä¸€ä¸‹ç®¡ç†æœåŠ¡å™¨çš„æƒ…å†µ(è¿œç¨‹é€šè¿‡`ssh`æ“ä½œ`Linux`æœåŠ¡å™¨)ã€‚ç®¡ç†å‘˜ï¼ˆ`invoker`ï¼‰åœ¨å‘½ä»¤è¡Œï¼ˆ`commands`ï¼‰ä¸­å¯åŠ¨ä¸€äº›æ“ä½œï¼Œå°†ç»“æœå‘é€åˆ°æœåŠ¡å™¨ï¼ˆæ¥æ”¶å™¨ï¼‰ã€‚åœ¨è¿™é‡Œ,æ‰€æœ‰è¿™ä¸€åˆ‡éƒ½æ˜¯ç”±å®¢æˆ·ç«¯çš„ç»ˆç«¯(ä¹Ÿå°±æ˜¯æˆ‘ä»¬ç”¨çš„`xshell`)æ¥å®Œæˆçš„ã€‚æä¸ª`Demo`æ¥è¯´æ˜ä¸€ä¸‹(å¯¹äºå‘½ä»¤ï¼Œå®ƒçš„åŠ¨ä½œå°±æ˜¯æ‰§è¡Œï¼Œå¯¹äºç®¡ç†å‘˜æ¥è®²ï¼Œæˆ‘ä»¬çš„åŠ¨ä½œå…¶å®å°±æ˜¯ä¸€ä¸ªå›è½¦ï¼Œæ‰§ä¸æ‰§è¡Œå½“ç„¶æ˜¯ç®¡ç†å‘˜è¯´çš„ç®—äº†ï¼Œæ‰§è¡Œäº¤ç»™å‘½ä»¤å¯¹è±¡äº†ï¼ŒæœåŠ¡å™¨æœ€åå°±æ˜¯ä¸€ä¸ªå±•ç¤ºç»“æœ)ï¼š

```java
public class CommandTest {

  // This test method is a client
  @Test
  public void test() {
    Administrator admin = new Administrator();
    Server server = new Server();

    // start Apache
    admin.setCommand(new StartApache(server));
    admin.typeEnter();

    // start Tomcat
    admin.setCommand(new StartTomcat(server));
    admin.typeEnter();

    // check executed commands
    int executed = server.getExecutedCommands().size();
    assertTrue("Two commands should be executed but only "+
      executed+ " were", executed == 2);
  }

}

// commands
abstract class ServerCommand {

  protected Server server;

  public ServerCommand(Server server) {
    this.server = server;
  }

  public abstract void execute();
}

class StartTomcat extends ServerCommand {

  public StartTomcat(Server server) {
    super(server);
  }

  @Override
  public void execute() {
    server.launchCommand("sudo service tomcat7 start");
  }
}

class StartApache extends ServerCommand {

  public StartApache(Server server) {
    super(server);
  }

  @Override
  public void execute() {
    server.launchCommand("sudo service apache2 start");
  }
}

// invoker
class Administrator {

  private ServerCommand command;

  public void setCommand(ServerCommand command) {
    this.command = command;
  }

  public void typeEnter() {
    this.command.execute();
  }

}

// receiver
class Server {

  // as in common terminals, we store executed commands in history
  private List<String> executedCommands = new ArrayList<String>();

  public void launchCommand(String command) {
    System.out.println("Executing: "+command+" on server");
    this.executedCommands.add(command);
  }

  public List<String> getExecutedCommands() {
    return this.executedCommands;
  }

}
```

æµ‹è¯•åº”é€šè¿‡å¹¶æ‰“å°ä¸¤ä¸ªå‘½ä»¤ï¼š

```java
Executing: sudo service apache2 start on server
Executing: sudo service tomcat7 start on server
```

å‘½ä»¤æ¨¡å¼ä¸ä»…å…è®¸å°è£…è¯·æ±‚ï¼ˆServerCommandï¼‰å¹¶å°†å…¶ä¼ è¾“åˆ°æ¥æ”¶å™¨ï¼ˆServerï¼‰ï¼Œè€Œä¸”è¿˜å¯ä»¥æ›´å¥½åœ°å¤„ç†ç»™å®šçš„è¯·æ±‚ã€‚åœ¨è¿™é‡Œï¼Œè¿™ç§æ›´å¥½çš„å¤„ç†æ˜¯é€šè¿‡å­˜å‚¨å‘½ä»¤çš„æ‰§è¡Œå†å²ã€‚åœ¨Springä¸­ï¼Œæˆ‘ä»¬åœ¨beanFactoryåç½®å¤„ç†å™¨çš„ç‰¹æ€§ä¸­æ¥æ‰¾åˆ°æŒ‡ä»¤è®¾è®¡æ¨¡å¼çš„åŸç†ã€‚è¦é€šè¿‡å¿«é€Ÿå¯¹å®ƒä»¬è¿›è¡Œå®šä¹‰ï¼Œåº”ç”¨ç¨‹åºä¸Šä¸‹æ–‡ä¼šå¯åŠ¨åç½®å¤„ç†å™¨ï¼Œå¹¶å¯ä»¥ç”¨æ¥å¯¹åˆ›å»ºçš„beanè¿›è¡Œä¸€äº›æ“ä½œï¼ˆè¿™é‡Œä¸æ‰“ç®—ç»†è¯´äº†ï¼Œå…·ä½“çš„æˆ‘åé¢ä¼šä¸“é—¨å†™ä¸€ç¯‡è¿™æ–¹é¢çš„æ–‡ç« ï¼Œæ¥åˆ†æå…¶ä¸­çš„æºç ç»†èŠ‚ï¼‰ã€‚

å½“æˆ‘ä»¬å°†å…ˆå‰Demoé‡Œå‘ˆç°çš„å‘½ä»¤é€»è¾‘è½¬æ¢å¹¶å¯¹æ¯”åˆ°`Spring beanå·¥å‚åå¤„ç†å™¨`æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥åŒºåˆ†ä»¥ä¸‹`actors`ï¼š**åç½®å¤„ç†å™¨bean**(æ˜¯æŒ‡å®ç°`BeanFactoryPostProcessor`æ¥å£)æ˜¯å‘½ä»¤ï¼Œ**org.springframework.context.support.PostProcessorRegistrationDelegate**æ˜¯è°ƒç”¨è€…(å®ƒæ‰§è¡Œ`postProcessBeanFactory`æ–¹æ³•æ³¨å†Œæ‰€æœ‰çš„åç½®å¤„ç†å™¨beanï¼Œæ­¤å¤„çœ‹ä¸‹é¢ç¬¬äºŒæ®µä»£ç )å’Œæ¥æ”¶å™¨**org.springframework.beans.factory.config.ConfigurableListableBeanFactory**å¯ä»¥åœ¨å…ƒç´ ï¼ˆbeanï¼‰æ„é€ åˆå§‹åŒ–ä¹‹å‰ä¿®æ”¹å®ƒä»¬ï¼ˆä¾‹å¦‚ï¼šåœ¨åˆå§‹åŒ–beanä¹‹å‰å¯ä»¥æ›´æ”¹å±æ€§ï¼‰ã€‚

å¦å¤–ï¼Œå›é¡¾ä¸‹ä¸Šé¢çš„é‚£ä¸ªDemoï¼Œå’Œæˆ‘ä»¬çš„Demoä¸­çš„å‘½ä»¤å†å²ç®¡ç†ä¸€æ ·ã€‚`PostProcessorRegistrationDelegate`åŒ…å«ä¸€ä¸ªå†…éƒ¨ç±»`BeanPostProcessorChecker`ï¼Œå®ƒå¯ä»¥è®°å½•å½“ä¸€ä¸ªbeanä¸ç¬¦åˆå¤„ç†æ¡ä»¶çš„æƒ…å†µã€‚

å¯ä»¥è§‚å¯Ÿ`PostProcessorRegistrationDelegate`ä¸­çš„ä¸¤æ®µä»£ç :

```java
/**
	 * BeanPostProcessor that logs an info message when a bean is created during
	 * BeanPostProcessor instantiation, i.e. when a bean is not eligible for
	 * getting processed by all BeanPostProcessors.
	 */
	private static class BeanPostProcessorChecker implements BeanPostProcessor {

		private static final Log logger = LogFactory.getLog(BeanPostProcessorChecker.class);

		private final ConfigurableListableBeanFactory beanFactory;

		private final int beanPostProcessorTargetCount;

		public BeanPostProcessorChecker(ConfigurableListableBeanFactory beanFactory, int beanPostProcessorTargetCount) {
			this.beanFactory = beanFactory;
			this.beanPostProcessorTargetCount = beanPostProcessorTargetCount;
		}

		@Override
		public Object postProcessBeforeInitialization(Object bean, String beanName) {
			return bean;
		}

		@Override
		public Object postProcessAfterInitialization(Object bean, String beanName) {
			if (bean != null && !(bean instanceof BeanPostProcessor) && !isInfrastructureBean(beanName) &&
					this.beanFactory.getBeanPostProcessorCount() < this.beanPostProcessorTargetCount) {
				if (logger.isInfoEnabled()) {
					logger.info("Bean '" + beanName + "' of type [" + bean.getClass() +
							"] is not eligible for getting processed by all BeanPostProcessors " +
							"(for example: not eligible for auto-proxying)");
				}
			}
			return bean;
		}

		private boolean isInfrastructureBean(String beanName) {
			if (beanName != null && this.beanFactory.containsBeanDefinition(beanName)) {
				BeanDefinition bd = this.beanFactory.getBeanDefinition(beanName);
				return RootBeanDefinition.ROLE_INFRASTRUCTURE == bd.getRole();
			}
			return false;
		}
	}
```

å®šä¹‰åçš„è°ƒç”¨,ç”¨çš„å°±æ˜¯`ConfigurableListableBeanFactory`çš„å®ä¾‹(çœ‹`BeanPostProcessorChecker`æ³¨é‡Š):

```java
public static void registerBeanPostProcessors(
			ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {

		String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);

		// Register BeanPostProcessorChecker that logs an info message when
		// a bean is created during BeanPostProcessor instantiation, i.e. when
		// a bean is not eligible for getting processed by all BeanPostProcessors.
		int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
  //BeanPostProcessorChecker
		beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));

		// Separate between BeanPostProcessors that implement PriorityOrdered,
		// Ordered, and the rest.
		List<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();
		List<BeanPostProcessor> internalPostProcessors = new ArrayList<>();
		List<String> orderedPostProcessorNames = new ArrayList<>();
		List<String> nonOrderedPostProcessorNames = new ArrayList<>();
		for (String ppName : postProcessorNames) {
			if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
				BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
				priorityOrderedPostProcessors.add(pp);
				if (pp instanceof MergedBeanDefinitionPostProcessor) {
					internalPostProcessors.add(pp);
				}
			}
			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
				orderedPostProcessorNames.add(ppName);
			}
			else {
				nonOrderedPostProcessorNames.add(ppName);
			}
		}

		// First, register the BeanPostProcessors that implement PriorityOrdered.
		sortPostProcessors(beanFactory, priorityOrderedPostProcessors);
		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);

		// Next, register the BeanPostProcessors that implement Ordered.
		List<BeanPostProcessor> orderedPostProcessors = new ArrayList<>();
		for (String ppName : orderedPostProcessorNames) {
			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
			orderedPostProcessors.add(pp);
			if (pp instanceof MergedBeanDefinitionPostProcessor) {
				internalPostProcessors.add(pp);
			}
		}
		sortPostProcessors(beanFactory, orderedPostProcessors);
		registerBeanPostProcessors(beanFactory, orderedPostProcessors);

		// Now, register all regular BeanPostProcessors.
		List<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<>();
		for (String ppName : nonOrderedPostProcessorNames) {
			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
			nonOrderedPostProcessors.add(pp);
			if (pp instanceof MergedBeanDefinitionPostProcessor) {
				internalPostProcessors.add(pp);
			}
		}
		registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);

		// Finally, re-register all internal BeanPostProcessors.
		sortPostProcessors(beanFactory, internalPostProcessors);
		registerBeanPostProcessors(beanFactory, internalPostProcessors);

		// Re-register post-processor for detecting inner beans as ApplicationListeners,
		// moving it to the end of the processor chain (for picking up proxies etc).
		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));
	}
```

> æ€»ç»“ä¸€ä¸ªè¿‡ç¨‹å°±æ˜¯ï¼Œæˆ‘è¦BeanFactoryé‡Œé¢å¾—åˆ°å¯¹è±¡(ä¹Ÿå°±æ˜¯ä¸ºäº†å¾—åˆ°ä¸€ä¸ªå‘½ä»¤çš„æ‰§è¡Œç»“æœ)ï¼Œé‚£ä¹ˆï¼Œæƒ³è¦åœ¨å¾—åˆ°å¯¹è±¡çš„æ—¶å€™å°±å·²ç»å®ç°äº†ä¸€äº›å¯¹å…¶ä¿®æ”¹çš„æƒ³æ³•ï¼Œé‚£ä¹ˆå°±é€šè¿‡åç½®å¤„ç†å™¨ï¼Œä¹Ÿæ˜¯å°±å®ç°äº†åç½®å¤„ç†å™¨æ¥å£çš„beans(å‘½ä»¤é‡Œå¯ä»¥é€šè¿‡ä¼ å…¥ä¸åŒçš„å‚æ•°æ¥å¾—åˆ°ä¸åŒç»“æœï¼Œæˆ–è€…å¯¹å‘½ä»¤çš„è„šæœ¬è¿›è¡Œä¿®æ”¹)ï¼Œç„¶åè¿˜éœ€è¦ä¸€ä¸ªæ‰§è¡Œè€…(æˆ‘ä»¬åœ¨åšè‡ªåŠ¨åŒ–è¿ç»´çš„æ—¶å€™ï¼Œä¸æ­¢æ“ä½œä¸€ä¸ªè„šæœ¬ï¼Œè¿™é‡Œçš„`PostProcessorRegistrationDelegate`å°±æ˜¯é›†ä¸­æ¥ç®¡ç†è¿™äº›çš„)ï¼Œæœ€åå¾—åˆ°çš„ç»“æœå°±ç”±`BeanFactory`æ¥å±•ç¤ºå’¯ã€‚

## è®¿é—®è€…æ¨¡å¼

æ¥ä¸‹æ¥è¦ä»‹ç»çš„ä¸€ä¸ªè¡Œä¸ºè®¾è®¡æ¨¡å¼æ˜¯**Visitor**:æŠ½è±¡ä¸€ç‚¹å°±æ˜¯é€šè¿‡å¦ä¸€ç§ç±»å‹çš„å¯¹è±¡æ¥ä½¿ä¸€ä¸ªå¯¹è±¡è®¿é—®ã€‚åœ¨è¿™ä¸ªç®€çŸ­å®šä¹‰ä¸­ï¼Œä½¿ç”¨è¿™ä¸ªè®¾è®¡æ¨¡å¼ä¸­çš„å¯¹è±¡å°†è¢«è§†ä¸ºè®¿é—®è€…æˆ–å¯¹è±¡å¯è¢«è®¿é—®ã€‚ç¬¬ä¸€ä¸ªè®¿é—®è€…è¦æœ‰å¯è®¿é—®æ”¯æŒã€‚è¿™ä¸ªæ¨¡å¼çš„ä¸€ä¸ªç°å®çš„ä¾‹å­å¯ä»¥æ˜¯ä¸€ä¸ªæ±½è½¦è´¨æ£€å‘˜ï¼Œä»–ä»¬æ£€æŸ¥ä¸€äº›æ±½è½¦é›¶ä»¶ï¼Œæ¯”å¦‚è½®å­ï¼Œåˆ¶åŠ¨å™¨å’Œå‘åŠ¨æœºï¼Œä»¥åˆ¤æ–­æ±½è½¦è´¨é‡æ˜¯å¦åˆæ ¼ã€‚æˆ‘ä»¬æ¥åšä¸ªJUnitæµ‹è¯•ç”¨ä¾‹ï¼š

```java
public class VisitorTest {

  @Test
  public void test() {
    CarComponent car = new Car();
    Mechanic mechanic = new QualifiedMechanic();
    car.accept(mechanic);
    assertTrue("After qualified mechanics visit, the car should be broken",
      car.isBroken());
    Mechanic nonqualifiedMechanic = new NonQualifiedMechanic();
    car.accept(nonqualifiedMechanic);
    assertFalse("Car shouldn't be broken becase non qualified mechanic " +
      " can't see breakdowns", car.isBroken());
  }

}

// visitor
interface Mechanic {
  public void visit(CarComponent element);
  public String getName();
}

class QualifiedMechanic implements Mechanic {

  @Override
  public void visit(CarComponent element) {
    element.setBroken(true);
  }

  @Override
  public String getName() {
    return "qualified";
  }
}

class NonQualifiedMechanic implements Mechanic {

  @Override
  public void visit(CarComponent element) {
    element.setBroken(true);
  }

  @Override
  public String getName() {
    return "unqualified";
  }
}

// visitable
abstract class CarComponent {
  protected boolean broken;

  public abstract void accept(Mechanic mechanic);

  public void setBroken(boolean broken) {
    this.broken = broken;
  }

  public boolean isBroken() {
    return this.broken;
  }
}

class Car extends CarComponent {

  private boolean broken = false;
  private CarComponent[] components;

  public Car() {
    components = new CarComponent[] {
      new Wheels(), new Engine(), new Brake()
    };
  }

  @Override
  public void accept(Mechanic mechanic) {
    this.broken = false;
    if (mechanic.getName().equals("qualified")) {
      int i = 0;
      while (i < components.length && this.broken == false) {
        CarComponent component = components[i];
        mechanic.visit(component);
        this.broken = component.isBroken();
        i++;
      }
    }
    // if mechanic isn't qualified, we suppose that
    // he isn't able to see breakdowns and so
    // he considers the car as no broken
    // (even if the car is broken)
  }

  @Override
  public boolean isBroken() {
          return this.broken;
  }
}

class Wheels extends CarComponent {

  @Override
  public void accept(Mechanic mechanic) {
    mechanic.visit(this);
  }
}

class Engine extends CarComponent {

  @Override
  public void accept(Mechanic mechanic) {
    mechanic.visit(this);
  }
}

class Brake extends CarComponent {

  @Override
  public void accept(Mechanic mechanic) {
    mechanic.visit(this);
  }
}
```

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ä»–ä»¬æœ‰ä¸¤ä¸ªæœºåˆ¶(è®¿é—®è€…,å…¶å®å°±æ˜¯å…æ£€å’Œä¸å…æ£€)ï¼šåˆæ ¼å’Œä¸åˆæ ¼ã€‚æš´éœ²äºä»–ä»¬çš„å¯è§å¯¹è±¡æ˜¯æ±½è½¦ã€‚é€šè¿‡å…¶æ¥å—æ–¹å¼ï¼Œå†³å®šå“ªä¸ªè§’è‰²åº”è¯¥é€‚ç”¨äºè¢«è®¿é—®è€…(é€šè¿‡ä»£ç `mechanic.getName().equals("qualified")`æ¥åˆ¤æ–­)ã€‚å½“è®¿é—®è€…åˆæ ¼æ—¶ï¼ŒCarè®©ä»–åˆ†ææ‰€æœ‰ç»„ä»¶ã€‚å¦‚æœè®¿é—®è€…ä¸åˆæ ¼ï¼ŒCarè®¤ä¸ºå…¶å¹²é¢„æ˜¯æ— ç”¨çš„ï¼Œå¹¶ä¸”åœ¨æ–¹æ³•`isBroken()`ä¸­ç›´æ¥è¿”å›`false`(å…¶å®å°±æ˜¯ä¸ºäº†è¾¾åˆ°ä¸€ä¸ªå…æ£€çš„æ•ˆæœ)ã€‚`Springåœ¨beansé…ç½®ä¸­å®ç°äº†è®¿é—®è€…è®¾è®¡æ¨¡å¼`ã€‚ä¸ºäº†è§‚å¯Ÿï¼Œæˆ‘ä»¬å¯ä»¥çœ‹çœ‹**org.springframework.beans.factory.config.BeanDefinitionVisitor**å¯¹è±¡ï¼Œè¯¥å¯¹è±¡ç”¨äº`è§£æbeanå…ƒæ•°æ®`å¹¶å°†å…¶è§£æä¸º`String`ï¼ˆä¾‹å¦‚ï¼šå…·æœ‰ä½œç”¨åŸŸæˆ–å·¥å‚æ–¹æ³•åç§°çš„XMLå±æ€§ï¼‰æˆ–`Object`ï¼ˆä¾‹å¦‚ï¼šæ„é€ å‡½æ•°å®šä¹‰ä¸­çš„å‚æ•°ï¼‰ã€‚å·²è§£æçš„å€¼åœ¨ä¸åˆ†æçš„beanå…³è”çš„`BeanDefinition`å®ä¾‹ä¸­è¿›è¡Œåˆ¤æ–­è®¾ç½®ã€‚å…·ä½“çš„æºç è¯·çœ‹`BeanDefinitionVisitor`çš„ä»£ç ç‰‡æ®µï¼š

```java
/**
 * Traverse the given BeanDefinition object and the MutablePropertyValues
 * and ConstructorArgumentValues contained in them.
 * @param beanDefinition the BeanDefinition object to traverse
 * @see #resolveStringValue(String)
 */
public void visitBeanDefinition(BeanDefinition beanDefinition) {
  visitParentName(beanDefinition);
  visitBeanClassName(beanDefinition);
  visitFactoryBeanName(beanDefinition);
  visitFactoryMethodName(beanDefinition);
  visitScope(beanDefinition);
  visitPropertyValues(beanDefinition.getPropertyValues());
  ConstructorArgumentValues cas = beanDefinition.
    getConstructorArgumentValues();
  visitIndexedArgumentValues(cas.
    getIndexedArgumentValues());
  visitGenericArgumentValues(cas.
    getGenericArgumentValues());
}

protected void visitParentName(BeanDefinition beanDefinition) {
  String parentName = beanDefinition.getParentName();
  if (parentName != null) {
    String resolvedName = resolveStringValue(parentName);
    if (!parentName.equals(resolvedName)) {
      beanDefinition.setParentName(resolvedName);
    }
  }
}
```

åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä»–ä»¬åªæ˜¯è®¿é—®æ–¹å¼ï¼Œæ²¡æœ‰å¯¹è®¿é—®è€…åšä»»ä½•è¡¥å……çš„æ§åˆ¶(åœ¨Demoé‡Œå¯¹carçš„è´¨æ£€å‘˜åšäº†æ§åˆ¶)ã€‚è¿™é‡Œè®¿é—®åŒ…æ‹¬åˆ†æç»™å®š`BeanDefinition`çš„å‚æ•°ï¼Œå¹¶å°†å…¶æ›¿æ¢ä¸ºå·²è§£æå¯¹è±¡ã€‚

åœ¨æœ€åä¸€ç¯‡å…³äºSpringä¸­è®¾è®¡æ¨¡å¼çš„æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å‘ç°äº†2ç§è¡Œä¸ºæ¨¡å¼ï¼š`ç”¨äºå¤„ç†beanå·¥å‚çš„åç½®å¤„ç†çš„å‘½ä»¤æ¨¡å¼`å’Œ`ç”¨äºå°†å®šä¹‰çš„beanå‚æ•°è½¬æ¢ä¸ºé¢å‘å¯¹è±¡ï¼ˆStringæˆ–Objectçš„å®ä¾‹ï¼‰å‚æ•°çš„è®¿é—®è€…æ¨¡å¼`ã€‚

# 666. å½©è›‹

å¦‚æœä½ å¯¹ Spring æ„Ÿå…´è¶£ï¼Œæ¬¢è¿åŠ å…¥æˆ‘çš„çŸ¥è¯†æ˜Ÿçƒä¸€èµ·äº¤æµã€‚

![çŸ¥è¯†æ˜Ÿçƒ](http://www.iocoder.cn/images/Architecture/2017_12_29/01.png)