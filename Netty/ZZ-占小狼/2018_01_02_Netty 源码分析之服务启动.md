title: ã€å å°ç‹¼ã€‘Nettyæºç åˆ†æä¹‹æœåŠ¡å¯åŠ¨
date: 2018-01-02
tags:
categories: Netty
permalink: Netty/zhanxiaolang/ServerBootstrap
author: å å°ç‹¼
from_url: https://www.jianshu.com/p/e577803f0fb8
wechat_url: https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247484487&idx=1&sn=556fcb8c7f51cb3d7e000f232b2db385&chksm=fa497bf6cd3ef2e09e93ae0753f3b62b5ff37037264bb193021dcba10b78c822fc19895d4c92#rd

-------

æ‘˜è¦: åŸåˆ›å‡ºå¤„ https://www.jianshu.com/p/e577803f0fb8 ã€Œå å°ç‹¼ã€æ¬¢è¿è½¬è½½ï¼Œä¿ç•™æ‘˜è¦ï¼Œè°¢è°¢ï¼

- [NioEventLoopGroup](http://www.iocoder.cn/Netty/zhanxiaolang/ServerBootstrap/)
- [NioEventLoop](http://www.iocoder.cn/Netty/zhanxiaolang/ServerBootstrap/)
- [ServerBootstrap](http://www.iocoder.cn/Netty/zhanxiaolang/ServerBootstrap/)
- [NioServerSocketChannel](http://www.iocoder.cn/Netty/zhanxiaolang/ServerBootstrap/)

-------

![](http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg)

> ğŸ™‚ğŸ™‚ğŸ™‚å…³æ³¨**å¾®ä¿¡å…¬ä¼—å·ï¼šã€èŠ‹é“æºç ã€‘**æœ‰ç¦åˆ©ï¼š
> 1. RocketMQ / MyCAT / Sharding-JDBC **æ‰€æœ‰**æºç åˆ†ææ–‡ç« åˆ—è¡¨
> 2. RocketMQ / MyCAT / Sharding-JDBC **ä¸­æ–‡æ³¨é‡Šæºç  GitHub åœ°å€**
> 3. æ‚¨å¯¹äºæºç çš„ç–‘é—®æ¯æ¡ç•™è¨€**éƒ½**å°†å¾—åˆ°**è®¤çœŸ**å›å¤ã€‚**ç”šè‡³ä¸çŸ¥é“å¦‚ä½•è¯»æºç ä¹Ÿå¯ä»¥è¯·æ•™å™¢**ã€‚
> 4. **æ–°çš„**æºç è§£ææ–‡ç« **å®æ—¶**æ”¶åˆ°é€šçŸ¥ã€‚**æ¯å‘¨æ›´æ–°ä¸€ç¯‡å·¦å³**ã€‚
> 5. **è®¤çœŸçš„**æºç äº¤æµå¾®ä¿¡ç¾¤ã€‚

-------

æœ¬æ–‡ä¸»è¦åˆ†æNettyæœåŠ¡ç«¯çš„å¯åŠ¨è¿‡ç¨‹ã€‚

Nettyæ˜¯åŸºäºNioå®ç°çš„ï¼Œæ‰€ä»¥ä¹Ÿç¦»ä¸å¼€selectorã€serverSocketChannelã€socketChannelå’ŒselectKeyç­‰ï¼Œåªä¸è¿‡NettyæŠŠè¿™äº›å®ç°éƒ½å°è£…åœ¨äº†åº•å±‚ã€‚

ä»ç¤ºä¾‹å¯ä»¥çœ‹å‡ºï¼Œä¸€åˆ‡ä»ServerBootstrapå¼€å§‹ã€‚

ServerBootstrapå®ä¾‹ä¸­éœ€è¦ä¸¤ä¸ªNioEventLoopGroupå®ä¾‹ï¼ŒæŒ‰ç…§èŒè´£åˆ’åˆ†æˆbosså’Œworkï¼Œæœ‰ç€ä¸åŒçš„åˆ†å·¥ï¼š
1ã€bossè´Ÿè´£è¯·æ±‚çš„accept
2ã€workè´Ÿè´£è¯·æ±‚çš„readã€write

### NioEventLoopGroup

NioEventLoopGroupä¸»è¦ç®¡ç†eventLoopçš„ç”Ÿå‘½å‘¨æœŸã€‚
eventLoopæ˜¯ä»€ä¹ˆï¼Ÿå§‘ä¸”æŠŠå®ƒçœ‹æˆæ˜¯å†…éƒ¨çš„ä¸€ä¸ªå¤„ç†çº¿ç¨‹ï¼Œæ•°é‡é»˜è®¤æ˜¯å¤„ç†å™¨ä¸ªæ•°çš„ä¸¤å€ã€‚

![img](http://upload-images.jianshu.io/upload_images/2184951-0ff0a97e70fad71b.png)

NioEventLoopGroupæ„é€ æ–¹æ³•ï¼š

```Java
public NioEventLoopGroup() {
    this(0);
}

public NioEventLoopGroup(int nThreads) {
    this(nThreads, null);
}

public NioEventLoopGroup(int nThreads, ThreadFactory threadFactory) {
    this(nThreads, threadFactory, SelectorProvider.provider());
}

public NioEventLoopGroup(
            int nThreads, ThreadFactory threadFactory, final SelectorProvider selectorProvider) {
    super(nThreads, threadFactory, selectorProvider);
}
```

MultithreadEventLoopGroupæ˜¯NioEventLoopGroupçš„çˆ¶ç±»ï¼Œæ„é€ æ–¹æ³•ï¼š

```Java
protected MultithreadEventLoopGroup(int nThreads, ThreadFactory threadFactory, Object... args) {
    super(nThreads == 0? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);
}
```

å…¶ä¸­ DEFAULT_EVENT_LOOP_THREADS ä¸ºå¤„ç†å™¨æ•°é‡çš„ä¸¤å€ã€‚

MultithreadEventExecutorGroupæ˜¯æ ¸å¿ƒï¼Œç®¡ç†eventLoopçš„ç”Ÿå‘½å‘¨æœŸï¼Œå…ˆçœ‹çœ‹å…¶ä¸­å‡ ä¸ªå˜é‡ã€‚
1ã€**children**ï¼šEventExecutoræ•°ç»„ï¼Œä¿å­˜eventLoopã€‚
2ã€**chooser**ï¼šä»childrenä¸­é€‰å–ä¸€ä¸ªeventLoopçš„ç­–ç•¥ã€‚

æ„é€ æ–¹æ³•ï¼š

```Java
protected MultithreadEventExecutorGroup(int nThreads, ThreadFactory threadFactory, Object... args) {
    if (nThreads <= 0) {
        throw new IllegalArgumentException(String.format("nThreads: %d (expected: > 0)", nThreads));
    }

    if (threadFactory == null) {
        threadFactory = newDefaultThreadFactory();
    }

    children = new SingleThreadEventExecutor[nThreads];
    if (isPowerOfTwo(children.length)) {
        chooser = new PowerOfTwoEventExecutorChooser();
    } else {
        chooser = new GenericEventExecutorChooser();
    }

    for (int i = 0; i < nThreads; i ++) {
        boolean success = false;
        try {
            children[i] = newChild(threadFactory, args);
            success = true;
        } catch (Exception e) {
            // TODO: Think about if this is a good exception type
            throw new IllegalStateException("failed to create a child event loop", e);
        } finally {
            if (!success) {
                for (int j = 0; j < i; j ++) {
                    children[j].shutdownGracefully();
                }

                for (int j = 0; j < i; j ++) {
                    EventExecutor e = children[j];
                    try {
                        while (!e.isTerminated()) {
                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);
                        }
                    } catch (InterruptedException interrupted) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }
        }
    }

    final FutureListener<Object> terminationListener = new FutureListener<Object>() {
        @Override
        public void operationComplete(Future<Object> future) throws Exception {
            if (terminatedChildren.incrementAndGet() == children.length) {
                terminationFuture.setSuccess(null);
            }
        }
    };

    for (EventExecutor e: children) {
        e.terminationFuture().addListener(terminationListener);
    }
}

 protected EventExecutor newChild(
            ThreadFactory threadFactory, Object... args) throws Exception {
      return new NioEventLoop(this, threadFactory, (SelectorProvider) args[0]);
}
```

1ã€æ ¹æ®æ•°ç»„çš„å¤§å°ï¼Œé‡‡ç”¨ä¸åŒç­–ç•¥åˆå§‹åŒ–chooserï¼Œå¦‚æœå¤§å°ä¸º2çš„å¹‚æ¬¡æ–¹ï¼Œåˆ™é‡‡ç”¨PowerOfTwoEventExecutorChooserï¼Œå¦åˆ™ä½¿ç”¨GenericEventExecutorChooserã€‚

å…¶ä¸­åˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯å¦æ˜¯2çš„å¹‚æ¬¡æ–¹çš„æ–¹æ³•ï¼Œè§‰å¾—å¾ˆèµã€‚

```Java
private static boolean isPowerOfTwo(int val) {
      return (val & -val) == val;
}
```

2ã€newChildæ–¹æ³•é‡è½½ï¼Œåˆå§‹åŒ–EventExecutoræ—¶ï¼Œå®é™…æ‰§è¡Œçš„æ˜¯NioEventLoopGroupä¸­çš„newChildæ–¹æ³•ï¼Œæ‰€ä»¥childrenå…ƒç´ çš„å®é™…ç±»å‹ä¸ºNioEventLoopã€‚

æ¥ä¸‹å»çœ‹çœ‹NioEventLoopç±»ã€‚

### NioEventLoop

æ¯ä¸ªeventLoopä¼šç»´æŠ¤ä¸€ä¸ªselectorå’ŒtaskQueueï¼Œè´Ÿè´£å¤„ç†å®¢æˆ·ç«¯è¯·æ±‚å’Œå†…éƒ¨ä»»åŠ¡ï¼Œå¦‚ServerSocketChannelæ³¨å†Œå’ŒServerSocketç»‘å®šç­‰ã€‚

![img](http://upload-images.jianshu.io/upload_images/2184951-2e248d85df2a1a86.png)

NioEventLoopæ„é€ æ–¹æ³•ï¼š

```Java
 NioEventLoop(NioEventLoopGroup parent, ThreadFactory threadFactory, SelectorProvider selectorProvider) {
      super(parent, threadFactory, false);
      if (selectorProvider == null) {
          throw new NullPointerException("selectorProvider");
      }
      provider = selectorProvider;
      selector = openSelector();
}
```

å½“çœ‹åˆ° selector = openSelector() æ—¶ï¼Œæœ‰æ²¡æœ‰è§‰å¾—äº²åˆ‡äº†è®¸å¤šï¼Œè¿™é‡Œå…ˆä¸ç®¡ selectorï¼Œçœ‹çœ‹SingleThreadEventLoopç±»ã€‚

SingleThreadEventLoopæ˜¯NioEventLoopçš„çˆ¶ç±»ï¼Œæ„é€ æ–¹æ³•ï¼š

```Java
protected SingleThreadEventLoop(EventLoopGroup parent, ThreadFactory threadFactory, boolean addTaskWakesUp) {
    super(parent, threadFactory, addTaskWakesUp);
}
```

å•¥äº‹éƒ½æ²¡åš...

ç»§ç»­çœ‹SingleThreadEventLoopçš„çˆ¶ç±»SingleThreadEventExecutor

ä»ç±»åä¸Šå¯ä»¥çœ‹å‡ºï¼Œè¿™æ˜¯ä¸€ä¸ªåªæœ‰ä¸€ä¸ªçº¿ç¨‹çš„çº¿ç¨‹æ± ï¼Œ å…ˆçœ‹çœ‹å…¶ä¸­çš„å‡ ä¸ªå˜é‡ï¼š
1ã€**state**ï¼šçº¿ç¨‹æ± å½“å‰çš„çŠ¶æ€
2ã€**taskQueue**ï¼šå­˜æ”¾ä»»åŠ¡çš„é˜Ÿåˆ—
3ã€**thread**ï¼šçº¿ç¨‹æ± ç»´æŠ¤çš„å”¯ä¸€çº¿ç¨‹
4ã€**scheduledTaskQueue**ï¼šå®šä¹‰åœ¨å…¶çˆ¶ç±»AbstractScheduledEventExecutorä¸­ï¼Œç”¨ä»¥ä¿å­˜å»¶è¿Ÿæ‰§è¡Œçš„ä»»åŠ¡ã€‚
...
æ„é€ æ–¹æ³•ï¼š

```Java
protected SingleThreadEventExecutor(EventExecutorGroup parent, ThreadFactory threadFactory, boolean addTaskWakesUp) {
    if (threadFactory == null) {
        throw new NullPointerException("threadFactory");
    }
    this.parent = parent;
    this.addTaskWakesUp = addTaskWakesUp;

    thread = threadFactory.newThread(new Runnable() {
        @Override
        public void run() {
            boolean success = false;
            updateLastExecutionTime();
            try {
                SingleThreadEventExecutor.this.run();
                success = true;
            } catch (Throwable t) {
                logger.warn("Unexpected exception from an event executor: ", t);
            } finally {
                for (;;) {
                    int oldState = STATE_UPDATER.get(SingleThreadEventExecutor.this);
                    if (oldState >= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(
                            SingleThreadEventExecutor.this, oldState, ST_SHUTTING_DOWN)) {
                        break;
                    }
                }
                // Check if confirmShutdown() was called at the end of the loop.
                if (success && gracefulShutdownStartTime == 0) {
                    logger.error(
                            "Buggy " + EventExecutor.class.getSimpleName() + " implementation; " +
                            SingleThreadEventExecutor.class.getSimpleName() + ".confirmShutdown() must be called " +
                            "before run() implementation terminates.");
                }

                try {
                    // Run all remaining tasks and shutdown hooks.
                    for (;;) {
                        if (confirmShutdown()) {
                            break;
                        }
                    }
                } finally {
                    try {
                        cleanup();
                    } finally {
                        STATE_UPDATER.set(SingleThreadEventExecutor.this, ST_TERMINATED);
                        threadLock.release();
                        if (!taskQueue.isEmpty()) {
                            logger.warn(
                                    "An event executor terminated with " +
                                    "non-empty task queue (" + taskQueue.size() + ')');
                        }

                        terminationFuture.setSuccess(null);
                    }
                }
            }
        }
    });
    threadProperties = new DefaultThreadProperties(thread);
    taskQueue = newTaskQueue();
}
```

ä»£ç å¾ˆé•¿ï¼Œå†…å®¹å¾ˆç®€å•ï¼š
1ã€åˆå§‹åŒ–ä¸€ä¸ªçº¿ç¨‹ï¼Œå¹¶åœ¨çº¿ç¨‹å†…éƒ¨æ‰§è¡ŒNioEventLoopç±»çš„runæ–¹æ³•ï¼Œå½“ç„¶è¿™ä¸ªçº¿ç¨‹ä¸ä¼šç«‹åˆ»æ‰§è¡Œã€‚
2ã€ä½¿ç”¨LinkedBlockingQueueç±»åˆå§‹åŒ–taskQueueã€‚

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œç›¸å…³çš„å¤„ç†çº¿ç¨‹å·²ç»åˆå§‹åŒ–å®Œæˆã€‚

### ServerBootstrap

é€šè¿‡serverBootstrap.bind(port)å¯åŠ¨æœåŠ¡ï¼Œè¿‡ç¨‹å¦‚ä¸‹ï¼š

```Java
/**
 * Create a new {@link Channel} and bind it.
 */
public ChannelFuture bind() {
    validate();
    SocketAddress localAddress = this.localAddress;
    if (localAddress == null) {
       throw new IllegalStateException("localAddress not set");
    }
    return doBind(localAddress);
 }
```

![img](http://upload-images.jianshu.io/upload_images/2184951-59e31365d0bf8d5d.png)

doBindå®ç°å¦‚ä¸‹

```Java
private ChannelFuture doBind(final SocketAddress localAddress) {
    final ChannelFuture regFuture = initAndRegister();
    final Channel channel = regFuture.channel();
    if (regFuture.cause() != null) {
        return regFuture;
    }

    if (regFuture.isDone()) {
        // At this point we know that the registration was complete and successful.
        ChannelPromise promise = channel.newPromise();
        doBind0(regFuture, channel, localAddress, promise);
        return promise;
    } else {
        // Registration future is almost always fulfilled already, but just in case it's not.
        final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
        regFuture.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                Throwable cause = future.cause();
                if (cause != null) {
                    // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an
                    // IllegalStateException once we try to access the EventLoop of the Channel.
                    promise.setFailure(cause);
                } else {
                    // Registration was successful, so set the correct executor to use.
                    // See https://github.com/netty/netty/issues/2586
                    promise.executor = channel.eventLoop();
                }
                doBind0(regFuture, channel, localAddress, promise);
            }
        });
        return promise;
    }
}
```

1ã€æ–¹æ³•initAndRegisterè¿”å›ä¸€ä¸ªChannelFutureå®ä¾‹regFutureï¼Œé€šè¿‡regFutureå¯ä»¥åˆ¤æ–­initAndRegisteræ‰§è¡Œç»“æœã€‚
2ã€å¦‚æœregFuture.isDone()ä¸ºtrueï¼Œè¯´æ˜initAndRegisterå·²ç»æ‰§è¡Œå®Œï¼Œåˆ™ç›´æ¥æ‰§è¡ŒdoBind0è¿›è¡Œsocketç»‘å®šã€‚
3ã€å¦åˆ™regFutureæ·»åŠ ä¸€ä¸ªChannelFutureListenerç›‘å¬ï¼Œå½“initAndRegisteræ‰§è¡Œå®Œæˆæ—¶ï¼Œè°ƒç”¨operationCompleteæ–¹æ³•å¹¶æ‰§è¡ŒdoBind0è¿›è¡Œsocketç»‘å®šã€‚

æ‰€ä»¥åªæœ‰å½“initAndRegisteræ“ä½œç»“æŸä¹‹åæ‰èƒ½è¿›è¡Œbindæ“ä½œã€‚

initAndRegisterå®ç°

```Java
final ChannelFuture initAndRegister() {
    final Channel channel = channelFactory().newChannel();
    try {
        init(channel);
    } catch (Throwable t) {
        channel.unsafe().closeForcibly();
        // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor
        return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);
    }

    ChannelFuture regFuture = group().register(channel);
    if (regFuture.cause() != null) {
        if (channel.isRegistered()) {
            channel.close();
        } else {
            channel.unsafe().closeForcibly();
        }
    }
    return regFuture;
}
```

1ã€è´Ÿè´£åˆ›å»ºæœåŠ¡ç«¯çš„NioServerSocketChannelå®ä¾‹
2ã€ä¸ºNioServerSocketChannelçš„pipelineæ·»åŠ handler
3ã€æ³¨å†ŒNioServerSocketChannelåˆ°selector

å¤§éƒ¨åˆ†çš„è¿‡ç¨‹å’ŒNIOä¸­ç±»ä¼¼ã€‚

### NioServerSocketChannel

å¯¹Nioçš„ServerSocketChannelå’ŒSelectionKeyè¿›è¡Œäº†å°è£…ã€‚

æ„é€ æ–¹æ³•ï¼š

```Java
public NioServerSocketChannel() {
    this(newSocket(DEFAULT_SELECTOR_PROVIDER));
}

private static ServerSocketChannel newSocket(SelectorProvider provider) {
    try {
        return provider.openServerSocketChannel();
    } catch (IOException e) {
        throw new ChannelException(
                "Failed to open a server socket.", e);
    }
}

public NioServerSocketChannel(ServerSocketChannel channel) {
    super(null, channel, SelectionKey.OP_ACCEPT);
    config = new NioServerSocketChannelConfig(this, javaChannel().socket());
}
```

1ã€æ–¹æ³•newSocketåˆ©ç”¨ provider.openServerSocketChannel() ç”ŸæˆNioä¸­çš„ServerSocketChannelå¯¹è±¡ã€‚
2ã€è®¾ç½®SelectionKey.OP_ACCEPTäº‹ä»¶ã€‚

AbstractNioMessageChannelæ„é€ æ–¹æ³•

```Java
protected  AbstractNioMessageChannel(Channel parent, SelectableChannel ch, int readInterestOp) {
    super(parent, ch, readInterestOp);
}
```

å•¥ä¹Ÿæ²¡åš...

AbstractNioChannelæ„é€ æ–¹æ³•

```Java
protected AbstractNioChannel(Channel parent, SelectableChannel ch, int readInterestOp) {
    super(parent);
    this.ch = ch;
    this.readInterestOp = readInterestOp;
    try {
        ch.configureBlocking(false);
    } catch (IOException e) {
        try {
            ch.close();
        } catch (IOException e2) {
            if (logger.isWarnEnabled()) {
                logger.warn(
                        "Failed to close a partially initialized socket.", e2);
            }
        }

        throw new ChannelException("Failed to enter non-blocking mode.", e);
    }
}
```

è®¾ç½®å½“å‰ServerSocketChannelä¸ºéé˜»å¡é€šé“ã€‚

AbstractChannelæ„é€ æ–¹æ³•

```Java
protected AbstractChannel(Channel parent) {
    this.parent = parent;
    unsafe = newUnsafe();
    pipeline = new DefaultChannelPipeline(this);
}
```

1ã€åˆå§‹åŒ–unsafeï¼Œè¿™é‡Œçš„Unsafeå¹¶éæ˜¯jdkä¸­åº•å±‚Unsafeç±»ï¼Œç”¨æ¥è´Ÿè´£åº•å±‚çš„connectã€registerã€readå’Œwriteç­‰æ“ä½œã€‚
2ã€åˆå§‹åŒ–pipelineï¼Œæ¯ä¸ªChanneléƒ½æœ‰è‡ªå·±çš„pipelineï¼Œå½“æœ‰è¯·æ±‚äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œpipelineè´Ÿè´£è°ƒç”¨ç›¸åº”çš„handerè¿›è¡Œå¤„ç†ã€‚

unsafeå’Œpipelineçš„å…·ä½“å®ç°åŸç†ä¼šåœ¨åç»­è¿›è¡Œåˆ†æã€‚

------

å›åˆ°ServerBootstrapçš„init(Channel channel)æ–¹æ³•ï¼Œæ·»åŠ handleråˆ°channelçš„pipelineä¸­ã€‚

```Java
void init(Channel channel) throws Exception {
    final Map<ChannelOption<?>, Object> options = options();
    synchronized (options) {
        channel.config().setOptions(options);
    }

    final Map<AttributeKey<?>, Object> attrs = attrs();
    synchronized (attrs) {
        for (Entry<AttributeKey<?>, Object> e: attrs.entrySet()) {
            @SuppressWarnings("unchecked")
            AttributeKey<Object> key = (AttributeKey<Object>) e.getKey();
            channel.attr(key).set(e.getValue());
        }
    }

    ChannelPipeline p = channel.pipeline();

    final EventLoopGroup currentChildGroup = childGroup;
    final ChannelHandler currentChildHandler = childHandler;
    final Entry<ChannelOption<?>, Object>[] currentChildOptions;
    final Entry<AttributeKey<?>, Object>[] currentChildAttrs;
    synchronized (childOptions) {
        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size()));
    }
    synchronized (childAttrs) {
        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size()));
    }

    p.addLast(new ChannelInitializer<Channel>() {
        @Override
        public void initChannel(Channel ch) throws Exception {
            ChannelPipeline pipeline = ch.pipeline();
            ChannelHandler handler = handler();
            if (handler != null) {
                pipeline.addLast(handler);
            }
            pipeline.addLast(new ServerBootstrapAcceptor(
                    currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
        }
    });
}
```

1ã€è®¾ç½®channelçš„optionså’Œattrsã€‚
2ã€åœ¨pipelineä¸­æ·»åŠ ä¸€ä¸ªChannelInitializerå¯¹è±¡ã€‚

------

initæ‰§è¡Œå®Œï¼Œéœ€è¦æŠŠå½“å‰channelæ³¨å†Œåˆ°EventLoopGroupã€‚
å…¶å®æœ€ç»ˆç›®çš„æ˜¯ä¸ºäº†å®ç°Nioä¸­æŠŠServerSocketæ³¨å†Œåˆ°selectorä¸Šï¼Œè¿™æ ·å°±å¯ä»¥å®ç°clientè¯·æ±‚çš„ç›‘å¬äº†ã€‚çœ‹çœ‹Nettyä¸­æ˜¯å¦‚ä½•å®ç°çš„ï¼š

```Java
public ChannelFuture register(Channel channel, ChannelPromise promise) {
    return next().register(channel, promise);
}

public EventLoop next() {
    return (EventLoop) super.next();
}

public EventExecutor next() {
    return children[Math.abs(childIndex.getAndIncrement() % children.length)];
}
```

å› ä¸ºEventLoopGroupä¸­ç»´æŠ¤äº†å¤šä¸ªeventLoopï¼Œnextæ–¹æ³•ä¼šè°ƒç”¨chooserç­–ç•¥æ‰¾åˆ°ä¸‹ä¸€ä¸ªeventLoopï¼Œå¹¶æ‰§è¡ŒeventLoopçš„registeræ–¹æ³•è¿›è¡Œæ³¨å†Œã€‚

```Java
public ChannelFuture register(final Channel channel, final ChannelPromise promise) {
    ...
    channel.unsafe().register(this, promise);
    return promise;
}
```

channel.unsafe()æ˜¯ä»€ä¹ˆï¼Ÿ
NioServerSocketChannelåˆå§‹åŒ–æ—¶ï¼Œä¼šåˆ›å»ºä¸€ä¸ªNioMessageUnsafeå®ä¾‹ï¼Œç”¨äºå®ç°åº•å±‚çš„registerã€readã€writeç­‰æ“ä½œã€‚

```Java
eventLoop.execute(new Runnable() {
   @Override
   public void run() {
      register0(promise);
   }
});

private void register0(ChannelPromise promise) {
    try {
        if (!ensureOpen(promise)) {
            return;
        }
        Runnable postRegisterTask = doRegister();
        registered = true;
        promise.setSuccess();
        pipeline.fireChannelRegistered();
        if (postRegisterTask != null) {
            postRegisterTask.run();
        }
        if (isActive()) {
            pipeline.fireChannelActive();
        }
    } catch (Throwable t) {
        // Close the channel directly to avoid FD leak.
        closeForcibly();
        if (!promise.tryFailure(t)) {

        }
        closeFuture.setClosed();
    }
}

public void execute(Runnable task) {
    if (task == null) {
        throw new NullPointerException("task");
    }

    boolean inEventLoop = inEventLoop();
    if (inEventLoop) {
        addTask(task);
    } else {
        startThread();
        addTask(task);
        if (isShutdown() && removeTask(task)) {
            reject();
        }
    }

    if (!addTaskWakesUp) {
        wakeup(inEventLoop);
    }
}
```

1ã€register0æ–¹æ³•æäº¤åˆ°eventLoopçº¿ç¨‹æ± ä¸­æ‰§è¡Œï¼Œè¿™ä¸ªæ—¶å€™ä¼šå¯åŠ¨eventLoopä¸­çš„çº¿ç¨‹ã€‚
2ã€æ–¹æ³•doRegister()æ‰æ˜¯æœ€ç»ˆNioä¸­çš„æ³¨å†Œæ–¹æ³•ï¼Œæ–¹æ³•javaChannel()è·å–ServerSocketChannelã€‚

```Java
protected Runnable doRegister() throws Exception {
    boolean selected = false;
    for (;;) {
        try {
            selectionKey = javaChannel().register(eventLoop().selector, 0, this);
            return null;
        } catch (CancelledKeyException e) {
            if (!selected) {
                // Force the Selector to select now  as the "canceled" SelectionKey may still be
                // cached and not removed because no Select.select(..) operation was called yet.
                eventLoop().selectNow();
                selected = true;
            } else {
                // We forced a select operation on the selector before but the SelectionKey is still cached
                // for whatever reason. JDK bug ?
                throw e;
            }
        }
    }
}
```

ServerSocketChannelæ³¨å†Œå®Œä¹‹åï¼Œé€šçŸ¥pipelineæ‰§è¡ŒfireChannelRegisteredæ–¹æ³•ï¼Œpipelineä¸­ç»´æŠ¤äº†handleré“¾è¡¨ï¼Œé€šè¿‡éå†é“¾è¡¨ï¼Œæ‰§è¡ŒInBoundç±»å‹handlerçš„channelRegisteredæ–¹æ³•ï¼Œæœ€ç»ˆæ‰§è¡Œinitä¸­æ·»åŠ çš„ChannelInitializer handlerã€‚

```Java
public final void channelRegistered(ChannelHandlerContext ctx)
        throws Exception {
    boolean removed = false;
    boolean success = false;
    try {
        initChannel((C) ctx.channel());
        ctx.pipeline().remove(this);
        removed = true;
        ctx.fireChannelRegistered();
        success = true;
    } catch (Throwable t) {
        logger.warn("Failed to initialize a channel. Closing: " + ctx.channel(), t);
    } finally {
        if (!removed) {
            ctx.pipeline().remove(this);
        }
        if (!success) {
            ctx.close();
        }
    }
}
```

1ã€initChannelæ–¹æ³•æœ€ç»ˆæŠŠServerBootstrapAcceptoræ·»åŠ åˆ°ServerSocketChannelçš„pipelineï¼Œè´Ÿè´£acceptå®¢æˆ·ç«¯è¯·æ±‚ã€‚
2ã€åœ¨pipelineä¸­åˆ é™¤å¯¹åº”çš„handlerã€‚
3ã€è§¦å‘fireChannelRegisteredæ–¹æ³•ï¼Œå¯ä»¥è‡ªå®šä¹‰handlerçš„channelRegisteredæ–¹æ³•ã€‚

åˆ°ç›®å‰ä¸ºæ­¢ï¼ŒServerSocketChannelå®Œæˆäº†åˆå§‹åŒ–å¹¶æ³¨å†Œåˆ°seletorä¸Šï¼Œå¯åŠ¨çº¿ç¨‹æ‰§è¡Œselector.select()æ–¹æ³•å‡†å¤‡æ¥å—å®¢æˆ·ç«¯è¯·æ±‚ã€‚

ç»†å¿ƒçš„åŒå­¦å·²ç»å‘ç°ï¼ŒServerSocketChannelçš„socketè¿˜æœªç»‘å®šåˆ°æŒ‡å®šç«¯å£ï¼Œé‚£ä¹ˆè¿™ä¸€å—Nettyæ˜¯å¦‚ä½•å®ç°çš„ï¼Ÿ
NettyæŠŠæ³¨å†Œæ“ä½œæ”¾åˆ°eventLoopä¸­æ‰§è¡Œã€‚

```Java
private static void doBind0(
        final ChannelFuture regFuture,
        final Channel channel,
        final SocketAddress localAddress,
        final ChannelPromise promise) {
    channel.eventLoop().execute(new Runnable() {
        @Override
        public void run() {
            if (regFuture.isSuccess()) {
                channel.bind(localAddress, promise)
.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
            } else {
                promise.setFailure(regFuture.cause());
            }
        }
    });
}

public ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) {
    return pipeline.bind(localAddress, promise);
}

@Override
public ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) {
    return tail.bind(localAddress, promise);
}


@Override
public ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) {
    if (localAddress == null) {
        throw new NullPointerException("localAddress");
    }
    validatePromise(promise, false);
    return findContextOutbound().invokeBind(localAddress, promise);
}

private ChannelFuture invokeBind(final SocketAddress localAddress, final ChannelPromise promise) {
    EventExecutor executor = executor();
    if (executor.inEventLoop()) {
        invokeBind0(localAddress, promise);
    } else {
        executor.execute(new Runnable() {
            @Override
            public void run() {
                invokeBind0(localAddress, promise);
            }
        });
    }
    return promise;
}

private void invokeBind0(SocketAddress localAddress, ChannelPromise promise) {
    try {
        ((ChannelOutboundHandler) handler()).bind(this, localAddress, promise);
    } catch (Throwable t) {
        notifyOutboundHandlerException(t, promise);
    }
}

@Override
public void bind(
        ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)
        throws Exception {
    unsafe.bind(localAddress, promise);
}
```

æœ€ç»ˆç”±unsafeå®ç°ç«¯å£çš„bindæ“ä½œã€‚

```Java
public final void bind(final SocketAddress localAddress, final ChannelPromise promise) {
        if (!ensureOpen(promise)) {
            return;
        }

        try {
            boolean wasActive = isActive();
            ...
            doBind(localAddress);
            promise.setSuccess();
            if (!wasActive && isActive()) {
                pipeline.fireChannelActive();
            }
        } catch (Throwable t) {
            promise.setFailure(t);
            closeIfClosed();
        }
    }

protected void doBind(SocketAddress localAddress) throws Exception {
    javaChannel().socket().bind(localAddress, config.getBacklog());
}
```

bindå®Œæˆåï¼Œä¸”ServerSocketChannelä¹Ÿå·²ç»æ³¨å†Œå®Œæˆï¼Œåˆ™è§¦å‘pipelineçš„fireChannelActiveæ–¹æ³•ï¼Œæ‰€ä»¥åœ¨è¿™é‡Œå¯ä»¥è‡ªå®šä¹‰fireChannelActiveæ–¹æ³•ï¼Œé»˜è®¤æ‰§è¡Œtailçš„fireChannelActiveã€‚

```Java
@Override
public ChannelPipeline fireChannelActive() {
    head.fireChannelActive();

    if (channel.config().isAutoRead()) {
        channel.read();
    }

    return this;
}
```

channel.read()æ–¹æ³•ä¼šè§¦å‘pipelineçš„è¡Œä¸ºï¼š

```Java
@Override
public Channel read() {
    pipeline.read();
    return this;
}

@Override
public ChannelPipeline read() {
    tail.read();
    return this;
}

@Override
public ChannelHandlerContext read() {
    findContextOutbound().invokeRead();
    return this;
}

private void invokeRead() {
    EventExecutor executor = executor();
    if (executor.inEventLoop()) {
        invokeRead0();
    } else {
        Runnable task = invokeRead0Task;
        if (task == null) {
            invokeRead0Task = task = new Runnable() {
                @Override
                public void run() {
                    invokeRead0();
                }
            };
        }
        executor.execute(task);
    }
}

private void invokeRead0() {
    try {
        ((ChannelOutboundHandler) handler()).read(this);
    } catch (Throwable t) {
        notifyHandlerException(t);
    }
}
```

æœ€ç»ˆä¼šåœ¨pipelineä¸­æ‰¾åˆ°handleræ‰§è¡Œreadæ–¹æ³•ï¼Œé»˜è®¤æ˜¯headã€‚

è‡³æ­¤ä¸ºæ­¢ï¼Œserverå·²ç»å¯åŠ¨å®Œæˆã€‚

# 666. å½©è›‹

å¦‚æœä½ å¯¹ Netty å¹¶å‘æ„Ÿå…´è¶£ï¼Œæ¬¢è¿åŠ å…¥æˆ‘çš„çŸ¥è¯†æ˜Ÿçƒä¸€èµ·äº¤æµã€‚

![çŸ¥è¯†æ˜Ÿçƒ](http://www.iocoder.cn/images/Architecture/2017_12_29/01.png)