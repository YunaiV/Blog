title: æµ…è°ˆå¸¸è§çš„ä¸ƒç§åŠ å¯†ç®—æ³•åŠå®ç°
date: 2018-11-01
tags:
categories: ç²¾è¿›
permalink: Fight/Talk-about-seven-common-encryption-algorithms-and-implementation
author: é›¶å£¹æŠ€æœ¯æ ˆ
from_url: https://juejin.im/post/5b48b0d7e51d4519962ea383
wechat_url: http://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=100002283&idx=1&sn=8149bf3eddabc4d23012ce961c7f261e&chksm=7a49765a4d3eff4cb58ce65df44bd69966e1d264ea7e587e55e1a7b5b323990e9a9c95602990#rd

-------

æ‘˜è¦: åŸåˆ›å‡ºå¤„ https://juejin.im/post/5b48b0d7e51d4519962ea383 ã€Œé›¶å£¹æŠ€æœ¯æ ˆã€æ¬¢è¿è½¬è½½ï¼Œä¿ç•™æ‘˜è¦ï¼Œè°¢è°¢ï¼

- [1. å‰è¨€](http://www.iocoder.cn/Fight/Talk-about-seven-common-encryption-algorithms-and-implementation/)
- [2. æ­£æ–‡](http://www.iocoder.cn/Fight/Talk-about-seven-common-encryption-algorithms-and-implementation/)
  - [2.1 æ•°å­—ç­¾å](http://www.iocoder.cn/Fight/Talk-about-seven-common-encryption-algorithms-and-implementation/)
  - [2.2 åŠ å¯†å’Œè§£å¯†](http://www.iocoder.cn/Fight/Talk-about-seven-common-encryption-algorithms-and-implementation/)
  - [2.3 å¯¹ç§°åŠ å¯†å’Œéå¯¹ç§°åŠ å¯†](http://www.iocoder.cn/Fight/Talk-about-seven-common-encryption-algorithms-and-implementation/)
  - [2.4 å¸¸è§çš„ç­¾ååŠ å¯†ç®—æ³•](http://www.iocoder.cn/Fight/Talk-about-seven-common-encryption-algorithms-and-implementation/)
  - [2.5 å„ç§åŠ å¯†ç®—æ³•å¯¹æ¯”](http://www.iocoder.cn/Fight/Talk-about-seven-common-encryption-algorithms-and-implementation/)
- [3. å°ç»“](http://www.iocoder.cn/Fight/Talk-about-seven-common-encryption-algorithms-and-implementation/)

-------

![](http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg)

> ğŸ™‚ğŸ™‚ğŸ™‚å…³æ³¨**å¾®ä¿¡å…¬ä¼—å·ï¼šã€èŠ‹é“æºç ã€‘**æœ‰ç¦åˆ©ï¼š
> 1. RocketMQ / MyCAT / Sharding-JDBC **æ‰€æœ‰**æºç åˆ†ææ–‡ç« åˆ—è¡¨
> 2. RocketMQ / MyCAT / Sharding-JDBC **ä¸­æ–‡æ³¨é‡Šæºç  GitHub åœ°å€**
> 3. æ‚¨å¯¹äºæºç çš„ç–‘é—®æ¯æ¡ç•™è¨€**éƒ½**å°†å¾—åˆ°**è®¤çœŸ**å›å¤ã€‚**ç”šè‡³ä¸çŸ¥é“å¦‚ä½•è¯»æºç ä¹Ÿå¯ä»¥è¯·æ•™å™¢**ã€‚
> 4. **æ–°çš„**æºç è§£ææ–‡ç« **å®æ—¶**æ”¶åˆ°é€šçŸ¥ã€‚**æ¯å‘¨æ›´æ–°ä¸€ç¯‡å·¦å³**ã€‚
> 5. **è®¤çœŸçš„**æºç äº¤æµå¾®ä¿¡ç¾¤ã€‚

-------

# 1. å‰è¨€

**æ•°å­—ç­¾å**ã€**ä¿¡æ¯åŠ å¯†** æ˜¯å‰åç«¯å¼€å‘éƒ½ç»å¸¸éœ€è¦ä½¿ç”¨åˆ°çš„æŠ€æœ¯ï¼Œåº”ç”¨åœºæ™¯åŒ…æ‹¬äº†ç”¨æˆ·ç™»å…¥ã€äº¤æ˜“ã€ä¿¡æ¯é€šè®¯ã€`oauth` ç­‰ç­‰ï¼Œä¸åŒçš„åº”ç”¨åœºæ™¯ä¹Ÿä¼šéœ€è¦ä½¿ç”¨åˆ°ä¸åŒçš„ç­¾ååŠ å¯†ç®—æ³•ï¼Œæˆ–è€…éœ€è¦æ­é…ä¸ä¸€æ ·çš„ **ç­¾ååŠ å¯†ç®—æ³•** æ¥è¾¾åˆ°ä¸šåŠ¡ç›®æ ‡ã€‚è¿™é‡Œç®€å•çš„ç»™å¤§å®¶ä»‹ç»å‡ ç§å¸¸è§çš„ç­¾ååŠ å¯†ç®—æ³•å’Œä¸€äº›å…¸å‹åœºæ™¯ä¸‹çš„åº”ç”¨ã€‚

# 2. æ­£æ–‡

## 2.1 æ•°å­—ç­¾å

**æ•°å­—ç­¾å**ï¼Œç®€å•æ¥è¯´å°±æ˜¯é€šè¿‡æä¾› **å¯é‰´åˆ«** çš„ **æ•°å­—ä¿¡æ¯** éªŒè¯ **è‡ªèº«èº«ä»½** çš„ä¸€ç§æ–¹å¼ã€‚ä¸€å¥— **æ•°å­—ç­¾å** é€šå¸¸å®šä¹‰ä¸¤ç§ **äº’è¡¥** çš„è¿ç®—ï¼Œä¸€ä¸ªç”¨äº **ç­¾å**ï¼Œå¦ä¸€ä¸ªç”¨äº **éªŒè¯**ã€‚åˆ†åˆ«ç”± **å‘é€è€…** æŒæœ‰èƒ½å¤Ÿ **ä»£è¡¨è‡ªå·±èº«ä»½** çš„ **ç§é’¥** (ç§é’¥ä¸å¯æ³„éœ²),ç”± **æ¥å—è€…** æŒæœ‰ä¸ç§é’¥å¯¹åº”çš„ **å…¬é’¥** ï¼Œèƒ½å¤Ÿåœ¨ **æ¥å—** åˆ°æ¥è‡ªå‘é€è€…ä¿¡æ¯æ—¶ç”¨äº **éªŒè¯** å…¶èº«ä»½ã€‚



![img](https://user-gold-cdn.xitu.io/2018/7/13/16493f2bfa18df72?imageView2/0/w/1280/h/960/format/jpeg/ignore-error/1)



> **æ³¨æ„**ï¼šå›¾ä¸­ **åŠ å¯†è¿‡ç¨‹** æœ‰åˆ«äº **å…¬é’¥åŠ å¯†**ï¼Œæ›´å¤š [ä»‹ç»æˆ³è¿™é‡Œ](https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F25912483)ã€‚**ç­¾å** æœ€æ ¹æœ¬çš„ç”¨é€”æ˜¯è¦èƒ½å¤Ÿå”¯ä¸€ **è¯æ˜å‘é€æ–¹çš„èº«ä»½**ï¼Œé˜²æ­¢ **ä¸­é—´äººæ”»å‡»**ã€`CSRF` **è·¨åŸŸèº«ä»½ä¼ªé€ **ã€‚åŸºäºè¿™ä¸€ç‚¹åœ¨è¯¸å¦‚ **è®¾å¤‡è®¤è¯**ã€**ç”¨æˆ·è®¤è¯**ã€**ç¬¬ä¸‰æ–¹è®¤è¯** ç­‰è®¤è¯ä½“ç³»ä¸­éƒ½ä¼šä½¿ç”¨åˆ° **ç­¾åç®—æ³•** (å½¼æ­¤çš„å®ç°æ–¹å¼å¯èƒ½ä¼šæœ‰å·®å¼‚)ã€‚

## 2.2 åŠ å¯†å’Œè§£å¯†

### 2.2.1 åŠ å¯†

**æ•°æ®åŠ å¯†** çš„åŸºæœ¬è¿‡ç¨‹ï¼Œå°±æ˜¯å¯¹åŸæ¥ä¸º **æ˜æ–‡** çš„æ–‡ä»¶æˆ–æ•°æ®æŒ‰ **æŸç§ç®—æ³•** è¿›è¡Œå¤„ç†ï¼Œä½¿å…¶æˆä¸º **ä¸å¯è¯»** çš„ä¸€æ®µä»£ç ï¼Œé€šå¸¸ç§°ä¸º **â€œå¯†æ–‡â€**ã€‚é€šè¿‡è¿™æ ·çš„é€”å¾„ï¼Œæ¥è¾¾åˆ° **ä¿æŠ¤æ•°æ®** ä¸è¢« **éæ³•äººçªƒå–**ã€é˜…è¯»çš„ç›®çš„ã€‚

### 2.2. è§£å¯†

**åŠ å¯†** çš„ **é€†è¿‡ç¨‹** ä¸º **è§£å¯†**ï¼Œå³å°†è¯¥ **ç¼–ç ä¿¡æ¯** è½¬åŒ–ä¸ºå…¶ **åŸæ¥æ•°æ®** çš„è¿‡ç¨‹ã€‚

## 2.3 å¯¹ç§°åŠ å¯†å’Œéå¯¹ç§°åŠ å¯†

åŠ å¯†ç®—æ³•åˆ† **å¯¹ç§°åŠ å¯†** å’Œ **éå¯¹ç§°åŠ å¯†**ï¼Œå…¶ä¸­å¯¹ç§°åŠ å¯†ç®—æ³•çš„åŠ å¯†ä¸è§£å¯† **å¯†é’¥ç›¸åŒ**ï¼Œéå¯¹ç§°åŠ å¯†ç®—æ³•çš„åŠ å¯†å¯†é’¥ä¸è§£å¯† **å¯†é’¥ä¸åŒ**ï¼Œæ­¤å¤–ï¼Œè¿˜æœ‰ä¸€ç±» **ä¸éœ€è¦å¯†é’¥** çš„ **æ•£åˆ—ç®—æ³•**ã€‚

> å¸¸è§çš„ **å¯¹ç§°åŠ å¯†** ç®—æ³•ä¸»è¦æœ‰ `DES`ã€`3DES`ã€`AES` ç­‰ï¼Œå¸¸è§çš„ **éå¯¹ç§°ç®—æ³•** ä¸»è¦æœ‰ `RSA`ã€`DSA` ç­‰ï¼Œ**æ•£åˆ—ç®—æ³•** ä¸»è¦æœ‰ `SHA-1`ã€`MD5` ç­‰ã€‚

### 2.3.1 å¯¹ç§°åŠ å¯†

**å¯¹ç§°åŠ å¯†ç®—æ³•** æ˜¯åº”ç”¨è¾ƒæ—©çš„åŠ å¯†ç®—æ³•ï¼Œåˆç§°ä¸º **å…±äº«å¯†é’¥åŠ å¯†ç®—æ³•**ã€‚åœ¨ **å¯¹ç§°åŠ å¯†ç®—æ³•** ä¸­ï¼Œä½¿ç”¨çš„å¯†é’¥åªæœ‰ä¸€ä¸ªï¼Œ**å‘é€** å’Œ **æ¥æ”¶** åŒæ–¹éƒ½ä½¿ç”¨è¿™ä¸ªå¯†é’¥å¯¹æ•°æ®è¿›è¡Œ **åŠ å¯†** å’Œ **è§£å¯†**ã€‚è¿™å°±è¦æ±‚åŠ å¯†å’Œè§£å¯†æ–¹äº‹å…ˆéƒ½å¿…é¡»çŸ¥é“åŠ å¯†çš„å¯†é’¥ã€‚



![img](https://user-gold-cdn.xitu.io/2018/7/13/16493f2bfa02dbcd?imageView2/0/w/1280/h/960/format/jpeg/ignore-error/1)



1. æ•°æ®åŠ å¯†è¿‡ç¨‹ï¼šåœ¨å¯¹ç§°åŠ å¯†ç®—æ³•ä¸­ï¼Œ**æ•°æ®å‘é€æ–¹** å°† **æ˜æ–‡** (åŸå§‹æ•°æ®) å’Œ **åŠ å¯†å¯†é’¥** ä¸€èµ·ç»è¿‡ç‰¹æ®Š **åŠ å¯†å¤„ç†**ï¼Œç”Ÿæˆå¤æ‚çš„ **åŠ å¯†å¯†æ–‡** è¿›è¡Œå‘é€ã€‚
2. æ•°æ®è§£å¯†è¿‡ç¨‹ï¼š**æ•°æ®æ¥æ”¶æ–¹** æ”¶åˆ°å¯†æ–‡åï¼Œè‹¥æƒ³è¯»å–åŸæ•°æ®ï¼Œåˆ™éœ€è¦ä½¿ç”¨ **åŠ å¯†ä½¿ç”¨çš„å¯†é’¥** åŠç›¸åŒç®—æ³•çš„ **é€†ç®—æ³•** å¯¹åŠ å¯†çš„å¯†æ–‡è¿›è¡Œè§£å¯†ï¼Œæ‰èƒ½ä½¿å…¶æ¢å¤æˆ **å¯è¯»æ˜æ–‡**ã€‚

### 2.3.2 éå¯¹ç§°åŠ å¯†

**éå¯¹ç§°åŠ å¯†ç®—æ³•**ï¼Œåˆç§°ä¸º **å…¬å¼€å¯†é’¥åŠ å¯†ç®—æ³•**ã€‚å®ƒéœ€è¦ä¸¤ä¸ªå¯†é’¥ï¼Œä¸€ä¸ªç§°ä¸º **å…¬å¼€å¯†é’¥** (`public key`)ï¼Œå³ **å…¬é’¥**ï¼Œå¦ä¸€ä¸ªç§°ä¸º **ç§æœ‰å¯†é’¥** (`private key`)ï¼Œå³ **ç§é’¥**ã€‚

å› ä¸º **åŠ å¯†** å’Œ **è§£å¯†** ä½¿ç”¨çš„æ˜¯ä¸¤ä¸ªä¸åŒçš„å¯†é’¥ï¼Œæ‰€ä»¥è¿™ç§ç®—æ³•ç§°ä¸º **éå¯¹ç§°åŠ å¯†ç®—æ³•**ã€‚



![img](https://user-gold-cdn.xitu.io/2018/7/13/16493f2bfa06e955?imageView2/0/w/1280/h/960/format/jpeg/ignore-error/1)



1. å¦‚æœä½¿ç”¨ **å…¬é’¥** å¯¹æ•°æ® **è¿›è¡ŒåŠ å¯†**ï¼Œåªæœ‰ç”¨å¯¹åº”çš„ **ç§é’¥** æ‰èƒ½ **è¿›è¡Œè§£å¯†**ã€‚
2. å¦‚æœä½¿ç”¨ **ç§é’¥** å¯¹æ•°æ® **è¿›è¡ŒåŠ å¯†**ï¼Œåªæœ‰ç”¨å¯¹åº”çš„ **å…¬é’¥** æ‰èƒ½ **è¿›è¡Œè§£å¯†**ã€‚

> **ä¾‹å­**ï¼šç”²æ–¹ç”Ÿæˆ **ä¸€å¯¹å¯†é’¥** å¹¶å°†å…¶ä¸­çš„ä¸€æŠŠä½œä¸º **å…¬é’¥** å‘å…¶å®ƒäººå…¬å¼€ï¼Œå¾—åˆ°è¯¥å…¬é’¥çš„ **ä¹™æ–¹** ä½¿ç”¨è¯¥å¯†é’¥å¯¹æœºå¯†ä¿¡æ¯ **è¿›è¡ŒåŠ å¯†** åå†å‘é€ç»™ç”²æ–¹ï¼Œç”²æ–¹å†ä½¿ç”¨è‡ªå·±ä¿å­˜çš„å¦ä¸€æŠŠ **ä¸“ç”¨å¯†é’¥** (**ç§é’¥**)ï¼Œå¯¹ **åŠ å¯†** åçš„ä¿¡æ¯ **è¿›è¡Œè§£å¯†**ã€‚

## 2.4 å¸¸è§çš„ç­¾ååŠ å¯†ç®—æ³•

### 2.4.1 MD5ç®—æ³•

`MD5` ç”¨çš„æ˜¯ **å“ˆå¸Œå‡½æ•°**ï¼Œå®ƒçš„å…¸å‹åº”ç”¨æ˜¯å¯¹ä¸€æ®µä¿¡æ¯äº§ç”Ÿ **ä¿¡æ¯æ‘˜è¦**ï¼Œä»¥ **é˜²æ­¢è¢«ç¯¡æ”¹**ã€‚ä¸¥æ ¼æ¥è¯´ï¼Œ`MD5` ä¸æ˜¯ä¸€ç§ **åŠ å¯†ç®—æ³•** è€Œæ˜¯ **æ‘˜è¦ç®—æ³•**ã€‚æ— è®ºæ˜¯å¤šé•¿çš„è¾“å…¥ï¼Œ`MD5` éƒ½ä¼šè¾“å‡ºé•¿åº¦ä¸º `128bits` çš„ä¸€ä¸ªä¸² (é€šå¸¸ç”¨ `16` **è¿›åˆ¶** è¡¨ç¤ºä¸º `32` ä¸ªå­—ç¬¦)ã€‚

```java
public static final byte[] computeMD5(byte[] content) {
    try {
        MessageDigest md5 = MessageDigest.getInstance("MD5");
        return md5.digest(content);
    } catch (NoSuchAlgorithmException e) {
        throw new RuntimeException(e);
    }
}
```

### 2.4.2 SHA1ç®—æ³•

`SHA1` æ˜¯å’Œ `MD5` ä¸€æ ·æµè¡Œçš„ **æ¶ˆæ¯æ‘˜è¦ç®—æ³•**ï¼Œç„¶è€Œ `SHA1` æ¯” `MD5` çš„ **å®‰å…¨æ€§æ›´å¼º**ã€‚å¯¹äºé•¿åº¦å°äº `2 ^ 64` ä½çš„æ¶ˆæ¯ï¼Œ`SHA1` ä¼šäº§ç”Ÿä¸€ä¸ª `160` ä½çš„ **æ¶ˆæ¯æ‘˜è¦**ã€‚åŸºäº `MD5`ã€`SHA1` çš„ä¿¡æ¯æ‘˜è¦ç‰¹æ€§ä»¥åŠ **ä¸å¯é€†** (ä¸€èˆ¬è€Œè¨€)ï¼Œå¯ä»¥è¢«åº”ç”¨åœ¨æ£€æŸ¥ **æ–‡ä»¶å®Œæ•´æ€§** ä»¥åŠ **æ•°å­—ç­¾å** ç­‰åœºæ™¯ã€‚

```java
public static byte[] computeSHA1(byte[] content) {
    try {
        MessageDigest sha1 = MessageDigest.getInstance("SHA1");
        return sha1.digest(content);
    } catch (NoSuchAlgorithmException e) {
        throw new RuntimeException(e);
    }
}
```

### 2.4.3 HMACç®—æ³•

`HMAC` æ˜¯å¯†é’¥ç›¸å…³çš„ **å“ˆå¸Œè¿ç®—æ¶ˆæ¯è®¤è¯ç **ï¼ˆHash-based Message Authentication Codeï¼‰ï¼Œ`HMAC` è¿ç®—åˆ©ç”¨ **å“ˆå¸Œç®—æ³•** (`MD5`ã€`SHA1` ç­‰)ï¼Œä»¥ **ä¸€ä¸ªå¯†é’¥** å’Œ **ä¸€ä¸ªæ¶ˆæ¯** ä¸ºè¾“å…¥ï¼Œç”Ÿæˆä¸€ä¸ª **æ¶ˆæ¯æ‘˜è¦** ä½œä¸º **è¾“å‡º**ã€‚

`HMAC` **å‘é€æ–¹** å’Œ **æ¥æ”¶æ–¹** éƒ½æœ‰çš„ `key` è¿›è¡Œè®¡ç®—ï¼Œè€Œæ²¡æœ‰è¿™æŠŠ `key` çš„ç¬¬ä¸‰æ–¹ï¼Œåˆ™æ˜¯ **æ— æ³•è®¡ç®—** å‡ºæ­£ç¡®çš„ **æ•£åˆ—å€¼**çš„ï¼Œè¿™æ ·å°±å¯ä»¥ **é˜²æ­¢æ•°æ®è¢«ç¯¡æ”¹**ã€‚

```java
package net.pocrd.util;
import net.pocrd.annotation.NotThreadSafe;
import net.pocrd.define.ConstField;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.util.Arrays;


@NotThreadSafe
public class HMacHelper {
    private static final Logger logger = LoggerFactory.getLogger(HMacHelper.class);
    private Mac mac;

    /**
     * MACç®—æ³•å¯é€‰ä»¥ä¸‹å¤šç§ç®—æ³•
     * HmacMD5/HmacSHA1/HmacSHA256/HmacSHA384/HmacSHA512
     */
    private static final String KEY_MAC = "HmacMD5";
    public HMacHelper(String key) {
        try {
            SecretKey secretKey = new SecretKeySpec(key.getBytes(ConstField.UTF8), KEY_MAC);
            mac = Mac.getInstance(secretKey.getAlgorithm());
            mac.init(secretKey);
        } catch (Exception e) {
            logger.error("create hmac helper failed.", e);
        }
    }
    public byte[] sign(byte[] content) {
        return mac.doFinal(content);
    }

    public boolean verify(byte[] signature, byte[] content) {
        try {
            byte[] result = mac.doFinal(content);
            return Arrays.equals(signature, result);
        } catch (Exception e) {
            logger.error("verify sig failed.", e);
        }
        return false;
    }
}
```

> **æµ‹è¯•ç»“è®º**ï¼š`HMAC` ç®—æ³•å®ä¾‹åœ¨ **å¤šçº¿ç¨‹ç¯å¢ƒ** ä¸‹æ˜¯ **ä¸å®‰å…¨çš„**ã€‚ä½†æ˜¯éœ€è¦åœ¨ **å¤šçº¿ç¨‹è®¿é—®** æ—¶ï¼Œè¿›è¡ŒåŒæ­¥çš„è¾…åŠ©ç±»ï¼Œä½¿ç”¨ `ThreadLocal` ä¸º **æ¯ä¸ªçº¿ç¨‹ç¼“å­˜** ä¸€ä¸ªå®ä¾‹å¯ä»¥é¿å…è¿›è¡Œé”æ“ä½œã€‚

### 2.4.4 AES/DES/3DESç®—æ³•

`AES`ã€`DES`ã€`3DES` éƒ½æ˜¯ **å¯¹ç§°** çš„ **å—åŠ å¯†ç®—æ³•**ï¼Œ**åŠ è§£å¯†** çš„è¿‡ç¨‹æ˜¯ **å¯é€†çš„**ã€‚å¸¸ç”¨çš„æœ‰ `AES128`ã€`AES192`ã€`AES256` (é»˜è®¤å®‰è£…çš„ `JDK` å°šä¸æ”¯æŒ `AES256`ï¼Œéœ€è¦å®‰è£…å¯¹åº”çš„ `jce` è¡¥ä¸è¿›è¡Œå‡çº§ `jce1.7`ï¼Œ`jce1.8`)ã€‚

#### 2.4.4.1 DESç®—æ³•

`DES` åŠ å¯†ç®—æ³•æ˜¯ä¸€ç§ **åˆ†ç»„å¯†ç **ï¼Œä»¥ `64` ä½ä¸º **åˆ†ç»„å¯¹æ•°æ®** åŠ å¯†ï¼Œå®ƒçš„ **å¯†é’¥é•¿åº¦** æ˜¯ `56` ä½ï¼Œ**åŠ å¯†è§£å¯†** ç”¨ **åŒä¸€ç®—æ³•**ã€‚

`DES` åŠ å¯†ç®—æ³•æ˜¯å¯¹ **å¯†é’¥** è¿›è¡Œä¿å¯†ï¼Œè€Œ **å…¬å¼€ç®—æ³•**ï¼ŒåŒ…æ‹¬åŠ å¯†å’Œè§£å¯†ç®—æ³•ã€‚è¿™æ ·ï¼Œåªæœ‰æŒæ¡äº†å’Œå‘é€æ–¹ **ç›¸åŒå¯†é’¥** çš„äººæ‰èƒ½è§£è¯»ç”± `DES`åŠ å¯†ç®—æ³•åŠ å¯†çš„å¯†æ–‡æ•°æ®ã€‚å› æ­¤ï¼Œç ´è¯‘ `DES` åŠ å¯†ç®—æ³•å®é™…ä¸Šå°±æ˜¯ **æœç´¢å¯†é’¥çš„ç¼–ç **ã€‚å¯¹äº `56` ä½é•¿åº¦çš„ **å¯†é’¥** æ¥è¯´ï¼Œå¦‚æœç”¨ **ç©·ä¸¾æ³•** æ¥è¿›è¡Œæœç´¢çš„è¯ï¼Œå…¶è¿ç®—æ¬¡æ•°ä¸º `2 ^ 56` æ¬¡ã€‚

#### 2.4.4.2 3DESç®—æ³•

æ˜¯åŸºäº `DES` çš„ **å¯¹ç§°ç®—æ³•**ï¼Œå¯¹ **ä¸€å—æ•°æ®** ç”¨ **ä¸‰ä¸ªä¸åŒçš„å¯†é’¥** è¿›è¡Œ **ä¸‰æ¬¡åŠ å¯†**ï¼Œ**å¼ºåº¦æ›´é«˜**ã€‚

#### 2.4.4.3 AESç®—æ³•

`AES` åŠ å¯†ç®—æ³•æ˜¯å¯†ç å­¦ä¸­çš„ **é«˜çº§åŠ å¯†æ ‡å‡†**ï¼Œè¯¥åŠ å¯†ç®—æ³•é‡‡ç”¨ **å¯¹ç§°åˆ†ç»„å¯†ç ä½“åˆ¶**ï¼Œå¯†é’¥é•¿åº¦çš„æœ€å°‘æ”¯æŒä¸º `128` ä½ã€ `192` ä½ã€`256` ä½ï¼Œåˆ†ç»„é•¿åº¦ `128` ä½ï¼Œç®—æ³•åº”æ˜“äºå„ç§ç¡¬ä»¶å’Œè½¯ä»¶å®ç°ã€‚è¿™ç§åŠ å¯†ç®—æ³•æ˜¯ç¾å›½è”é‚¦æ”¿åºœé‡‡ç”¨çš„ **åŒºå—åŠ å¯†æ ‡å‡†**ã€‚

`AES` æœ¬èº«å°±æ˜¯ä¸ºäº†å–ä»£ `DES` çš„ï¼Œ`AES` å…·æœ‰æ›´å¥½çš„ **å®‰å…¨æ€§**ã€**æ•ˆç‡** å’Œ **çµæ´»æ€§**ã€‚

```java
import net.pocrd.annotation.NotThreadSafe;
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.security.SecureRandom;

@NotThreadSafe
public class AesHelper {
    private SecretKeySpec keySpec;
    private IvParameterSpec iv;

    public AesHelper(byte[] aesKey, byte[] iv) {
        if (aesKey == null || aesKey.length < 16 || (iv != null && iv.length < 16)) {
            throw new RuntimeException("é”™è¯¯çš„åˆå§‹å¯†é’¥");
        }
        if (iv == null) {
            iv = Md5Util.compute(aesKey);
        }
        keySpec = new SecretKeySpec(aesKey, "AES");
        this.iv = new IvParameterSpec(iv);
    }

    public AesHelper(byte[] aesKey) {
        if (aesKey == null || aesKey.length < 16) {
            throw new RuntimeException("é”™è¯¯çš„åˆå§‹å¯†é’¥");
        }
        keySpec = new SecretKeySpec(aesKey, "AES");
        this.iv = new IvParameterSpec(Md5Util.compute(aesKey));
    }

    public byte[] encrypt(byte[] data) {
        byte[] result = null;
        Cipher cipher = null;
        try {
            cipher = Cipher.getInstance("AES/CFB/NoPadding");
            cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);
            result = cipher.doFinal(data);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return result;
    }

    public byte[] decrypt(byte[] secret) {
        byte[] result = null;
        Cipher cipher = null;
        try {
            cipher = Cipher.getInstance("AES/CFB/NoPadding");
            cipher.init(Cipher.DECRYPT_MODE, keySpec, iv);
            result = cipher.doFinal(secret);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return result;
    }

    public static byte[] randomKey(int size) {
        byte[] result = null;
        try {
            KeyGenerator gen = KeyGenerator.getInstance("AES");
            gen.init(size, new SecureRandom());
            result = gen.generateKey().getEncoded();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return result;
    }
}
```

### 2.4.5 RSAç®—æ³•

`RSA` åŠ å¯†ç®—æ³•æ˜¯ç›®å‰æœ€æœ‰å½±å“åŠ›çš„ **å…¬é’¥åŠ å¯†ç®—æ³•**ï¼Œå¹¶ä¸”è¢«æ™®éè®¤ä¸ºæ˜¯ç›®å‰ **æœ€ä¼˜ç§€çš„å…¬é’¥æ–¹æ¡ˆ** ä¹‹ä¸€ã€‚`RSA` æ˜¯ç¬¬ä¸€ä¸ªèƒ½åŒæ—¶ç”¨äº **åŠ å¯†** å’Œ **æ•°å­—ç­¾å** çš„ç®—æ³•ï¼Œå®ƒèƒ½å¤Ÿ **æŠµæŠ—** åˆ°ç›®å‰ä¸ºæ­¢å·²çŸ¥çš„ **æ‰€æœ‰å¯†ç æ”»å‡»**ï¼Œå·²è¢« `ISO` æ¨èä¸ºå…¬é’¥æ•°æ®åŠ å¯†æ ‡å‡†ã€‚

> `RSA` **åŠ å¯†ç®—æ³•** åŸºäºä¸€ä¸ªååˆ†ç®€å•çš„æ•°è®ºäº‹å®ï¼šå°†ä¸¤ä¸ªå¤§ **ç´ æ•°** ç›¸ä¹˜ååˆ†å®¹æ˜“ï¼Œä½†æƒ³è¦å¯¹å…¶ä¹˜ç§¯è¿›è¡Œ **å› å¼åˆ†è§£** å´æå…¶å›°éš¾ï¼Œå› æ­¤å¯ä»¥å°† **ä¹˜ç§¯** å…¬å¼€ä½œä¸º **åŠ å¯†å¯†é’¥**ã€‚

```java
import net.pocrd.annotation.NotThreadSafe;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import javax.crypto.Cipher;
import java.io.ByteArrayOutputStream;
import java.security.KeyFactory;
import java.security.Security;
import java.security.Signature;
import java.security.interfaces.RSAPrivateCrtKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;

@NotThreadSafe
public class RsaHelper {
    private static final Logger logger = LoggerFactory.getLogger(RsaHelper.class);
    private RSAPublicKey publicKey;
    private RSAPrivateCrtKey privateKey;

    static {
        Security.addProvider(new BouncyCastleProvider()); //ä½¿ç”¨bouncycastleä½œä¸ºåŠ å¯†ç®—æ³•å®ç°
    }

    public RsaHelper(String publicKey, String privateKey) {
        this(Base64Util.decode(publicKey), Base64Util.decode(privateKey));
    }

    public RsaHelper(byte[] publicKey, byte[] privateKey) {
        try {
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            if (publicKey != null && publicKey.length > 0) {
                this.publicKey = (RSAPublicKey)keyFactory.generatePublic(new X509EncodedKeySpec(publicKey));
            }
            if (privateKey != null && privateKey.length > 0) {
                this.privateKey = (RSAPrivateCrtKey)keyFactory.generatePrivate(new PKCS8EncodedKeySpec(privateKey));
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public RsaHelper(String publicKey) {
        this(Base64Util.decode(publicKey));
    }

    public RsaHelper(byte[] publicKey) {
        try {
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            if (publicKey != null && publicKey.length > 0) {
                this.publicKey = (RSAPublicKey)keyFactory.generatePublic(new X509EncodedKeySpec(publicKey));
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public byte[] encrypt(byte[] content) {
        if (publicKey == null) {
            throw new RuntimeException("public key is null.");
        }

        if (content == null) {
            return null;
        }

        try {
            Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
            cipher.init(Cipher.ENCRYPT_MODE, publicKey);
            int size = publicKey.getModulus().bitLength() / 8 - 11;
            ByteArrayOutputStream baos = new ByteArrayOutputStream((content.length + size - 1) / size * (size + 11));
            int left = 0;
            for (int i = 0; i < content.length; ) {
                left = content.length - i;
                if (left > size) {
                    cipher.update(content, i, size);
                    i += size;
                } else {
                    cipher.update(content, i, left);
                    i += left;
                }
                baos.write(cipher.doFinal());
            }
            return baos.toByteArray();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public byte[] decrypt(byte[] secret) {
        if (privateKey == null) {
            throw new RuntimeException("private key is null.");
        }

        if (secret == null) {
            return null;
        }

        try {
            Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
            cipher.init(Cipher.DECRYPT_MODE, privateKey);
            int size = privateKey.getModulus().bitLength() / 8;
            ByteArrayOutputStream baos = new ByteArrayOutputStream((secret.length + size - 12) / (size - 11) * size);
            int left = 0;
            for (int i = 0; i < secret.length; ) {
                left = secret.length - i;
                if (left > size) {
                    cipher.update(secret, i, size);
                    i += size;
                } else {
                    cipher.update(secret, i, left);
                    i += left;
                }
                baos.write(cipher.doFinal());
            }
            return baos.toByteArray();
        } catch (Exception e) {
            logger.error("rsa decrypt failed.", e);
        }
        return null;
    }

    public byte[] sign(byte[] content) {
        if (privateKey == null) {
            throw new RuntimeException("private key is null.");
        }
        if (content == null) {
            return null;
        }
        try {
            Signature signature = Signature.getInstance("SHA1WithRSA");
            signature.initSign(privateKey);
            signature.update(content);
            return signature.sign();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public boolean verify(byte[] sign, byte[] content) {
        if (publicKey == null) {
            throw new RuntimeException("public key is null.");
        }
        if (sign == null || content == null) {
            return false;
        }
        try {
            Signature signature = Signature.getInstance("SHA1WithRSA");
            signature.initVerify(publicKey);
            signature.update(content);
            return signature.verify(sign);
        } catch (Exception e) {
            logger.error("rsa verify failed.", e);
        }
        return false;
    }
}
```

### 2.4.6 ECCç®—æ³•

`ECC` ä¹Ÿæ˜¯ä¸€ç§ **éå¯¹ç§°åŠ å¯†ç®—æ³•**ï¼Œä¸»è¦ä¼˜åŠ¿æ˜¯åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå®ƒæ¯”å…¶ä»–çš„æ–¹æ³•ä½¿ç”¨ **æ›´å°çš„å¯†é’¥**ï¼Œæ¯”å¦‚ `RSA` **åŠ å¯†ç®—æ³•**ï¼Œæä¾› **ç›¸å½“çš„æˆ–æ›´é«˜ç­‰çº§** çš„å®‰å…¨çº§åˆ«ã€‚ä¸è¿‡ä¸€ä¸ªç¼ºç‚¹æ˜¯ **åŠ å¯†å’Œè§£å¯†æ“ä½œ** çš„å®ç°æ¯”å…¶ä»–æœºåˆ¶ **æ—¶é—´é•¿** (ç›¸æ¯” `RSA` ç®—æ³•ï¼Œè¯¥ç®—æ³•å¯¹ `CPU` æ¶ˆè€—ä¸¥é‡)ã€‚

```java
import net.pocrd.annotation.NotThreadSafe;
import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPrivateKey;
import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import javax.crypto.Cipher;
import java.io.ByteArrayOutputStream;
import java.security.KeyFactory;
import java.security.Security;
import java.security.Signature;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;

@NotThreadSafe
public class EccHelper {
    private static final Logger logger = LoggerFactory.getLogger(EccHelper.class);
    private static final int SIZE = 4096;
    private BCECPublicKey  publicKey;
    private BCECPrivateKey privateKey;

    static {
        Security.addProvider(new BouncyCastleProvider());
    }

    public EccHelper(String publicKey, String privateKey) {
        this(Base64Util.decode(publicKey), Base64Util.decode(privateKey));
    }

    public EccHelper(byte[] publicKey, byte[] privateKey) {
        try {
            KeyFactory keyFactory = KeyFactory.getInstance("EC", "BC");
            if (publicKey != null && publicKey.length > 0) {
                this.publicKey = (BCECPublicKey)keyFactory.generatePublic(new X509EncodedKeySpec(publicKey));
            }
            if (privateKey != null && privateKey.length > 0) {
                this.privateKey = (BCECPrivateKey)keyFactory.generatePrivate(new PKCS8EncodedKeySpec(privateKey));
            }
        } catch (ClassCastException e) {
            throw new RuntimeException("", e);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public EccHelper(String publicKey) {
        this(Base64Util.decode(publicKey));
    }

    public EccHelper(byte[] publicKey) {
        try {
            KeyFactory keyFactory = KeyFactory.getInstance("EC", "BC");
            if (publicKey != null && publicKey.length > 0) {
                this.publicKey = (BCECPublicKey)keyFactory.generatePublic(new X509EncodedKeySpec(publicKey));
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public byte[] encrypt(byte[] content) {
        if (publicKey == null) {
            throw new RuntimeException("public key is null.");
        }
        try {
            Cipher cipher = Cipher.getInstance("ECIES", "BC");
            cipher.init(Cipher.ENCRYPT_MODE, publicKey);
            int size = SIZE;
            ByteArrayOutputStream baos = new ByteArrayOutputStream((content.length + size - 1) / size * (size + 45));
            int left = 0;
            for (int i = 0; i < content.length; ) {
                left = content.length - i;
                if (left > size) {
                    cipher.update(content, i, size);
                    i += size;
                } else {
                    cipher.update(content, i, left);
                    i += left;
                }
                baos.write(cipher.doFinal());
            }
            return baos.toByteArray();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public byte[] decrypt(byte[] secret) {
        if (privateKey == null) {
            throw new RuntimeException("private key is null.");
        }
        try {
            Cipher cipher = Cipher.getInstance("ECIES", "BC");
            cipher.init(Cipher.DECRYPT_MODE, privateKey);
            int size = SIZE + 45;
            ByteArrayOutputStream baos = new ByteArrayOutputStream((secret.length + size + 44) / (size + 45) * size);
            int left = 0;
            for (int i = 0; i < secret.length; ) {
                left = secret.length - i;
                if (left > size) {
                    cipher.update(secret, i, size);
                    i += size;
                } else {
                    cipher.update(secret, i, left);
                    i += left;
                }
                baos.write(cipher.doFinal());
            }
            return baos.toByteArray();
        } catch (Exception e) {
            logger.error("ecc decrypt failed.", e);
        }
        return null;
    }

    public byte[] sign(byte[] content) {
        if (privateKey == null) {
            throw new RuntimeException("private key is null.");
        }
        try {
            Signature signature = Signature.getInstance("SHA1withECDSA", "BC");
            signature.initSign(privateKey);
            signature.update(content);
            return signature.sign();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public boolean verify(byte[] sign, byte[] content) {
        if (publicKey == null) {
            throw new RuntimeException("public key is null.");
        }
        try {
            Signature signature = Signature.getInstance("SHA1withECDSA", "BC");
            signature.initVerify(publicKey);
            signature.update(content);
            return signature.verify(sign);
        } catch (Exception e) {
            logger.error("ecc verify failed.", e);
        }
        return false;
    }
}
```

## 2.5 å„ç§åŠ å¯†ç®—æ³•å¯¹æ¯”

### 2.5.1 æ•£åˆ—ç®—æ³•æ¯”è¾ƒ

| åç§°  | å®‰å…¨æ€§ | é€Ÿåº¦ |
| ----- | ------ | ---- |
| SHA-1 | é«˜     | æ…¢   |
| MD5   | ä¸­     | å¿«   |

### 2.5.2 å¯¹ç§°åŠ å¯†ç®—æ³•æ¯”è¾ƒ

| åç§° | å¯†é’¥åç§°        | è¿è¡Œé€Ÿåº¦ | å®‰å…¨æ€§ | èµ„æºæ¶ˆè€— |
| ---- | --------------- | -------- | ------ | -------- |
| DES  | 56ä½            | è¾ƒå¿«     | ä½     | ä¸­       |
| 3DES | 112ä½æˆ–168ä½    | æ…¢       | ä¸­     | é«˜       |
| AES  | 128ã€192ã€256ä½ | å¿«       | é«˜     | ä½       |

### 2.5.3 éå¯¹ç§°åŠ å¯†ç®—æ³•æ¯”è¾ƒ

| åç§° | æˆç†Ÿåº¦ | å®‰å…¨æ€§ | è¿ç®—é€Ÿåº¦ | èµ„æºæ¶ˆè€— |
| ---- | ------ | ------ | -------- | -------- |
| RSA  | é«˜     | é«˜     | ä¸­       | ä¸­       |
| ECC  | é«˜     | é«˜     | æ…¢       | é«˜       |

### 2.5.4 å¯¹ç§°ç®—æ³•ä¸éå¯¹ç§°åŠ å¯†ç®—æ³•

#### 2.5.4.1 å¯¹ç§°ç®—æ³•

1. **å¯†é’¥ç®¡ç†**ï¼šæ¯”è¾ƒéš¾ï¼Œä¸é€‚åˆäº’è”ç½‘ï¼Œä¸€èˆ¬ç”¨äºå†…éƒ¨ç³»ç»Ÿ
2. **å®‰å…¨æ€§**ï¼šä¸­
3. **åŠ å¯†é€Ÿåº¦**ï¼šå¿«å¥½ **å‡ ä¸ªæ•°é‡çº§** (è½¯ä»¶åŠ è§£å¯†é€Ÿåº¦è‡³å°‘å¿« `100` å€ï¼Œæ¯ç§’å¯ä»¥åŠ è§£å¯†æ•° `M` **æ¯”ç‰¹** æ•°æ®)ï¼Œé€‚åˆå¤§æ•°æ®é‡çš„åŠ è§£å¯†å¤„ç†

#### 2.5.4.2 éå¯¹ç§°ç®—æ³•

1. **å¯†é’¥ç®¡ç†**ï¼šå¯†é’¥å®¹æ˜“ç®¡ç†
2. **å®‰å…¨æ€§**ï¼šé«˜
3. **åŠ å¯†é€Ÿåº¦**ï¼šæ¯”è¾ƒæ…¢ï¼Œé€‚åˆ **å°æ•°æ®é‡** åŠ è§£å¯†æˆ–æ•°æ®ç­¾å

# 3. å°ç»“

æœ¬æ–‡ä»‹ç»äº† **æ•°å­—ç­¾å**ï¼Œ**åŠ å¯†å’Œè§£å¯†**ï¼Œ**å¯¹ç§°åŠ å¯†å’Œéå¯¹ç§°åŠ å¯†**ï¼Œç„¶åè¯¦ç»†ä»‹ç»äº† `MD5`ï¼Œ`SHA-1`ï¼Œ`HMAC`ï¼Œ`DES/AES`ï¼Œ`RSA` å’Œ `ECC` è¿™å‡ ç§åŠ å¯†ç®—æ³•å’Œä»£ç ç¤ºä¾‹ã€‚