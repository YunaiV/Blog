title: Java 8 å‡½æ•°å¼ç¼–ç¨‹æ¢ç§˜
date: 2018-12-02
tags:
categories: ç²¾è¿›
permalink: Fight/Exploration-of-functional-programming-in-Java-8
author: ç´æ°´ç‰
from_url: http://www.cnblogs.com/lovesqcc/p/7965387.html
wechat_url: https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247485769&idx=1&sn=545ce2787bf4b4689e3aaf5ae70b6747&chksm=fa4976f8cd3effee455167b9e1a1c665d9c50185c464196a83ddebe3e507effdb009810605ba&token=582518212&lang=zh_CN#rd

-------

æ‘˜è¦: åŸåˆ›å‡ºå¤„ http://www.cnblogs.com/lovesqcc/p/7965387.html ã€Œç´æ°´ç‰ã€æ¬¢è¿è½¬è½½ï¼Œä¿ç•™æ‘˜è¦ï¼Œè°¢è°¢ï¼

- [å¼•å­](http://www.iocoder.cn/Fight/Exploration-of-functional-programming-in-Java-8/)
  - [å°†è¡Œä¸ºä½œä¸ºæ•°æ®ä¼ é€’](http://www.iocoder.cn/Fight/Exploration-of-functional-programming-in-Java-8/)
- [Java8å‡½æ•°æ¡†æ¶è§£è¯»](http://www.iocoder.cn/Fight/Exploration-of-functional-programming-in-Java-8/)
  - [å‡½æ•°æ¥å£](http://www.iocoder.cn/Fight/Exploration-of-functional-programming-in-Java-8/)
  - [èšåˆå™¨](http://www.iocoder.cn/Fight/Exploration-of-functional-programming-in-Java-8/)
  - [æµ](http://www.iocoder.cn/Fight/Exploration-of-functional-programming-in-Java-8/)
- [å‡½æ•°å¼ç¼–ç¨‹çš„ç›Šå¤„](http://www.iocoder.cn/Fight/Exploration-of-functional-programming-in-Java-8/)
- [Java8æ³›å‹](http://www.iocoder.cn/Fight/Exploration-of-functional-programming-in-Java-8/)
- [å®Œæ•´ä»£ç ç¤ºä¾‹](http://www.iocoder.cn/Fight/Exploration-of-functional-programming-in-Java-8/)
- [å°ç»“](http://www.iocoder.cn/Fight/Exploration-of-functional-programming-in-Java-8/)

-------

![](http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg)

> ğŸ™‚ğŸ™‚ğŸ™‚å…³æ³¨**å¾®ä¿¡å…¬ä¼—å·ï¼šã€èŠ‹é“æºç ã€‘**æœ‰ç¦åˆ©ï¼š
> 1. RocketMQ / MyCAT / Sharding-JDBC **æ‰€æœ‰**æºç åˆ†ææ–‡ç« åˆ—è¡¨
> 2. RocketMQ / MyCAT / Sharding-JDBC **ä¸­æ–‡æ³¨é‡Šæºç  GitHub åœ°å€**
> 3. æ‚¨å¯¹äºæºç çš„ç–‘é—®æ¯æ¡ç•™è¨€**éƒ½**å°†å¾—åˆ°**è®¤çœŸ**å›å¤ã€‚**ç”šè‡³ä¸çŸ¥é“å¦‚ä½•è¯»æºç ä¹Ÿå¯ä»¥è¯·æ•™å™¢**ã€‚
> 4. **æ–°çš„**æºç è§£ææ–‡ç« **å®æ—¶**æ”¶åˆ°é€šçŸ¥ã€‚**æ¯å‘¨æ›´æ–°ä¸€ç¯‡å·¦å³**ã€‚
> 5. **è®¤çœŸçš„**æºç äº¤æµå¾®ä¿¡ç¾¤ã€‚

-------

# å¼•å­

## å°†è¡Œä¸ºä½œä¸ºæ•°æ®ä¼ é€’

æ€æ ·åœ¨ä¸€è¡Œä»£ç é‡ŒåŒæ—¶è®¡ç®—ä¸€ä¸ªåˆ—è¡¨çš„å’Œã€æœ€å¤§å€¼ã€æœ€å°å€¼ã€å¹³å‡å€¼ã€å…ƒç´ ä¸ªæ•°ã€å¥‡å¶åˆ†ç»„ã€æŒ‡æ•°ã€æ’åºå‘¢ï¼Ÿ

ç­”æ¡ˆæ˜¯æ€ç»´åè½¬ï¼å°†è¡Œä¸ºä½œä¸ºæ•°æ®ä¼ é€’ã€‚ æ–‡è‰ºé’å¹´çš„ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š

```Java
public class FunctionUtil {

   public static <T,R> List<R> multiGetResult(List<Function<List<T>, R>> functions, List<T> list) {
     return functions.stream().map(f -> f.apply(list)).collect(Collectors.toList());
   }

   public static void main(String[] args) {
     System.out.println(multiGetResult(
         Arrays.asList(
             list -> list.stream().collect(Collectors.summarizingInt(x->x)),
             list -> list.stream().filter(x -> x < 50).sorted().collect(Collectors.toList()),
             list -> list.stream().collect(Collectors.groupingBy(x->(x%2==0? "even": "odd"))),
             list -> list.stream().sorted().collect(Collectors.toList()),
             list -> list.stream().sorted().map(Math::sqrt).collect(Collectors.toMap(x->x, y->Math.pow(2,y)))),
         Arrays.asList(64,49,25,16,9,4,1,81,36)));
   }
}
```

å‘ƒï¼Œæœ‰ç‚¹å–å¼„å°èªæ˜ã€‚ ä¸è¿‡è¦æ˜¯èƒ½å°†è¡Œä¸ºä½œä¸ºæ•°æ®è‡ªç”±ä¼ é€’å’Œæ–½åŠ äºæ•°æ®é›†äº§ç”Ÿç»“æœï¼Œé‚£ä¹ˆå…¶ä»£ç è¡¨è¾¾èƒ½åŠ›å°†å¦‚åº„å­ä¹‹è¨€ï¼Œæ£æ„æ½‡æ´’è€Œæ— æ‰€æé™ã€‚

> è¡Œä¸ºå°±æ˜¯æ•°æ®ã€‚

# Java8å‡½æ•°æ¡†æ¶è§£è¯»

**å‡½æ•°ç¼–ç¨‹çš„æœ€ç›´æ¥çš„è¡¨ç°ï¼Œè«è¿‡äºå°†å‡½æ•°ä½œä¸ºæ•°æ®è‡ªç”±ä¼ é€’ï¼Œç»“åˆæ³›å‹æ¨å¯¼èƒ½åŠ›ï¼Œä½¿ä»£ç è¡¨è¾¾èƒ½åŠ›è·å¾—é£ä¸€èˆ¬çš„æå‡**ã€‚é‚£ä¹ˆï¼ŒJava8æ˜¯æ€ä¹ˆæ”¯æŒå‡½æ•°ç¼–ç¨‹çš„å‘¢ï¼Ÿä¸»è¦æœ‰ä¸‰ä¸ªæ ¸å¿ƒæ¦‚å¿µï¼š

- å‡½æ•°æ¥å£(Function)
- æµ(Stream)
- èšåˆå™¨(Collector)

## å‡½æ•°æ¥å£

å…³äºå‡½æ•°æ¥å£ï¼Œéœ€è¦è®°ä½çš„å°±æ˜¯ä¸¤ä»¶äº‹ï¼š

- å‡½æ•°æ¥å£æ˜¯**è¡Œä¸ºçš„æŠ½è±¡**ï¼›
- å‡½æ•°æ¥å£æ˜¯**æ•°æ®è½¬æ¢å™¨**ã€‚

æœ€ç›´æ¥çš„æ”¯æŒå°±æ˜¯ java.util.Function åŒ…ã€‚å®šä¹‰äº†å››ä¸ªæœ€åŸºç¡€çš„å‡½æ•°æ¥å£ï¼š

- Supplier<T>: æ•°æ®æä¾›å™¨ï¼Œå¯ä»¥æä¾› T ç±»å‹å¯¹è±¡ï¼›æ— å‚çš„æ„é€ å™¨ï¼Œæä¾›äº† get æ–¹æ³•ï¼›
- Function<T,R>: æ•°æ®è½¬æ¢å™¨ï¼Œæ¥æ”¶ä¸€ä¸ª T ç±»å‹çš„å¯¹è±¡ï¼Œè¿”å›ä¸€ä¸ª Rç±»å‹çš„å¯¹è±¡ï¼› å•å‚æ•°å•è¿”å›å€¼çš„è¡Œä¸ºæ¥å£ï¼›æä¾›äº† apply, compose, andThen, identity æ–¹æ³•ï¼›
- Consumer<T>: æ•°æ®æ¶ˆè´¹å™¨ï¼Œ æ¥æ”¶ä¸€ä¸ª Tç±»å‹çš„å¯¹è±¡ï¼Œæ— è¿”å›å€¼ï¼Œé€šå¸¸ç”¨äºæ ¹æ®Tå¯¹è±¡åšäº›å¤„ç†ï¼› å•å‚æ•°æ— è¿”å›å€¼çš„è¡Œä¸ºæ¥å£ï¼›æä¾›äº† accept, andThen æ–¹æ³•ï¼›
- Predicate<T>: æ¡ä»¶æµ‹è¯•å™¨ï¼Œæ¥æ”¶ä¸€ä¸ª T ç±»å‹çš„å¯¹è±¡ï¼Œè¿”å›å¸ƒå°”å€¼ï¼Œé€šå¸¸ç”¨äºä¼ é€’æ¡ä»¶å‡½æ•°ï¼› å•å‚æ•°å¸ƒå°”å€¼çš„æ¡ä»¶æ€§æ¥å£ã€‚æä¾›äº† test (æ¡ä»¶æµ‹è¯•) , and-or- negate(ä¸æˆ–é) æ–¹æ³•ã€‚

å…¶ä¸­, compose, andThen, and, or, negate ç”¨æ¥ç»„åˆå‡½æ•°æ¥å£è€Œå¾—åˆ°æ›´å¼ºå¤§çš„å‡½æ•°æ¥å£ã€‚

å…¶å®ƒçš„å‡½æ•°æ¥å£éƒ½æ˜¯é€šè¿‡è¿™å››ä¸ªæ‰©å±•è€Œæ¥ã€‚

- åœ¨å‚æ•°ä¸ªæ•°ä¸Šæ‰©å±•ï¼š æ¯”å¦‚æ¥æ”¶åŒå‚æ•°çš„ï¼Œæœ‰ Bi å‰ç¼€ï¼Œ æ¯”å¦‚ BiConsumer<T,U>, BiFunction<T,U,R> ;
- åœ¨ç±»å‹ä¸Šæ‰©å±•ï¼š æ¯”å¦‚æ¥æ”¶åŸå­ç±»å‹å‚æ•°çš„ï¼Œæœ‰ [Int|Double|Long][Function|Consumer|Supplier|Predicate]
- ç‰¹æ®Šå¸¸ç”¨çš„å˜å½¢ï¼š æ¯”å¦‚ BinaryOperator ï¼Œ æ˜¯åŒç±»å‹çš„åŒå‚æ•° BiFunction<T,T,T> ï¼ŒäºŒå…ƒæ“ä½œç¬¦ ï¼› UnaryOperator æ˜¯ Function<T,T> ä¸€å…ƒæ“ä½œç¬¦ã€‚

é‚£ä¹ˆï¼Œè¿™äº›å‡½æ•°æ¥å£å¯ä»¥æ¥æ”¶å“ªäº›å€¼å‘¢ï¼Ÿ

- ç±»/å¯¹è±¡çš„é™æ€æ–¹æ³•å¼•ç”¨ã€å®ä¾‹æ–¹æ³•å¼•ç”¨ã€‚å¼•ç”¨ç¬¦å·ä¸ºåŒå†’å· ::
- ç±»çš„æ„é€ å™¨å¼•ç”¨ï¼Œæ¯”å¦‚ Class::new
- lambdaè¡¨è¾¾å¼

åœ¨åšæ–‡â€œ[ä½¿ç”¨å‡½æ•°æ¥å£å’Œæšä¸¾å®ç°é…ç½®å¼ç¼–ç¨‹(Javaä¸Scalaå®ç°)](http://www.cnblogs.com/lovesqcc/p/6649018.html)â€, â€œ[ç²¾ç»ƒä»£ç ï¼šä¸€æ¬¡Javaå‡½æ•°å¼ç¼–ç¨‹çš„é‡æ„ä¹‹æ—…](http://www.cnblogs.com/lovesqcc/p/7077971.html)â€ ç»™å‡ºäº†åŸºæœ¬çš„ä¾‹å­ã€‚åé¢è¿˜æœ‰æ›´å¤šä¾‹å­ã€‚é‡åœ¨ç»ƒä¹ å’Œå°è¯•ã€‚

## èšåˆå™¨

å…ˆè¯´èšåˆå™¨ã€‚æ¯ä¸€ä¸ªæµå¼è®¡ç®—çš„æœ«å°¾æ€»æœ‰ä¸€ä¸ªç±»ä¼¼ collect(Collectors.toList()) çš„æ–¹æ³•è°ƒç”¨ã€‚collect æ˜¯ Stream çš„æ–¹æ³•ï¼Œè€Œå‚æ•°åˆ™æ˜¯èšåˆå™¨Collectorã€‚å·²æœ‰çš„èšåˆå™¨å®šä¹‰åœ¨Collectors çš„é™æ€æ–¹æ³•é‡Œã€‚ é‚£ä¹ˆè¿™ä¸ªèšåˆå™¨æ˜¯æ€ä¹ˆå®ç°çš„å‘¢ï¼Ÿ

### Reduce

å¤§éƒ¨åˆ†èšåˆå™¨éƒ½æ˜¯åŸºäº Reduce æ“ä½œå®ç°çš„ã€‚ Reduce ï¼Œåæ›°æ¨å¯¼ï¼Œå«æœ‰ä¸‰ä¸ªè¦ç´ ï¼š åˆå§‹å€¼ init, äºŒå…ƒæ“ä½œç¬¦ BinaryOperator, ä»¥åŠä¸€ä¸ªç”¨äºèšåˆç»“æœçš„æ•°æ®æºSã€‚

Reduce çš„ç®—æ³•å¦‚ä¸‹ï¼š

STEP1: åˆå§‹åŒ–ç»“æœ R = init ï¼›

STEP2: æ¯æ¬¡ä» S ä¸­å–å‡ºä¸€ä¸ªå€¼ vï¼Œé€šè¿‡äºŒå…ƒæ“ä½œç¬¦æ–½åŠ åˆ° R å’Œ v ï¼Œäº§ç”Ÿä¸€ä¸ªæ–°å€¼èµ‹ç»™ R = BinaryOperator(R, v)ï¼›é‡å¤ STEP2ï¼Œ ç›´åˆ° S ä¸­æ²¡æœ‰å€¼å¯å–ä¸ºæ­¢ã€‚

æ¯”å¦‚ä¸€ä¸ªåˆ—è¡¨æ±‚å’Œï¼ŒSum([1,2,3]) , é‚£ä¹ˆå®šä¹‰ä¸€ä¸ªåˆå§‹å€¼ 0 ä»¥åŠä¸€ä¸ªäºŒå…ƒåŠ æ³•æ“ä½œ BO = a + b ï¼Œé€šè¿‡ä¸‰æ­¥å®Œæˆ Reduce æ“ä½œï¼šstep1: R = 0; step2: v=1, R = 0+v = 1; step2: v=2, R = 1 + v = 3 ; step3: v = 3, R = 3 + v = 6ã€‚

### å››è¦ç´ 

ä¸€ä¸ªèšåˆå™¨çš„å®ç°ï¼Œé€šå¸¸éœ€è¦æä¾›å››è¦ç´ ï¼š

- ä¸€ä¸ªç»“æœå®¹å™¨çš„åˆå§‹å€¼æä¾›å™¨ supplier ï¼›
- ä¸€ä¸ªç”¨äºå°†æ¯æ¬¡äºŒå…ƒæ“ä½œçš„ä¸­é—´ç»“æœä¸ç»“æœå®¹å™¨çš„å€¼è¿›è¡Œæ“ä½œå¹¶é‡æ–°è®¾ç½®ç»“æœå®¹å™¨çš„ç´¯ç§¯å™¨ accumulator ï¼›
- ä¸€ä¸ªç”¨äºå¯¹Streamå…ƒç´ å’Œä¸­é—´ç»“æœè¿›è¡Œæ“ä½œçš„äºŒå…ƒæ“ä½œç¬¦ combiner ï¼›
- ä¸€ä¸ªç”¨äºå¯¹ç»“æœå®¹å™¨è¿›è¡Œæœ€ç»ˆèšåˆçš„è½¬æ¢å™¨ finisherï¼ˆå¯é€‰) ã€‚

Collectors.CollectorImpl çš„å®ç°å±•ç¤ºäº†è¿™ä¸€ç‚¹ï¼š

```Java
static class CollectorImpl<T, A, R> implements Collector<T, A, R> {
        private final Supplier<A> supplier;
        private final BiConsumer<A, T> accumulator;
        private final BinaryOperator<A> combiner;
        private final Function<A, R> finisher;
        private final Set<Characteristics> characteristics;

        CollectorImpl(Supplier<A> supplier,
                      BiConsumer<A, T> accumulator,
                      BinaryOperator<A> combiner,
                      Function<A,R> finisher,
                      Set<Characteristics> characteristics) {
            this.supplier = supplier;
            this.accumulator = accumulator;
            this.combiner = combiner;
            this.finisher = finisher;
            this.characteristics = characteristics;
        }
}
```

### åˆ—è¡¨ç±»èšåˆå™¨

åˆ—è¡¨ç±»èšåˆå™¨å®ç°ï¼ŒåŸºæœ¬æ˜¯åŸºäºReduce æ“ä½œå®Œæˆçš„ã€‚ çœ‹å¦‚ä¸‹ä»£ç ï¼š

```Java
public static <T>
    Collector<T, ?, List<T>> toList() {
        return new CollectorImpl<>((Supplier<List<T>>) ArrayList::new, List::add,
                                   (left, right) -> { left.addAll(right); return left; },
                                   CH_ID);
```

é¦–å…ˆä½¿ç”¨ ArrayList::new åˆ›é€ ä¸€ä¸ªç©ºåˆ—è¡¨ï¼› ç„¶å List:add å°†Streamç´¯ç§¯æ“ä½œçš„ä¸­é—´ç»“æœåŠ å…¥åˆ°è¿™ä¸ªåˆ—è¡¨ï¼›ç¬¬ä¸‰ä¸ªå‡½æ•°åˆ™å°†ä¸¤ä¸ªåˆ—è¡¨å…ƒç´ è¿›è¡Œåˆå¹¶æˆä¸€ä¸ªç»“æœåˆ—è¡¨ä¸­ã€‚ å°±æ˜¯è¿™ä¹ˆç®€å•ã€‚é›†åˆèšåˆå™¨ toSet(), å­—ç¬¦ä¸²è¿æ¥å™¨ joining()ï¼Œä»¥åŠåˆ—è¡¨æ±‚å’Œ(summingXXX)ã€æœ€å¤§(maxBy)ã€æœ€å°å€¼(minBy)ç­‰éƒ½æ˜¯è¿™ä¸ªå¥—è·¯ã€‚

### æ˜ å°„ç±»èšåˆå™¨

æ˜ å°„ç±»èšåˆå™¨åŸºäºMapåˆå¹¶æ¥å®Œæˆã€‚çœ‹è¿™æ®µä»£ç ï¼š

```Java
private static <K, V, M extends Map<K,V>>
    BinaryOperator<M> mapMerger(BinaryOperator<V> mergeFunction) {
        return (m1, m2) -> {
            for (Map.Entry<K,V> e : m2.entrySet())
                m1.merge(e.getKey(), e.getValue(), mergeFunction);
            return m1;
        };
    }
```

æ ¹æ®æŒ‡å®šçš„å€¼åˆå¹¶å‡½æ•° mergeFunction, è¿”å›ä¸€ä¸ªmapåˆå¹¶å™¨ï¼Œç”¨æ¥åˆå¹¶ä¸¤ä¸ªmapé‡Œç›¸åŒkeyçš„å€¼ã€‚mergeFunctionç”¨æ¥å¯¹ä¸¤ä¸ªmapä¸­ç›¸åŒkeyçš„å€¼è¿›è¡Œè¿ç®—å¾—åˆ°æ–°çš„valueå€¼ï¼Œå¦‚æœvalueå€¼ä¸ºnullï¼Œä¼šç§»é™¤ç›¸åº”çš„keyï¼Œå¦åˆ™ä½¿ç”¨valueå€¼ä½œä¸ºå¯¹åº”keyçš„å€¼ã€‚è¿™ä¸ªæ–¹æ³•æ˜¯ç§æœ‰çš„ï¼Œä¸»è¦ä¸ºæ”¯æ’‘ toMapï¼ŒgroupingBy è€Œç”Ÿã€‚

toMapçš„å®ç°å¾ˆç®€çŸ­ï¼Œå®é™…ä¸Šå°±æ˜¯å°†æŒ‡å®šstreamçš„æ¯ä¸ªå…ƒç´ åˆ†åˆ«ä½¿ç”¨ç»™å®šå‡½æ•°keyMapper, valueMapperè¿›è¡Œæ˜ å°„å¾—åˆ° newKey, newValueï¼Œä»è€Œå½¢æˆæ–°çš„Map[newKey,newValue] (1), å†ä½¿ç”¨mapMerger(mergeFunction) ç”Ÿæˆçš„ map åˆå¹¶å™¨å°†å…¶åˆå¹¶åˆ° mapSupplier (2)ã€‚å¦‚æœåªä¼  keyMapper, valueMapperï¼Œé‚£ä¹ˆå°±åªå¾—åˆ°ç»“æœ(1)ã€‚

```Java
public static <T, K, U, M extends Map<K, U>>
    Collector<T, ?, M> toMap(Function<? super T, ? extends K> keyMapper,
                                Function<? super T, ? extends U> valueMapper,
                                BinaryOperator<U> mergeFunction,
                                Supplier<M> mapSupplier) {
        BiConsumer<M, T> accumulator
                = (map, element) -> map.merge(keyMapper.apply(element),
                                              valueMapper.apply(element), mergeFunction);
        return new CollectorImpl<>(mapSupplier, accumulator, mapMerger(mergeFunction), CH_ID);
    }
```

toMap çš„ä¸€ä¸ªç¤ºä¾‹è§å¦‚ä¸‹ä»£ç ï¼š

```Java
     List<Integer> list = Arrays.asList(1,2,3,4,5);
     Supplier<Map<Integer,Integer>> mapSupplier = () -> list.stream().collect(Collectors.toMap(x->x, y-> y * y));

     Map<Integer, Integer> mapValueAdd = list.stream().collect(Collectors.toMap(x->x, y->y, (v1,v2) -> v1+v2, mapSupplier));
     System.out.println(mapValueAdd);
```

å°†ä¸€ä¸ª List è½¬æˆ map[1=1,2=2,3=3,4=4,5=5]ï¼Œç„¶åä¸å¦ä¸€ä¸ªmap[1=1,2=4,3=9,4=16,5=25]çš„ç›¸åŒkeyçš„valueè¿›è¡Œç›¸åŠ ã€‚æ³¨æ„åˆ°, toMap çš„æœ€åä¸€ä¸ªå‚æ•°æ˜¯ Supplier<Map> ï¼Œ æ˜¯ Map æä¾›å™¨ï¼Œè€Œä¸æ˜¯ Map å¯¹è±¡ã€‚å¦‚æœç”¨Mapå¯¹è±¡ï¼Œä¼šæŠ¥ no instances of type variables M exists so that conforms to Supplier<M>ã€‚ åœ¨å‡½æ•°å¼ç¼–ç¨‹çš„ä¸–ç•Œé‡Œï¼Œé€šå¸¸æ˜¯ç”¨å‡½æ•°æ¥è¡¨è¾¾å’Œç»„åˆçš„ã€‚

### è‡ªå®šä¹‰èšåˆå™¨

è®©æˆ‘ä»¬ä»¿ç…§ Collectors.toList() åšä¸€ä¸ªè‡ªå®šä¹‰çš„èšåˆå™¨ã€‚å®ç°ä¸€ä¸ªå«Nä¸ªæ•°çš„æ–æ³¢é‚£å¥‘åºåˆ— List<Integer>ã€‚ç”±äº Reduce æ¯æ¬¡éƒ½ä»æµä¸­å–ä¸€ä¸ªæ•°ï¼Œå› æ­¤éœ€è¦ç”Ÿäº§ä¸€ä¸ªå«Nä¸ªæ•°çš„streamï¼›å¯ä½¿ç”¨ Arrays.asList(1,2,3,4,5,6,7,8,9,10).stream() ï¼Œ äº¦å¯ä½¿ç”¨ IntStream.range(1,11) ï¼Œä¸è¿‡ä¸¤è€…çš„ collector æ–¹æ³•æ˜¯ä¸ä¸€æ ·çš„ã€‚è¿™é‡Œæˆ‘ä»¬å–å‰è€…ã€‚

ç°åœ¨ï¼Œéœ€è¦æ„é€ å››è¦ç´ ï¼š

- å¯å˜çš„ç»“æœå®¹å™¨æä¾›å™¨ Supplier<List<Integer>> = () -> [0, 1] ï¼› æ³¨æ„è¿™é‡Œä¸èƒ½ä½¿ç”¨ Arrays.asList , å› ä¸ºè¯¥æ–¹æ³•ç”Ÿæˆçš„åˆ—è¡¨æ˜¯ä¸å¯å˜çš„ã€‚
- ç´¯ç§¯å™¨ BiConsumer<List<Integer>, Integer> accumulator()ï¼š è¿™é‡Œæµçš„å…ƒç´ æœªç”¨ï¼Œä»…ä»…ç”¨æ¥ä½¿è®¡ç®—è¿›è¡Œå’Œç»ˆæ­¢ã€‚æ–°çš„å…ƒç´ ä»ç»“æœå®¹å™¨ä¸­å–æœ€åä¸¤ä¸ªç›¸åŠ åäº§ç”Ÿæ–°çš„ç»“æœæ”¾åˆ°ç»“æœå®¹å™¨ä¸­ã€‚
- ç»„åˆå™¨ BinaryOperator<List<Integer>> combiner() ï¼š ç…§è‘«èŠ¦ç”»ç“¢ï¼Œç›®å‰æ²¡çœ‹å‡ºè¿™æ­¥æ˜¯åšä»€ä¹ˆç”¨ï¼›ç›´æ¥ return null; ä¹Ÿæ˜¯OKçš„ã€‚
- æœ€ç»ˆè½¬æ¢å™¨ Function<List<Integer>, List<Integer>> finisher() ï¼šåœ¨æœ€ç»ˆè½¬æ¢å™¨ä¸­ï¼Œç§»é™¤åˆå§‹è®¾ç½®çš„ä¸¤ä¸ªå€¼ 0, 1 ã€‚

ä»£ç å¦‚ä¸‹ï¼š

```Java
/**
 * Created by shuqin on 17/12/5.
 */
public class FiboCollector implements Collector<Integer, List<Integer>, List<Integer>> {

  public Supplier<List<Integer>> supplier() {
    return () -> {
      List<Integer> result = new ArrayList<>();
      result.add(0); result.add(1);
      return result;
    };
  }

  @Override
  public BiConsumer<List<Integer>, Integer> accumulator() {
    return (res, num) -> {
      Integer next = res.get(res.size()-1) + res.get(res.size()-2);
      res.add(next);
    };
  }

  @Override
  public BinaryOperator<List<Integer>> combiner() {
    return null;
    //return (left, right) -> { left.addAll(right); return left; };
  }

  @Override
  public Function<List<Integer>, List<Integer>> finisher() {
    return res -> { res.remove(0); res.remove(1); return res; };
  }

  @Override
  public Set<Characteristics> characteristics() {
    return Collections.emptySet();
  }

}

List<Integer> fibo = Arrays.asList(1,2,3,4,5,6,7,8,9,10).stream().collect(new FiboCollector());
System.out.println(fibo);
```

## æµ

æµï¼ˆStreamï¼‰æ˜¯Java8å¯¹å‡½æ•°å¼ç¼–ç¨‹çš„é‡è¦æ”¯æ’‘ã€‚å¤§éƒ¨åˆ†å‡½æ•°å¼å·¥å…·éƒ½å›´ç»•Streamå±•å¼€ã€‚

### Streamçš„æ¥å£

Stream ä¸»è¦æœ‰å››ç±»æ¥å£ï¼š

- æµåˆ°æµä¹‹é—´çš„è½¬æ¢ï¼šæ¯”å¦‚ filter(è¿‡æ»¤), map(æ˜ å°„è½¬æ¢), mapTo[Int|Long|Double] (åˆ°åŸå­ç±»å‹æµçš„è½¬æ¢), flatMap(é«˜ç»´ç»“æ„å¹³é“º)ï¼ŒflatMapTo[Int|Long|Double], sorted(æ’åº)ï¼Œdistinct(ä¸é‡å¤å€¼)ï¼Œpeek(æ‰§è¡ŒæŸç§æ“ä½œï¼Œæµä¸å˜ï¼Œå¯ç”¨äºè°ƒè¯•)ï¼Œlimit(é™åˆ¶åˆ°æŒ‡å®šå…ƒç´ æ•°é‡), skip(è·³è¿‡è‹¥å¹²å…ƒç´ ) ï¼›
- æµåˆ°ç»ˆå€¼çš„è½¬æ¢ï¼š æ¯”å¦‚ toArrayï¼ˆè½¬ä¸ºæ•°ç»„ï¼‰ï¼Œreduceï¼ˆæ¨å¯¼ç»“æœï¼‰ï¼Œcollectï¼ˆèšåˆç»“æœï¼‰ï¼Œmin(æœ€å°å€¼), max(æœ€å¤§å€¼), count (å…ƒç´ ä¸ªæ•°)ï¼Œ anyMatch (ä»»ä¸€åŒ¹é…), allMatch(æ‰€æœ‰éƒ½åŒ¹é…)ï¼Œ noneMatch(ä¸€ä¸ªéƒ½ä¸åŒ¹é…)ï¼Œ findFirstï¼ˆé€‰æ‹©é¦–å…ƒç´ ï¼‰ï¼ŒfindAny(ä»»é€‰ä¸€å…ƒç´ ) ï¼›
- ç›´æ¥éå†ï¼š forEach (ä¸ä¿åºéå†ï¼Œæ¯”å¦‚å¹¶è¡Œæµ), forEachOrderedï¼ˆä¿åºéå†) ï¼›
- æ„é€ æµï¼š empty (æ„é€ ç©ºæµ)ï¼Œof (å•ä¸ªå…ƒç´ çš„æµåŠå¤šå…ƒç´ é¡ºåºæµ)ï¼Œiterate (æ— é™é•¿åº¦çš„æœ‰åºé¡ºåºæµ)ï¼Œgenerate (å°†æ•°æ®æä¾›å™¨è½¬æ¢æˆæ— é™éæœ‰åºçš„é¡ºåºæµ)ï¼Œ concat (æµçš„è¿æ¥)ï¼Œ Builder (ç”¨äºæ„é€ æµçš„Builderå¯¹è±¡)

é™¤äº† Stream æœ¬èº«è‡ªå¸¦çš„ç”ŸæˆStream çš„æ–¹æ³•ï¼Œæ•°ç»„å’Œå®¹å™¨åŠStreamSupportéƒ½æœ‰è½¬æ¢ä¸ºæµçš„æ–¹æ³•ã€‚æ¯”å¦‚ Arrays.stream , [List|Set|Collection].[stream|parallelStream] , StreamSupport.[int|long|double|]streamï¼›

æµçš„ç±»å‹ä¸»è¦æœ‰ï¼šReference(å¯¹è±¡æµ)ï¼Œ IntStream (intå…ƒç´ æµ), LongStream (longå…ƒç´ æµ)ï¼Œ Double (doubleå…ƒç´ æµ) ï¼Œå®šä¹‰åœ¨ç±» StreamShape ä¸­ï¼Œä¸»è¦å°†æ“ä½œé€‚é…äºç±»å‹ç³»ç»Ÿã€‚

flatMap çš„ä¸€ä¸ªä¾‹å­è§å¦‚ä¸‹æ‰€ç¤ºï¼Œå°†ä¸€ä¸ªäºŒç»´æ•°ç»„è½¬æ¢ä¸ºä¸€ç»´æ•°ç»„ï¼š

```Java
     List<Integer> nums = Arrays.asList(Arrays.asList(1,2,3), Arrays.asList(1,4,9), Arrays.asList(1,8,27))
                                .stream().flatMap(x -> x.stream()).collect(Collectors.toList());
     System.out.println(nums);
```

### collectorå®ç°

è¿™é‡Œæˆ‘ä»¬ä»…åˆ†æä¸²è¡Œæ˜¯æ€ä¹ˆå®ç°çš„ã€‚å…¥å£åœ¨ç±» java.util.stream.ReferencePipeline çš„ collect æ–¹æ³•ï¼š

```Java
container = evaluate(ReduceOps.makeRef(collector));
return collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)
          ? (R) container : collector.finisher().apply(container);
```

è¿™é‡Œçš„å…³é”®æ˜¯ ReduceOps.makeRef(collector)ã€‚ ç‚¹è¿›å»ï¼š

```Java
public static <T, I> TerminalOp<T, I>
    makeRef(Collector<? super T, I, ?> collector) {
        Supplier<I> supplier = Objects.requireNonNull(collector).supplier();
        BiConsumer<I, ? super T> accumulator = collector.accumulator();
        BinaryOperator<I> combiner = collector.combiner();
        class ReducingSink extends Box<I>
                implements AccumulatingSink<T, I, ReducingSink> {
            @Override
            public void begin(long size) {
                state = supplier.get();
            }

            @Override
            public void accept(T t) {
                accumulator.accept(state, t);
            }

            @Override
            public void combine(ReducingSink other) {
                state = combiner.apply(state, other.state);
            }
        }
        return new ReduceOp<T, I, ReducingSink>(StreamShape.REFERENCE) {
            @Override
            public ReducingSink makeSink() {
                return new ReducingSink();
            }

            @Override
            public int getOpFlags() {
                return collector.characteristics().contains(Collector.Characteristics.UNORDERED)
                       ? StreamOpFlag.NOT_ORDERED
                       : 0;
            }
        };
    }

private static abstract class Box<U> {
        U state;

        Box() {} // Avoid creation of special accessor

        public U get() {
            return state;
        }
    }
```

Box æ˜¯ä¸€ä¸ªç»“æœå€¼çš„æŒæœ‰è€…ï¼› ReducingSink ç”¨begin, accept, combine ä¸‰ä¸ªæ–¹æ³•å®šä¹‰äº†è¦è¿›è¡Œçš„è®¡ç®—ï¼›ReducingSinkæ˜¯æœ‰çŠ¶æ€çš„æµæ•°æ®æ¶ˆè´¹çš„è®¡ç®—æŠ½è±¡ï¼Œé˜…è¯»Sinkæ¥å£æ–‡æ¡£å¯çŸ¥ã€‚ReduceOps.makeRef(collector) è¿”å›äº†ä¸€ä¸ªå°è£…äº†Reduceæ“ä½œçš„ReduceOpså¯¹è±¡ã€‚æ³¨æ„åˆ°ï¼Œè¿™é‡Œéƒ½æ˜¯å£°æ˜è¦æ‰§è¡Œçš„è®¡ç®—ï¼Œè€Œä¸æ¶‰åŠè®¡ç®—çš„å®é™…è¿‡ç¨‹ã€‚å±•ç¤ºäº†**è¡¨è¾¾ä¸æ‰§è¡Œåˆ†ç¦»**çš„æ€æƒ³ã€‚çœŸæ­£çš„è®¡ç®—è¿‡ç¨‹å¯åŠ¨åœ¨ ReferencePipeline.evaluate æ–¹æ³•é‡Œ:

```Java
final <R> R evaluate(TerminalOp<E_OUT, R> terminalOp) {
        assert getOutputShape() == terminalOp.inputShape();
        if (linkedOrConsumed)
            throw new IllegalStateException(MSG_STREAM_LINKED);
        linkedOrConsumed = true;

        return isParallel()
               ? terminalOp.evaluateParallel(this, sourceSpliterator(terminalOp.getOpFlags()))
               : terminalOp.evaluateSequential(this, sourceSpliterator(terminalOp.getOpFlags()));
    }
```

ä½¿ç”¨ IDE çš„ go to implementations åŠŸèƒ½ï¼Œ è·Ÿè¿›å»ï¼Œå¯ä»¥å‘ç°ï¼Œæœ€ç»ˆåœ¨ AbstractPipeLine ä¸­å®šä¹‰äº†ï¼š

```Java
@Override
    final <P_IN> void copyInto(Sink<P_IN> wrappedSink, Spliterator<P_IN> spliterator) {
        Objects.requireNonNull(wrappedSink);

        if (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) {
            wrappedSink.begin(spliterator.getExactSizeIfKnown());
            spliterator.forEachRemaining(wrappedSink);
            wrappedSink.end();
        }
        else {
            copyIntoWithCancel(wrappedSink, spliterator);
        }
    }
```

Spliterator ç”¨æ¥å¯¹æµä¸­çš„å…ƒç´ è¿›è¡Œåˆ†åŒºå’Œéå†ä»¥åŠæ–½åŠ SinkæŒ‡å®šæ“ä½œï¼Œå¯ä»¥ç”¨äºå¹¶å‘è®¡ç®—ã€‚Spliteratorçš„å…·ä½“å®ç°ç±»å®šä¹‰åœ¨ Spliterators çš„é™æ€ç±»å’Œé™æ€æ–¹æ³•ä¸­ã€‚å…¶ä¸­æœ‰ï¼š

```Java
æ•°ç»„Spliterator:
static final class ArraySpliterator<T> implements Spliterator<T>
static final class IntArraySpliterator implements Spliterator.OfInt
static final class LongArraySpliterator implements Spliterator.OfLong
static final class DoubleArraySpliterator implements Spliterator.OfDouble

è¿­ä»£Spliterator:
static class IteratorSpliterator<T> implements Spliterator<T>
static final class IntIteratorSpliterator implements Spliterator.OfInt
static final class LongIteratorSpliterator implements Spliterator.OfLong
static final class DoubleIteratorSpliterator implements Spliterator.OfDouble

æŠ½è±¡Spliterator:
public static abstract class AbstractSpliterator<T> implements Spliterator<T>
private static abstract class EmptySpliterator<T, S extends Spliterator<T>, C>
public static abstract class AbstractIntSpliterator implements Spliterator.OfInt
public static abstract class AbstractLongSpliterator implements Spliterator.OfLong
public static abstract class AbstractDoubleSpliterator implements Spliterator.OfDouble
```

æ¯ä¸ªå…·ä½“ç±»éƒ½å®ç°äº†trySplitï¼ŒforEachRemainingï¼ŒtryAdvanceï¼ŒestimateSizeï¼Œcharacteristicsï¼Œ getComparatorã€‚ trySplit ç”¨äºæ‹†åˆ†æµï¼Œæä¾›å¹¶å‘èƒ½åŠ›ï¼›forEachRemainingï¼ŒtryAdvance ç”¨äºéå†å’Œæ¶ˆè´¹æµä¸­çš„æ•°æ®ã€‚ä¸‹é¢å±•ç¤ºäº†IteratorSpliteratorçš„forEachRemainingï¼ŒtryAdvance ä¸¤ä¸ªæ–¹æ³•çš„å®ç°ã€‚å¯ä»¥çœ‹åˆ°ï¼Œæœ¨æœ‰ç‰¹åˆ«çš„åœ°æ–¹ï¼Œå°±æ˜¯éå†å…ƒç´ å¹¶å°†æŒ‡å®šæ“ä½œæ–½åŠ äºå…ƒç´ ã€‚

```Java
@Override
        public void forEachRemaining(Consumer<? super T> action) {
            if (action == null) throw new NullPointerException();
            Iterator<? extends T> i;
            if ((i = it) == null) {
                i = it = collection.iterator();
                est = (long)collection.size();
            }
            i.forEachRemaining(action);
        }

        @Override
        public boolean tryAdvance(Consumer<? super T> action) {
            if (action == null) throw new NullPointerException();
            if (it == null) {
                it = collection.iterator();
                est = (long) collection.size();
            }
            if (it.hasNext()) {
                action.accept(it.next());
                return true;
            }
            return false;
        }
```

æ•´ä½“æµç¨‹å°±æ˜¯è¿™æ ·ã€‚å›é¡¾ä¸€ä¸‹ï¼š

- Collector å®šä¹‰äº†å¿…è¦çš„èšåˆæ“ä½œå‡½æ•°ï¼›
- ReduceOps.makeRef å°† Collector å°è£…æˆä¸€ä¸ªè®¡ç®—å¯¹è±¡ ReduceOps ï¼Œä¾èµ–çš„ ReducingSink å®šä¹‰äº†å…·ä½“çš„æµæ•°æ®æ¶ˆè´¹è¿‡ç¨‹ï¼›
- Spliterator ç”¨äºå¯¹æµä¸­çš„å…ƒç´ è¿›è¡Œåˆ†åŒºå’Œéå†ä»¥åŠæ–½åŠ SinkæŒ‡å®šçš„æ“ä½œã€‚

### Pipeline

é‚£ä¹ˆï¼ŒSpliterator åˆæ˜¯ä»å“ªé‡Œæ¥çš„å‘¢ï¼Ÿæ˜¯é€šè¿‡ç±» java.util.stream.AbstractPipeline çš„æ–¹æ³• sourceSpliterator æ‹¿åˆ°çš„ï¼š

```Java
private Spliterator<?> sourceSpliterator(int terminalFlags) {
        // Get the source spliterator of the pipeline
        Spliterator<?> spliterator = null;
        if (sourceStage.sourceSpliterator != null) {
            spliterator = sourceStage.sourceSpliterator;
            sourceStage.sourceSpliterator = null;
        }
        else if (sourceStage.sourceSupplier != null) {
            spliterator = (Spliterator<?>) sourceStage.sourceSupplier.get();
            sourceStage.sourceSupplier = null;
        }
        else {
            throw new IllegalStateException(MSG_CONSUMED);
        }
        // code for isParallel
       return spliterator;
}
```

è¿™é‡Œçš„ sourceStage æ˜¯ä¸€ä¸ª AbstractPipelineã€‚ Pipeline æ˜¯å®ç°æµå¼è®¡ç®—çš„æµæ°´çº¿æŠ½è±¡ï¼Œä¹Ÿæ˜¯Streamçš„å®ç°ç±»ã€‚å¯ä»¥çœ‹åˆ°ï¼Œjava.util.stream å®šä¹‰äº†å››ç§ pipeline: DoublePipeline, IntPipeline, LongPipeline, ReferencePipelineã€‚å¯ä»¥é‡ç‚¹çœ‹ ReferencePipeline çš„å®ç°ã€‚æ¯”å¦‚ filter, map

```Java
abstract class ReferencePipeline<P_IN, P_OUT>
        extends AbstractPipeline<P_IN, P_OUT, Stream<P_OUT>>
        implements Stream<P_OUT>

@Override
    public final Stream<P_OUT> filter(Predicate<? super P_OUT> predicate) {
        Objects.requireNonNull(predicate);
        return new StatelessOp<P_OUT, P_OUT>(this, StreamShape.REFERENCE,
                                     StreamOpFlag.NOT_SIZED) {
            @Override
            Sink<P_OUT> opWrapSink(int flags, Sink<P_OUT> sink) {
                return new Sink.ChainedReference<P_OUT, P_OUT>(sink) {
                    @Override
                    public void begin(long size) {
                        downstream.begin(-1);
                    }

                    @Override
                    public void accept(P_OUT u) {
                        if (predicate.test(u))
                            downstream.accept(u);
                    }
                };
            }
        };
    }

    @Override
    @SuppressWarnings("unchecked")
    public final <R> Stream<R> map(Function<? super P_OUT, ? extends R> mapper) {
        Objects.requireNonNull(mapper);
        return new StatelessOp<P_OUT, R>(this, StreamShape.REFERENCE,
                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
            @Override
            Sink<P_OUT> opWrapSink(int flags, Sink<R> sink) {
                return new Sink.ChainedReference<P_OUT, R>(sink) {
                    @Override
                    public void accept(P_OUT u) {
                        downstream.accept(mapper.apply(u));
                    }
                };
            }
        };
    }
```

å¥—è·¯åŸºæœ¬ä¸€æ ·ï¼Œå…³é”®ç‚¹åœ¨äº accept æ–¹æ³•ã€‚filter åªåœ¨æ»¡è¶³æ¡ä»¶æ—¶å°†å€¼ä¼ ç»™ä¸‹ä¸€ä¸ª pipeline, è€Œ map å°†è®¡ç®—çš„å€¼ä¼ ç»™ä¸‹ä¸€ä¸ª pipeline. StatelessOp æ²¡æœ‰ä»€ä¹ˆé€»è¾‘ï¼ŒJDKæ–‡æ¡£è§£é‡Šæ˜¯ï¼šBase class for a stateless intermediate stage of a Streamã€‚ç›¸åº”è¿˜æœ‰ä¸€ä¸ª StatefulOp, Headã€‚ è¿™äº›éƒ½æ˜¯ ReferencePipeline ï¼Œè´Ÿè´£å°†å€¼åœ¨ pipeline ä¹‹é—´ä¼ é€’ï¼Œäº¤ç»™ Sink å»è®¡ç®—ã€‚

```Java
static class Head<E_IN, E_OUT> extends ReferencePipeline<E_IN, E_OUT>
abstract static class StatelessOp<E_IN, E_OUT> extends ReferencePipeline<E_IN, E_OUT>
abstract static class StatefulOp<E_IN, E_OUT> extends ReferencePipeline<E_IN, E_OUT>
```

è‡³æ­¤ï¼Œæˆ‘ä»¬å¯¹æ•´ä¸ªæµè®¡ç®—è¿‡ç¨‹æœ‰äº†æ›´æ¸…æ™°çš„è®¤è¯†ã€‚ ç»†èŠ‚å¯ä»¥å†é€æ­¥æ¨æ•²ã€‚

# å‡½æ•°å¼ç¼–ç¨‹çš„ç›Šå¤„

### æ›´ç²¾ç»ƒçš„ä»£ç 

å‡½æ•°ç¼–ç¨‹çš„ä¸€å¤§ç›Šå¤„ï¼Œæ˜¯ç”¨æ›´ç²¾ç»ƒçš„ä»£ç è¡¨è¾¾å¸¸ç”¨æ•°æ®å¤„ç†æ¨¡å¼ã€‚å‡½æ•°æ¥å£èƒ½å¤Ÿè½»æ˜“åœ°å®ç°æ¨¡æ¿æ–¹æ³•æ¨¡å¼ï¼Œåªè¦å°†ä¸ç¡®å®šçš„ä¸šåŠ¡é€»è¾‘æŠ½è±¡æˆå‡½æ•°æ¥å£ï¼Œç„¶åä¼ å…¥ä¸åŒçš„lambdaè¡¨è¾¾å¼å³å¯ã€‚åšæ–‡[â€œç²¾ç»ƒä»£ç ï¼šä¸€æ¬¡Javaå‡½æ•°å¼ç¼–ç¨‹çš„é‡æ„ä¹‹æ—…â€](http://www.cnblogs.com/lovesqcc/p/7077971.html) å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨å‡½æ•°å¼ç¼–ç¨‹æ¥é‡æ„å¸¸è§ä»£ç ï¼Œèƒå–æ›´å¤šå¯å¤ç”¨çš„ä»£ç æ¨¡å¼ã€‚

è¿™é‡Œç»™å‡ºä¸€ä¸ªåˆ—è¡¨åˆ†ç»„çš„ä¾‹å­ã€‚å®é™…åº”ç”¨å¸¸å¸¸éœ€è¦å°†ä¸€ä¸ªåˆ—è¡¨ List[T] è½¬æ¢ä¸ºä¸€ä¸ª Map[K, List[T]] ï¼Œ å…¶ä¸­ K æ˜¯é€šè¿‡æŸä¸ªå‡½æ•°æ¥å®ç°çš„ã€‚ çœ‹ä¸‹é¢ä¸€æ®µä»£ç ï¼š

```Java
public static Map<String, List<OneRecord>> buildRecordMap(List<OneRecord> records, List<String> colKeys) {
    Map<String, List<OneRecord>> recordMap = new HashMap<>();
    records.forEach(
        record -> {
          String recordKey = buildRecordKey(record.getFieldValues(), colKeys);
          if (recordMap.get(recordKey) == null) {
            recordMap.put(recordKey, new ArrayList<OneRecord>());
          }
          recordMap.get(recordKey).add(record);
    });
    return recordMap;
  }
```

å¯ä»¥ä½¿ç”¨ Collectors.groupingby æ¥ç®€æ´åœ°å®ç°ï¼š

```Java
public static Map<String, List<OneRecord>> buildRecordMapBrief(List<OneRecord> records, List<String> colKeys) {
    return records.stream().collect(Collectors.groupingBy(
        record -> buildRecordKey(record.getFieldValues(), colKeys)
    ));
  }
```

> å¾ˆå¤šå¸¸ç”¨æ•°æ®å¤„ç†ç®—æ³•ï¼Œéƒ½å¯ä»¥ä½¿ç”¨å‡½æ•°å¼ç¼–ç¨‹çš„æµå¼è®¡ç®—ç®€æ´è¡¨è¾¾ã€‚

### æ›´é€šç”¨çš„ä»£ç 

ä½¿ç”¨å‡½æ•°æ¥å£ï¼Œç»“åˆæ³›å‹ï¼Œå¾ˆå®¹æ˜“ç”¨ç²¾ç»ƒçš„ä»£ç ï¼Œå†™å‡ºéå¸¸é€šç”¨çš„å·¥å…·æ–¹æ³•ã€‚ å®é™…åº”ç”¨ä¸­ï¼Œå¸¸å¸¸ä¼šæœ‰è¿™æ ·çš„éœ€æ±‚ï¼š æœ‰ä¸¤ä¸ªå¯¹è±¡åˆ—è¡¨srcListå’ŒdestListï¼Œä¸¤ä¸ªå¯¹è±¡ç±»å‹çš„æŸä¸ªå­—æ®µKå…·æœ‰ç›¸åŒçš„å€¼ï¼›éœ€è¦æ ¹æ®è¿™ä¸ªç›¸åŒçš„å€¼åˆå¹¶å¯¹åº”çš„ä¸¤ä¸ªå¯¹è±¡çš„ä¿¡æ¯ã€‚

è¿™é‡Œç»™å‡ºäº†ä¸€ä¸ªåˆ—è¡¨åˆå¹¶å‡½æ•°ï¼Œå¯ä»¥å°†ä¸€ä¸ªå¯¹è±¡åˆ—è¡¨åˆå¹¶åˆ°æŒ‡å®šçš„å¯¹è±¡åˆ—è¡¨ä¸­ã€‚å®ç°æ˜¯ï¼š å…ˆå°†å¾…åˆå¹¶çš„åˆ—è¡¨srcListæ ¹æ®keyå€¼å‡½æ•°keyFuncæ„å»ºèµ·srcMap,ç„¶åéå†deståˆ—è¡¨çš„å¯¹è±¡Rï¼Œå°†å¾…åˆå¹¶çš„ä¿¡æ¯srcMap[key]åŠTé€šè¿‡åˆå¹¶å‡½æ•°mergeFuncç”Ÿæˆçš„æ–°å¯¹è±¡Ræ·»åŠ åˆ°æœ€ç»ˆç»“æœåˆ—è¡¨ã€‚

```Java
  public static <K,R> List<R> mergeList(List<R> srcList, List<R> destList ,
                                        Function<R,K> keyFunc,
                                        BinaryOperator<R> mergeFunc) {
    return mergeList(srcList, destList, keyFunc, keyFunc, mergeFunc);
  }

  public static <T,S,K,R> List<R> mergeList(List<S> srcList, List<T> destList ,
                                            Function<S,K> skeyFunc, Function<T,K> dkeyFunc,
                                            BiFunction<S,T,R> mergeFunc) {

    Map<K,S> srcMap = srcList.stream().collect(Collectors.toMap(skeyFunc, s -> s, (k1,k2) -> k1));
    return destList.stream().map(
        dest -> {
          K key = dkeyFunc.apply(dest);
          S src = srcMap.get(key);
          return mergeFunc.apply(src, dest);
        }
    ).collect(Collectors.toList());

  }
```

### æ›´å¯æµ‹çš„ä»£ç 

ä½¿ç”¨å‡½æ•°æ¥å£å¯ä»¥æ–¹ä¾¿åœ°éš”ç¦»å¤–éƒ¨ä¾èµ–ï¼Œä½¿å¾—ç±»å’Œå¯¹è±¡çš„æ–¹æ³•æ›´çº¯ç²¹ã€æ›´å…·å¯æµ‹æ€§ã€‚åšæ–‡â€œ[ä½¿ç”¨Javaå‡½æ•°æ¥å£åŠlambdaè¡¨è¾¾å¼éš”ç¦»å’Œæ¨¡æ‹Ÿå¤–éƒ¨ä¾èµ–æ›´å®¹æ˜“æ»´å•æµ‹](http://www.cnblogs.com/lovesqcc/p/6917448.html)â€ï¼Œâ€œ[æ”¹å–„ä»£ç å¯æµ‹æ€§çš„è‹¥å¹²æŠ€å·§](http://www.cnblogs.com/lovesqcc/p/7898319.html)â€é›†ä¸­è®¨è®ºäº†å¦‚ä½•ä½¿ç”¨å‡½æ•°æ¥å£æå‡ä»£ç çš„å¯å•æµ‹æ€§ã€‚

### ç»„åˆçš„åŠ›é‡

å‡½æ•°ç¼–ç¨‹çš„å¼ºå¤§å¨åŠ›ï¼Œåœ¨äºå°†å‡½æ•°æ¥å£ç»„åˆèµ·æ¥ï¼Œæ„å»ºæ›´å¼ºå¤§æ›´å…·æœ‰é€šç”¨æ€§çš„å®ç”¨å·¥å…·æ–¹æ³•ã€‚**è¶…è¶Šç±»å‹ï¼Œè¶…è¶Šæ“ä½œä¸æ•°æ®çš„è¾¹ç•Œã€‚**

å‰é¢æåˆ°ï¼Œå‡½æ•°æ¥å£å°±æ˜¯æ•°æ®è½¬æ¢å™¨ã€‚æ¯”å¦‚Function<T,R> å°±æ˜¯â€œå°†Tå¯¹è±¡è½¬æ¢æˆRå¯¹è±¡çš„è¡Œä¸ºæˆ–æ•°æ®è½¬æ¢å™¨â€ã€‚å¯¹äºå®é™…å·¥ç¨‹åº”ç”¨çš„æ™®é€šçº§å‡½æ•°ç¼–ç¨‹è¶³å¤Ÿäº†ã€‚ä¸è¿‡ï¼Œè¦ç©è½¬å‡½æ•°æ¥å£ï¼Œå°±è¦å‡çº§ä¸‹è®¤è¯†ã€‚ æ¯”å¦‚ Function<BiFunction<S,Q,R>, Function<T,R>> è¯¥æ€ä¹ˆç†è§£å‘¢ï¼Ÿè¿™æ˜¯â€œä¸€ä¸ªä¸€å…ƒå‡½æ•°g(h(s,q)) ï¼Œå‚æ•°æŒ‡å®šçš„äºŒå…ƒå‡½æ•°h(s,q)åº”ç”¨äºæŒ‡å®šçš„ä¸¤ä¸ªå‚æ•°S,Qï¼Œå¾—åˆ°ä¸€ä¸ªä¸€å…ƒå‡½æ•°f(t)ï¼Œè¿™ä¸ªå‡½æ•°æ¥æ”¶ä¸€ä¸ªTå¯¹è±¡ï¼Œè¿”å›ä¸€ä¸ªRå¯¹è±¡â€ã€‚ å¦‚ä¸‹ä»£ç æ‰€ç¤ºï¼š

```Java
  public static <T,S,Q,R> Function<BiFunction<S,Q,R>, Function<T,R>> op(Function<T,S> funcx, Function<T,Q> funcy) {
    return opFunc -> aT -> opFunc.apply(funcx.apply(aT), funcy.apply(aT));
  }

  System.out.println(op(x-> x.toString().length(), y-> y+",world").apply((x,y) -> x+" " +y).apply("hello"));
```

å®ç°çš„æ˜¯ h(t) = h(funx(t), funy(t)) ï¼Œh(x,y) æ˜¯ä¸€ä¸ªåŒå‚æ•°å‡½æ•°ã€‚

[â€œJavaå‡½æ•°æ¥å£å®ç°å‡½æ•°ç»„åˆåŠè£…é¥°å™¨æ¨¡å¼â€](http://www.cnblogs.com/lovesqcc/p/7107558.html) å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨æå°‘é‡çš„ä»£ç å®ç°è£…é¥°å™¨æ¨¡å¼ï¼Œå°†ç®€å•çš„å‡½æ•°æ¥å£ç»„åˆæˆæ›´å¼ºå¤§åŠŸèƒ½çš„å¤åˆå‡½æ•°æ¥å£ã€‚

æ¥çœ‹ä¸Šé¢çš„ `public static <T,S,K,R> List<R> mergeList(List<S> srcList, List<T> destList , Function<S,K> skeyFunc, Function<T,K> dkeyFunc,BiFunction<S,T,R> mergeFunc)` ï¼Œ é€šç”¨æ€§è™½å¥½ï¼Œå¯æ˜¯æœ‰5ä¸ªå‚æ•°ï¼Œæœ‰ç‚¹ä¸‘ã€‚æ€ä¹ˆæ”¹é€ ä¸‹å‘¢ï¼Ÿ çœ‹å®ç°ï¼Œä¸»è¦åŒ…å«ä¸¤æ­¥ï¼š1. å°†å¾…åˆå¹¶åˆ—è¡¨è½¬åŒ–ä¸º srcMap: map<K,S>; 2. ä½¿ç”¨æŒ‡å®šçš„å‡½æ•° dKeyFunc, mergeFunc ä½œç”¨äºdestListå’ŒsrcMapï¼Œå¾—åˆ°æœ€ç»ˆç»“æœã€‚å¯ä»¥æ”¹å†™ä»£ç å¦‚ä¸‹ï¼š

```Java
public static <T,S,K,R> List<R> mergeList(List<S> srcList, List<T> destList ,
                                          Function<S,K> skeyFunc, Function<T,K> dkeyFunc,
                                          BiFunction<S,T,R> mergeFunc) {
    return join(destList, mapKey(srcList, skeyFunc)).apply(dkeyFunc, (BiFunction) mergeFunc);

  }

  public static <T,K> Map<K,T> mapKey(List<T> list, Function<T,K> keyFunc) {
    return list.stream().collect(Collectors.toMap(keyFunc, t -> t, (k1,k2) -> k1));
  }

  public static <T,S,K,R> BiFunction<Function<T,K>, BiFunction<S,T,R>, List<R>> join(List<T> destList, Map<K,S> srcMap) {
    return (dkeyFunc,mergeFunc) -> destList.stream().map(
        dest -> {
          K key = dkeyFunc.apply(dest);
          S src = srcMap.get(key);
          return mergeFunc.apply(src, dest);
        }).collect(Collectors.toList());
  }

System.out.println(mergeList(Arrays.asList(1,2), Arrays.asList("an", "a"), s-> s, t-> t.toString().length(), (s,t) -> s+t));
```

mapKey æ˜¯ä¸€ä¸ªé€šç”¨å‡½æ•°ï¼Œç”¨äºå°†ä¸€ä¸ª list æŒ‰ç…§æŒ‡å®šçš„ keyFunc è½¬æˆä¸€ä¸ª Map; join å‡½æ•°æ¥å—ä¸€ä¸ª list å’Œå¾…åˆå¹¶çš„ srcMap, è¿”å›ä¸€ä¸ªäºŒå…ƒå‡½æ•°ï¼Œè¯¥å‡½æ•°ä½¿ç”¨æŒ‡å®šçš„ dkeyFunc å’Œ mergeFunc æ¥åˆå¹¶æŒ‡å®šæ•°æ®å¾—åˆ°æœ€ç»ˆçš„ç»“æœåˆ—è¡¨ã€‚è¿™å¯ç§°ä¹‹ä¸ºâ€œå»¶è¿ŸæŒ‡å®šè¡Œä¸ºâ€ã€‚ç°åœ¨, mapKey å’Œ join éƒ½æ˜¯é€šç”¨æ€§å‡½æ•°ã€‚Amazing ï¼

# Java8æ³›å‹

åœ¨Java8å‡½æ•°å¼æ¡†æ¶çš„è§£è¯»ä¸­ï¼Œå¯ä»¥æ˜æ˜¾çœ‹åˆ°ï¼Œæ³›å‹æ— å¤„ä¸åœ¨ã€‚Java8çš„æ³›å‹æ¨å¯¼èƒ½åŠ›ä¹Ÿæœ‰å¾ˆå¤§çš„å¢å¼ºã€‚å¯ä»¥è¯´ï¼Œå¦‚æœæ²¡æœ‰å¼ºå¤§çš„æ³›å‹æ¨å¯¼æ”¯æ’‘ï¼Œå‡½æ•°æ¥å£çš„å¨åŠ›å°†ä¼šå¤§æ‰“æŠ˜æ‰£ã€‚

# å®Œæ•´ä»£ç ç¤ºä¾‹

```Java
package zzz.study.function;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collectors;

/**
 * Created by shuqin on 17/12/3.
 */
public class FunctionUtil {

  public static <T,R> List<R> multiGetResult(List<Function<List<T>, R>> functions, List<T> list) {
    return functions.stream().map(f -> f.apply(list)).collect(Collectors.toList());
  }

  public static <K,R> List<R> mergeList(List<R> srcList, List<R> destList ,
                                        Function<R,K> keyFunc,
                                        BinaryOperator<R> mergeFunc) {
    return mergeList(srcList, destList, keyFunc, keyFunc, mergeFunc);
  }

  public static <T,S,K,R> List<R> mergeList(List<S> srcList, List<T> destList ,
                                          Function<S,K> skeyFunc, Function<T,K> dkeyFunc,
                                          BiFunction<S,T,R> mergeFunc) {
    return join(destList, mapKey(srcList, skeyFunc)).apply(dkeyFunc, (BiFunction) mergeFunc);

  }

  public static <T,K> Map<K,T> mapKey(List<T> list, Function<T,K> keyFunc) {
    return list.stream().collect(Collectors.toMap(keyFunc, t -> t, (k1,k2) -> k1));
  }

  public static <T,S,K,R> BiFunction<Function<T,K>, BiFunction<S,T,R>, List<R>> join(List<T> destList, Map<K,S> srcMap) {
    return (dkeyFunc,mergeFunc) -> destList.stream().map(
        dest -> {
          K key = dkeyFunc.apply(dest);
          S src = srcMap.get(key);
          return mergeFunc.apply(src, dest);
        }).collect(Collectors.toList());
  }

  /** å¯¹ç»™å®šçš„å€¼ x,y åº”ç”¨æŒ‡å®šçš„äºŒå…ƒæ“ä½œå‡½æ•° */
  public static <T,S,R> Function<BiFunction<T,S,R>, R> op(T x, S y) {
    return opFunc -> opFunc.apply(x, y);
  }

  /** å°†ä¸¤ä¸ªå‡½æ•°ä½¿ç”¨ç»„åˆæˆä¸€ä¸ªå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°æ¥å—ä¸€ä¸ªäºŒå…ƒæ“ä½œå‡½æ•° */
  public static <T,S,Q,R> Function<BiFunction<S,Q,R>, R> op(Function<T,S> funcx, Function<T,Q> funcy, T x) {
    return opFunc -> opFunc.apply(funcx.apply(x), funcy.apply(x));
  }

  public static <T,S,Q,R> Function<BiFunction<S,Q,R>, Function<T,R>> op(Function<T,S> funcx, Function<T,Q> funcy) {
    return opFunc -> aT -> opFunc.apply(funcx.apply(aT), funcy.apply(aT));
  }

  /** å°†ä¸¤ä¸ªå‡½æ•°ç»„åˆæˆä¸€ä¸ªå åŠ å‡½æ•°, compose(f,g) = f(g) */
  public static <T> Function<T, T> compose(Function<T,T> funcx, Function<T,T> funcy) {
    return x -> funcx.apply(funcy.apply(x));
  }

  /** å°†è‹¥å¹²ä¸ªå‡½æ•°ç»„åˆæˆä¸€ä¸ªå åŠ å‡½æ•°, compose(f1,f2,...fn) = f1(f2(...(fn))) */
  public static <T> Function<T, T> compose(Function<T,T>... extraFuncs) {
    if (extraFuncs == null || extraFuncs.length == 0) {
      return x->x;
    }
    return x -> Arrays.stream(extraFuncs).reduce(y->y, FunctionUtil::compose).apply(x);
  }

   public static void main(String[] args) {
     System.out.println(multiGetResult(
         Arrays.asList(
             list -> list.stream().collect(Collectors.summarizingInt(x->x)),
             list -> list.stream().filter(x -> x < 50).sorted().collect(Collectors.toList()),
             list -> list.stream().collect(Collectors.groupingBy(x->(x%2==0? "even": "odd"))),
             list -> list.stream().sorted().collect(Collectors.toList()),
             list -> list.stream().sorted().map(Math::sqrt).collect(Collectors.toMap(x->x, y->Math.pow(2,y)))),
         Arrays.asList(64,49,25,16,9,4,1,81,36)));

     List<Integer> list = Arrays.asList(1,2,3,4,5);
     Supplier<Map<Integer,Integer>> mapSupplier = () -> list.stream().collect(Collectors.toMap(x->x, y-> y * y));

     Map<Integer, Integer> mapValueAdd = list.stream().collect(Collectors.toMap(x->x, y->y, (v1,v2) -> v1+v2, mapSupplier));
     System.out.println(mapValueAdd);

     List<Integer> nums = Arrays.asList(Arrays.asList(1,2,3), Arrays.asList(1,4,9), Arrays.asList(1,8,27))
                                .stream().flatMap(x -> x.stream()).collect(Collectors.toList());
     System.out.println(nums);

     List<Integer> fibo = Arrays.asList(1,2,3,4,5,6,7,8,9,10).stream().collect(new FiboCollector());
     System.out.println(fibo);

     System.out.println(op(new Integer(3), Integer.valueOf(3)).apply((x,y) -> x.equals(y.toString())));

     System.out.println(op(x-> x.length(), y-> y+",world", "hello").apply((x,y) -> x+" " +y));

     System.out.println(op(x-> x, y-> y+",world").apply((x,y) -> x+" " +y).apply("hello"));

     System.out.println(op(x-> x.toString().length(), y-> y+",world").apply((x,y) -> x+" " +y).apply("hello"));

     System.out.println(mergeList(Arrays.asList(1,2), Arrays.asList("an", "a"),
                                  s-> s, t-> t.toString().length(), (s,t) -> s+t));

   }

}
```

# å°ç»“

æœ¬æ–‡æ·±å…¥å­¦ä¹ äº†Java8å‡½æ•°å¼ç¼–ç¨‹æ¡†æ¶ï¼šFunction&Stream&Collectorï¼Œå¹¶å±•ç¤ºäº†å‡½æ•°å¼ç¼–ç¨‹åœ¨å®é™…åº”ç”¨ä¸­æ‰€å¸¦æ¥çš„è¯¸å¤šç›Šå¤„ã€‚å‡½æ•°å¼ç¼–ç¨‹æ˜¯ä¸€æŠŠå¤§é”‹è‹¥é’çš„å¥‡å‰‘ã€‚åŸºäºå‡½æ•°æ¥å£ç¼–ç¨‹ï¼Œå°†å‡½æ•°ä½œä¸ºæ•°æ®è‡ªç”±ä¼ é€’ï¼Œç»“åˆæ³›å‹æ¨å¯¼èƒ½åŠ›ï¼Œå¯ç¼–å†™å‡ºç²¾ç»ƒã€é€šç”¨ã€æ˜“æµ‹çš„ä»£ç ï¼Œä½¿ä»£ç è¡¨è¾¾èƒ½åŠ›è·å¾—é£ä¸€èˆ¬çš„æå‡ã€‚