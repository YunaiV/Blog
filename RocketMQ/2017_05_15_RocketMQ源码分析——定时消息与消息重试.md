title: RocketMQ æºç åˆ†æ â€”â€” å®šæ—¶æ¶ˆæ¯ä¸æ¶ˆæ¯é‡è¯•
date: 2017-05-15
tags:
categories: RocketMQ
permalink: RocketMQ/message-schedule-and-retry

-------

![](http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg)

> ğŸ™‚ğŸ™‚ğŸ™‚å…³æ³¨**å¾®ä¿¡å…¬ä¼—å·ï¼šã€èŠ‹è‰¿çš„åç«¯å°å±‹ã€‘**æœ‰ç¦åˆ©ï¼š  
> 1. RocketMQ / MyCAT / Sharding-JDBC **æ‰€æœ‰**æºç åˆ†ææ–‡ç« åˆ—è¡¨  
> 2. RocketMQ / MyCAT / Sharding-JDBC **ä¸­æ–‡æ³¨é‡Šæºç  GitHub åœ°å€**  
> 3. æ‚¨å¯¹äºæºç çš„ç–‘é—®æ¯æ¡ç•™è¨€**éƒ½**å°†å¾—åˆ°**è®¤çœŸ**å›å¤ã€‚**ç”šè‡³ä¸çŸ¥é“å¦‚ä½•è¯»æºç ä¹Ÿå¯ä»¥è¯·æ•™å™¢**ã€‚  
> 4. **æ–°çš„**æºç è§£ææ–‡ç« **å®æ—¶**æ”¶åˆ°é€šçŸ¥ã€‚**æ¯å‘¨æ›´æ–°ä¸€ç¯‡å·¦å³**ã€‚
> 5. **è®¤çœŸçš„**æºç äº¤æµå¾®ä¿¡ç¾¤ã€‚

-------

- [1. æ¦‚è¿°](#)
- [2. å®šæ—¶æ¶ˆæ¯](#)
	- [2.1 å»¶è¿Ÿçº§åˆ«](#)
	- [2.2 Producer å‘é€å®šæ—¶æ¶ˆæ¯](#)
	- [2.3 Broker å­˜å‚¨å®šæ—¶æ¶ˆæ¯](#)
	- [2.4 Broker å‘é€å®šæ—¶æ¶ˆæ¯](#)
	- [2.5 Broker æŒä¹…åŒ–å®šæ—¶å‘é€è¿›åº¦](#)
- [3. æ¶ˆæ¯é‡è¯•](#)

# 1. æ¦‚è¿°

**å»ºè®®**å‰ç½®é˜…è¯»å†…å®¹ï¼š

* [ã€ŠRocketMQ æºç åˆ†æ â€”â€” Message å‘é€ä¸æ¥æ”¶ã€‹](http://www.yunai.me/RocketMQ/message-send-and-receive/)
* [ã€ŠRocketMQ æºç åˆ†æ â€”â€” Message æ‹‰å–ä¸æ¶ˆè´¹ï¼ˆä¸‹ï¼‰ã€‹](http://www.yunai.me/RocketMQ/message-pull-and-consume-second/)

ğŸ˜ˆ ä¸ºä»€ä¹ˆæŠŠ**å®šæ—¶æ¶ˆæ¯**ä¸**æ¶ˆæ¯é‡è¯•**æ”¾åœ¨ä¸€èµ·ï¼Ÿä½ çŒœã€‚  
ğŸ‘» ä½ çŒœæˆ‘çŒœä¸çŒœã€‚

# 2. å®šæ—¶æ¶ˆæ¯

> **å®šæ—¶æ¶ˆæ¯**æ˜¯æŒ‡æ¶ˆæ¯å‘åˆ° Broker åï¼Œä¸èƒ½ç«‹åˆ»è¢« Consumer æ¶ˆè´¹ï¼Œè¦åˆ°ç‰¹å®šçš„æ—¶é—´ç‚¹æˆ–è€…ç­‰å¾…ç‰¹å®šçš„æ—¶é—´åæ‰èƒ½è¢«æ¶ˆè´¹ã€‚

ä¸‹å›¾æ˜¯**å®šæ—¶æ¶ˆæ¯**çš„å¤„ç†é€»è¾‘å›¾ï¼š

![å®šæ—¶æ¶ˆæ¯é€»è¾‘å›¾.png](http://www.yunai.me/images/RocketMQ/2017_05_15/02.png)

## 2.1 å»¶è¿Ÿçº§åˆ«

`RocketMQ` ç›®å‰åªæ”¯æŒ**å›ºå®šç²¾åº¦**çš„å®šæ—¶æ¶ˆæ¯ã€‚å®˜æ–¹è¯´æ³•å¦‚ä¸‹ï¼š
> å¦‚æœè¦æ”¯æŒä»»æ„çš„æ—¶é—´ç²¾åº¦ï¼Œåœ¨ Broker å±‚é¢ï¼Œå¿…é¡»è¦åšæ¶ˆæ¯æ’åºï¼Œå¦‚æœå†æ¶‰åŠåˆ°æŒä¹…åŒ–ï¼Œé‚£ä¹ˆæ¶ˆæ¯æ’åºè¦ä¸å¯é¿å…çš„äº§ç”Ÿå·¨å¤§æ€§èƒ½å¼€é”€ã€‚

* å»¶è¿Ÿçº§åˆ«ï¼š

| å»¶è¿Ÿçº§åˆ« | æ—¶é—´ |
| --- | --- |
| 1   |  1s |
| 2   |  5s |
| 3   | 10s |
| 4   | 30s |
| 5   |  1m |
| 6   |  2m |
| 7   |  3m |
| 8   | 4m  |
| 9   | 5m  |
| 10  | 6m  |
| 11  | 7m  |
| 12  | 8m  |
| 13  | 9m  |
| 14  | 10m |
| 15  | 20m |
| 16  | 30m |
| 17  | 1h  |
| 18  | 2h  |

* æ ¸å¿ƒæºç å¦‚ä¸‹ï¼š

    ```Java
      1: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€MessageStoreConfig.javaã€‘
      2: /**
      3:  * æ¶ˆæ¯å»¶è¿Ÿçº§åˆ«å­—ç¬¦ä¸²é…ç½®
      4:  */
      5: private String messageDelayLevel = "1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h";
      6: 
      7: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€ScheduleMessageService.javaã€‘
      8: /**
      9:  * è§£æå»¶è¿Ÿçº§åˆ«
     10:  *
     11:  * @return æ˜¯å¦è§£ææˆåŠŸ
     12:  */
     13: public boolean parseDelayLevel() {
     14:     HashMap<String, Long> timeUnitTable = new HashMap<>();
     15:     timeUnitTable.put("s", 1000L);
     16:     timeUnitTable.put("m", 1000L * 60);
     17:     timeUnitTable.put("h", 1000L * 60 * 60);
     18:     timeUnitTable.put("d", 1000L * 60 * 60 * 24);
     19: 
     20:     String levelString = this.defaultMessageStore.getMessageStoreConfig().getMessageDelayLevel();
     21:     try {
     22:         String[] levelArray = levelString.split(" ");
     23:         for (int i = 0; i < levelArray.length; i++) {
     24:             String value = levelArray[i];
     25:             String ch = value.substring(value.length() - 1);
     26:             Long tu = timeUnitTable.get(ch);
     27: 
     28:             int level = i + 1;
     29:             if (level > this.maxDelayLevel) {
     30:                 this.maxDelayLevel = level;
     31:             }
     32:             long num = Long.parseLong(value.substring(0, value.length() - 1));
     33:             long delayTimeMillis = tu * num;
     34:             this.delayLevelTable.put(level, delayTimeMillis);
     35:         }
     36:     } catch (Exception e) {
     37:         log.error("parseDelayLevel exception", e);
     38:         log.info("levelString String = {}", levelString);
     39:         return false;
     40:     }
     41: 
     42:     return true;
     43: }
    ```

## 2.2 Producer å‘é€å®šæ—¶æ¶ˆæ¯

* ğŸ¦…å‘é€æ—¶ï¼Œè®¾ç½®æ¶ˆæ¯çš„**å»¶è¿Ÿçº§åˆ«**ã€‚

```Java
Message msg = new Message(...);
msg.setDelayTimeLevel(level);
```

## 2.3 Broker å­˜å‚¨å®šæ—¶æ¶ˆæ¯

* ğŸ¦… å­˜å‚¨æ¶ˆæ¯æ—¶ï¼Œå»¶è¿Ÿæ¶ˆæ¯è¿›å…¥ `Topic` ä¸º `SCHEDULE_TOPIC_XXXX`ã€‚
* ğŸ¦… å»¶è¿Ÿçº§åˆ« ä¸ æ¶ˆæ¯é˜Ÿåˆ—ç¼–å· åš**å›ºå®šæ˜ å°„ï¼šQueueId = DelayLevel - 1**ã€‚

æ ¸å¿ƒä»£ç å¦‚ä¸‹ï¼š

```Java
  1: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€CommitLog.javaã€‘
  2: /**
  3:  * æ·»åŠ æ¶ˆæ¯ï¼Œè¿”å›æ¶ˆæ¯ç»“æœ
  4:  *
  5:  * @param msg æ¶ˆæ¯
  6:  * @return ç»“æœ
  7:  */
  8: public PutMessageResult putMessage(final MessageExtBrokerInner msg) {
  9:     // ....(çœç•¥ä»£ç ) 
 10: 
 11:     // å®šæ—¶æ¶ˆæ¯å¤„ç†
 12:     final int tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());
 13:     if (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE//
 14:         || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) {
 15:         // Delay Delivery
 16:         if (msg.getDelayTimeLevel() > 0) {
 17:             if (msg.getDelayTimeLevel() > this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) {
 18:                 msg.setDelayTimeLevel(this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());
 19:             }
 20: 
 21:             // å­˜å‚¨æ¶ˆæ¯æ—¶ï¼Œå»¶è¿Ÿæ¶ˆæ¯è¿›å…¥ `Topic` ä¸º `SCHEDULE_TOPIC_XXXX` ã€‚
 22:             topic = ScheduleMessageService.SCHEDULE_TOPIC;
 23: 
 24:             // å»¶è¿Ÿçº§åˆ« ä¸ æ¶ˆæ¯é˜Ÿåˆ—ç¼–å· åšå›ºå®šæ˜ å°„
 25:             queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());
 26: 
 27:             // Backup real topic, queueId
 28:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());
 29:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));
 30:             msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));
 31: 
 32:             msg.setTopic(topic);
 33:             msg.setQueueId(queueId);
 34:         }
 35:     }
 36: 
 37:     // ....(çœç•¥ä»£ç ) 
 38: }
 39: 
 40: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€ScheduleMessageService.javaã€‘
 41: /**
 42:  * æ ¹æ® å»¶è¿Ÿçº§åˆ« è®¡ç®— æ¶ˆæ¯é˜Ÿåˆ—ç¼–å·
 43:  * QueueId = DelayLevel - 1
 44:  *
 45:  * @param delayLevel å»¶è¿Ÿçº§åˆ«
 46:  * @return æ¶ˆæ¯é˜Ÿåˆ—ç¼–å·
 47:  */
 48: public static int delayLevel2QueueId(final int delayLevel) {
 49:     return delayLevel - 1;
 50: }
```

-------

* ğŸ¦… ç”Ÿæˆ `ConsumeQueue` æ—¶ï¼Œæ¯æ¡æ¶ˆæ¯çš„ `tagsCode` ä½¿ç”¨ã€æ¶ˆæ¯è®¡åˆ’æ¶ˆè´¹æ—¶é—´ã€‘ã€‚è¿™æ ·ï¼Œ`ScheduleMessageService` åœ¨è½®è¯¢ `ConsumeQueue` æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ `tagsCode` è¿›è¡Œè¿‡æ»¤ã€‚

æ ¸å¿ƒä»£ç å¦‚ä¸‹ï¼š

```Java
  1: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€CommitLog.javaã€‘
  2: /**
  3:  * check the message and returns the message size
  4:  *
  5:  * @return 0 Come the end of the file // >0 Normal messages // -1 Message checksum failure
  6:  */
  7: public DispatchRequest checkMessageAndReturnSize(ByteBuffer byteBuffer, final boolean checkCRC, final boolean readBody) {
  8:     try {
  9:         // // ....(çœç•¥ä»£ç )
 10: 
 11:         // 17 properties
 12:         short propertiesLength = byteBuffer.getShort();
 13:         if (propertiesLength > 0) {
 14:             // ....(çœç•¥ä»£ç )
 15:             String tags = propertiesMap.get(MessageConst.PROPERTY_TAGS);
 16:             if (tags != null && tags.length() > 0) {
 17:                 tagsCode = MessageExtBrokerInner.tagsString2tagsCode(MessageExt.parseTopicFilterType(sysFlag), tags);
 18:             }
 19: 
 20:             // Timing message processing
 21:             {
 22:                 String t = propertiesMap.get(MessageConst.PROPERTY_DELAY_TIME_LEVEL);
 23:                 if (ScheduleMessageService.SCHEDULE_TOPIC.equals(topic) && t != null) {
 24:                     int delayLevel = Integer.parseInt(t);
 25: 
 26:                     if (delayLevel > this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) {
 27:                         delayLevel = this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel();
 28:                     }
 29: 
 30:                     if (delayLevel > 0) {
 31:                         tagsCode = this.defaultMessageStore.getScheduleMessageService().computeDeliverTimestamp(delayLevel,
 32:                             storeTimestamp);
 33:                     }
 34:                 }
 35:             }
 36:         }
 37: 
 38:         // ....(çœç•¥ä»£ç )
 39: 
 40:         return new DispatchRequest(//
 41:             topic, // 1
 42:             queueId, // 2
 43:             physicOffset, // 3
 44:             totalSize, // 4
 45:             tagsCode, // 5
 46:             storeTimestamp, // 6
 47:             queueOffset, // 7
 48:             keys, // 8
 49:             uniqKey, //9
 50:             sysFlag, // 9
 51:             preparedTransactionOffset// 10
 52:         );
 53:     } catch (Exception e) {
 54:     }
 55: 
 56:     return new DispatchRequest(-1, false /* success */);
 57: }
 58: 
 59: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€ScheduleMessageService.javaã€‘
 60: /**
 61:  * è®¡ç®— æŠ•é€’æ—¶é—´ã€è®¡åˆ’æ¶ˆè´¹æ—¶é—´ã€‘
 62:  *
 63:  * @param delayLevel å»¶è¿Ÿçº§åˆ«
 64:  * @param storeTimestamp å­˜å‚¨æ—¶é—´
 65:  * @return æŠ•é€’æ—¶é—´ã€è®¡åˆ’æ¶ˆè´¹æ—¶é—´ã€‘
 66:  */
 67: public long computeDeliverTimestamp(final int delayLevel, final long storeTimestamp) {
 68:     Long time = this.delayLevelTable.get(delayLevel);
 69:     if (time != null) {
 70:         return time + storeTimestamp;
 71:     }
 72: 
 73:     return storeTimestamp + 1000;
 74: }
```

## 2.4 Broker å‘é€å®šæ—¶æ¶ˆæ¯

* ğŸ¦… å¯¹ `SCHEDULE_TOPIC_XXXX` æ¯æ¡æ¶ˆè´¹é˜Ÿåˆ—å¯¹åº”**å•ç‹¬ä¸€ä¸ª**å®šæ—¶ä»»åŠ¡è¿›è¡Œè½®è¯¢ï¼Œå‘é€ **åˆ°è¾¾æŠ•é€’æ—¶é—´ã€è®¡åˆ’æ¶ˆè´¹æ—¶é—´ã€‘** çš„æ¶ˆæ¯ã€‚

ä¸‹å›¾æ˜¯å‘é€å®šæ—¶æ¶ˆæ¯çš„å¤„ç†é€»è¾‘å›¾ï¼š

![å®šæ—¶æ¶ˆæ¯å®šæ—¶é€»è¾‘](http://www.yunai.me/images/RocketMQ/2017_05_15/01.png)

å®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
  1: /**
  2:  * â¬‡ï¸â¬‡ï¸â¬‡ï¸ å‘é€ï¼ˆæŠ•é€’ï¼‰å»¶è¿Ÿæ¶ˆæ¯å®šæ—¶ä»»åŠ¡
  3:  */
  4: class DeliverDelayedMessageTimerTask extends TimerTask {
  5:     /**
  6:      * å»¶è¿Ÿçº§åˆ«
  7:      */
  8:     private final int delayLevel;
  9:     /**
 10:      * ä½ç½®
 11:      */
 12:     private final long offset;
 13: 
 14:     public DeliverDelayedMessageTimerTask(int delayLevel, long offset) {
 15:         this.delayLevel = delayLevel;
 16:         this.offset = offset;
 17:     }
 18: 
 19:     @Override
 20:     public void run() {
 21:         try {
 22:             this.executeOnTimeup();
 23:         } catch (Exception e) {
 24:             // XXX: warn and notify me
 25:             log.error("ScheduleMessageService, executeOnTimeup exception", e);
 26:             ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(
 27:                 this.delayLevel, this.offset), DELAY_FOR_A_PERIOD);
 28:         }
 29:     }
 30: 
 31:     /**
 32:      * çº æ­£å¯æŠ•é€’æ—¶é—´ã€‚
 33:      * å› ä¸ºå‘é€çº§åˆ«å¯¹åº”çš„å‘é€é—´éš”å¯ä»¥è°ƒæ•´ï¼Œå¦‚æœè¶…è¿‡å½“å‰é—´éš”ï¼Œåˆ™ä¿®æ­£æˆå½“å‰é…ç½®ï¼Œé¿å…åé¢çš„æ¶ˆæ¯æ— æ³•å‘é€ã€‚
 34:      *
 35:      * @param now å½“å‰æ—¶é—´
 36:      * @param deliverTimestamp æŠ•é€’æ—¶é—´
 37:      * @return çº æ­£ç»“æœ
 38:      */
 39:     private long correctDeliverTimestamp(final long now, final long deliverTimestamp) {
 40:         long result = deliverTimestamp;
 41: 
 42:         long maxTimestamp = now + ScheduleMessageService.this.delayLevelTable.get(this.delayLevel);
 43:         if (deliverTimestamp > maxTimestamp) {
 44:             result = now;
 45:         }
 46: 
 47:         return result;
 48:     }
 49: 
 50:     public void executeOnTimeup() {
 51:         ConsumeQueue cq = ScheduleMessageService.this.defaultMessageStore.findConsumeQueue(SCHEDULE_TOPIC,  delayLevel2QueueId(delayLevel));
 52: 
 53:         long failScheduleOffset = offset;
 54: 
 55:         if (cq != null) {
 56:             SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(this.offset);
 57:             if (bufferCQ != null) {
 58:                 try {
 59:                     long nextOffset = offset;
 60:                     int i = 0;
 61:                     for (; i < bufferCQ.getSize(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) {
 62:                         long offsetPy = bufferCQ.getByteBuffer().getLong();
 63:                         int sizePy = bufferCQ.getByteBuffer().getInt();
 64:                         long tagsCode = bufferCQ.getByteBuffer().getLong();
 65: 
 66:                         long now = System.currentTimeMillis();
 67:                         long deliverTimestamp = this.correctDeliverTimestamp(now, tagsCode);
 68: 
 69:                         nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);
 70: 
 71:                         long countdown = deliverTimestamp - now;
 72: 
 73:                         if (countdown <= 0) { // æ¶ˆæ¯åˆ°è¾¾å¯å‘é€æ—¶é—´
 74:                             MessageExt msgExt = ScheduleMessageService.this.defaultMessageStore.lookMessageByOffset(offsetPy, sizePy);
 75:                             if (msgExt != null) {
 76:                                 try {
 77:                                     // å‘é€æ¶ˆæ¯
 78:                                     MessageExtBrokerInner msgInner = this.messageTimeup(msgExt);
 79:                                     PutMessageResult putMessageResult = ScheduleMessageService.this.defaultMessageStore.putMessage(msgInner);
 80:                                     if (putMessageResult != null && putMessageResult.getPutMessageStatus() == PutMessageStatus.PUT_OK) { // å‘é€æˆåŠŸ
 81:                                         continue;
 82:                                     } else { // å‘é€å¤±è´¥
 83:                                         // XXX: warn and notify me
 84:                                         log.error("ScheduleMessageService, a message time up, but reput it failed, topic: {} msgId {}", msgExt.getTopic(), msgExt.getMsgId());
 85: 
 86:                                         // å®‰æ’ä¸‹ä¸€æ¬¡ä»»åŠ¡
 87:                                         ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(this.delayLevel, nextOffset), DELAY_FOR_A_PERIOD);
 88: 
 89:                                         // æ›´æ–°è¿›åº¦
 90:                                         ScheduleMessageService.this.updateOffset(this.delayLevel, nextOffset);
 91:                                         return;
 92:                                     }
 93:                                 } catch (Exception e) {
 94:                                     // XXX: warn and notify me
 95:                                     log.error("ScheduleMessageService, messageTimeup execute error, drop it. msgExt="
 96:                                             + msgExt + ", nextOffset=" + nextOffset + ",offsetPy=" + offsetPy + ",sizePy=" + sizePy, e);
 97:                                 }
 98:                             }
 99:                         } else {
100:                             // å®‰æ’ä¸‹ä¸€æ¬¡ä»»åŠ¡
101:                             ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(this.delayLevel, nextOffset), countdown);
102: 
103:                             // æ›´æ–°è¿›åº¦
104:                             ScheduleMessageService.this.updateOffset(this.delayLevel, nextOffset);
105:                             return;
106:                         }
107:                     } // end of for
108: 
109:                     nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);
110: 
111:                     // å®‰æ’ä¸‹ä¸€æ¬¡ä»»åŠ¡
112:                     ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(this.delayLevel, nextOffset), DELAY_FOR_A_WHILE);
113: 
114:                     // æ›´æ–°è¿›åº¦
115:                     ScheduleMessageService.this.updateOffset(this.delayLevel, nextOffset);
116:                     return;
117:                 } finally {
118:                     bufferCQ.release();
119:                 }
120:             } // end of if (bufferCQ != null)
121:             else { // æ¶ˆè´¹é˜Ÿåˆ—å·²ç»è¢«åˆ é™¤éƒ¨åˆ†ï¼Œè·³è½¬åˆ°æœ€å°çš„æ¶ˆè´¹è¿›åº¦
122:                 long cqMinOffset = cq.getMinOffsetInQueue();
123:                 if (offset < cqMinOffset) {
124:                     failScheduleOffset = cqMinOffset;
125:                     log.error("schedule CQ offset invalid. offset=" + offset + ", cqMinOffset="
126:                         + cqMinOffset + ", queueId=" + cq.getQueueId());
127:                 }
128:             }
129:         } // end of if (cq != null)
130: 
131:         ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(this.delayLevel, failScheduleOffset), DELAY_FOR_A_WHILE);
132:     }
133: 
134:     /**
135:      * è®¾ç½®æ¶ˆæ¯å†…å®¹
136:      *
137:      * @param msgExt æ¶ˆæ¯
138:      * @return æ¶ˆæ¯
139:      */
140:     private MessageExtBrokerInner messageTimeup(MessageExt msgExt) {
141:         MessageExtBrokerInner msgInner = new MessageExtBrokerInner();
142:         msgInner.setBody(msgExt.getBody());
143:         msgInner.setFlag(msgExt.getFlag());
144:         MessageAccessor.setProperties(msgInner, msgExt.getProperties());
145: 
146:         TopicFilterType topicFilterType = MessageExt.parseTopicFilterType(msgInner.getSysFlag());
147:         long tagsCodeValue =
148:             MessageExtBrokerInner.tagsString2tagsCode(topicFilterType, msgInner.getTags());
149:         msgInner.setTagsCode(tagsCodeValue);
150:         msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties()));
151: 
152:         msgInner.setSysFlag(msgExt.getSysFlag());
153:         msgInner.setBornTimestamp(msgExt.getBornTimestamp());
154:         msgInner.setBornHost(msgExt.getBornHost());
155:         msgInner.setStoreHost(msgExt.getStoreHost());
156:         msgInner.setReconsumeTimes(msgExt.getReconsumeTimes());
157: 
158:         msgInner.setWaitStoreMsgOK(false);
159:         MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_DELAY_TIME_LEVEL);
160: 
161:         msgInner.setTopic(msgInner.getProperty(MessageConst.PROPERTY_REAL_TOPIC));
162: 
163:         String queueIdStr = msgInner.getProperty(MessageConst.PROPERTY_REAL_QUEUE_ID);
164:         int queueId = Integer.parseInt(queueIdStr);
165:         msgInner.setQueueId(queueId);
166: 
167:         return msgInner;
168:     }
169: }
```

## 2.5 Broker æŒä¹…åŒ–å®šæ—¶å‘é€è¿›åº¦

* ğŸ¦… å®šæ—¶æ¶ˆæ¯å‘é€è¿›åº¦å­˜å‚¨åœ¨æ–‡ä»¶(`../config/delayOffset.json`)é‡Œ
* ğŸ¦… æ¯ 10s å®šæ—¶æŒä¹…åŒ–å‘é€è¿›åº¦ã€‚

æ ¸å¿ƒä»£ç å¦‚ä¸‹ï¼š

```Java
  1: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€ScheduleMessageService.javaã€‘
  2: /**
  3: public void start() {
  4:     // å®šæ—¶å‘é€æ¶ˆæ¯
  5:     for (Map.Entry<Integer, Long> entry : this.delayLevelTable.entrySet()) {
  6:         Integer level = entry.getKey();
  7:         Long timeDelay = entry.getValue();
  8:         Long offset = this.offsetTable.get(level);
  9:         if (null == offset) {
 10:             offset = 0L;
 11:         }
 12: 
 13:         if (timeDelay != null) {
 14:             this.timer.schedule(new DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME);
 15:         }
 16:     }
 17: 
 18:     // å®šæ—¶æŒä¹…åŒ–å‘é€è¿›åº¦
 19:     this.timer.scheduleAtFixedRate(new TimerTask() {
 20: 
 21:         @Override
 22:         public void run() {
 23:             try {
 24:                 ScheduleMessageService.this.persist();
 25:             } catch (Exception e) {
 26:                 log.error("scheduleAtFixedRate flush exception", e);
 27:             }
 28:         }
 29:     }, 10000, this.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval());
 30: }
```

# 3. æ¶ˆæ¯é‡è¯•

> Consumer æ¶ˆè´¹æ¶ˆæ¯å¤±è´¥åï¼Œè¦æä¾›ä¸€ç§é‡è¯•æœºåˆ¶ï¼Œä»¤æ¶ˆæ¯å†æ¶ˆè´¹ä¸€æ¬¡ã€‚

* ğŸ¦… `Consumer` å°†æ¶ˆè´¹å¤±è´¥çš„æ¶ˆæ¯å‘å› `Broker`ï¼Œè¿›å…¥**å»¶è¿Ÿæ¶ˆæ¯é˜Ÿåˆ—**ã€‚å³ï¼Œæ¶ˆè´¹å¤±è´¥çš„æ¶ˆæ¯ï¼Œä¸ä¼šç«‹å³æ¶ˆè´¹ã€‚

æ ¸å¿ƒä»£ç å¦‚ä¸‹ï¼š

```Java
  1: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€SendMessageProcessor.javaã€‘
  2: /**
  3:  * æ¶ˆè´¹è€…å‘å›æ¶ˆæ¯
  4:  *
  5:  * @param ctx ctx
  6:  * @param request è¯·æ±‚
  7:  * @return å“åº”
  8:  * @throws RemotingCommandException å½“è¿œç¨‹è°ƒç”¨å¼‚å¸¸
  9:  */
 10: private RemotingCommand consumerSendMsgBack(final ChannelHandlerContext ctx, final RemotingCommand request)
 11:     throws RemotingCommandException {
 12:     // ....(çœç•¥ä»£ç )
 13:     // å¤„ç† delayLevelï¼ˆç‹¬æœ‰ï¼‰ã€‚
 14:     int delayLevel = requestHeader.getDelayLevel();
 15:     int maxReconsumeTimes = subscriptionGroupConfig.getRetryMaxTimes();
 16:     if (request.getVersion() >= MQVersion.Version.V3_4_9.ordinal()) {
 17:         maxReconsumeTimes = requestHeader.getMaxReconsumeTimes();
 18:     }
 19:     if (msgExt.getReconsumeTimes() >= maxReconsumeTimes//
 20:     // ....(çœç•¥ä»£ç )
 21:     } else {
 22:         if (0 == delayLevel) {
 23:             delayLevel = 3 + msgExt.getReconsumeTimes();
 24:         }
 25:         msgExt.setDelayTimeLevel(delayLevel);
 26:     }
 27: 
 28:     // ....(çœç•¥ä»£ç )
 29:     return response;
 30: }
```

