title: RocketMQ æºç åˆ†æ â€”â€” é«˜å¯ç”¨
date: 2017-05-14
tags:
categories: RocketMQ
permalink: RocketMQ/high-availability

-------

![](http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg)

> ğŸ™‚ğŸ™‚ğŸ™‚å…³æ³¨**å¾®ä¿¡å…¬ä¼—å·ï¼šã€èŠ‹é“æºç ã€‘**æœ‰ç¦åˆ©ï¼š  
> 1. RocketMQ / MyCAT / Sharding-JDBC **æ‰€æœ‰**æºç åˆ†ææ–‡ç« åˆ—è¡¨  
> 2. RocketMQ / MyCAT / Sharding-JDBC **ä¸­æ–‡æ³¨é‡Šæºç  GitHub åœ°å€**  
> 3. æ‚¨å¯¹äºæºç çš„ç–‘é—®æ¯æ¡ç•™è¨€**éƒ½**å°†å¾—åˆ°**è®¤çœŸ**å›å¤ã€‚**ç”šè‡³ä¸çŸ¥é“å¦‚ä½•è¯»æºç ä¹Ÿå¯ä»¥è¯·æ•™å™¢**ã€‚  
> 4. **æ–°çš„**æºç è§£ææ–‡ç« **å®æ—¶**æ”¶åˆ°é€šçŸ¥ã€‚**æ¯å‘¨æ›´æ–°ä¸€ç¯‡å·¦å³**ã€‚
> 5. **è®¤çœŸçš„**æºç äº¤æµå¾®ä¿¡ç¾¤ã€‚

-------

- [1. æ¦‚è¿°](#)
- [2. Namesrv é«˜å¯ç”¨](#)
	- [2.1 Broker æ³¨å†Œåˆ° Namesrv](#)
	- [2.2 Producerã€Consumer è®¿é—® Namesrv](#)
- [3. Broker é«˜å¯ç”¨](#)
	- [3.2 Broker ä¸»ä»](#)
		- [3.1.1 é…ç½®](#)
		- [3.1.2 ç»„ä»¶](#)
		- [3.1.3 é€šä¿¡åè®®](#)
		- [3.1.4 Slave](#)
		- [3.1.5 Master](#)
		- [3.1.6 Master_SYNC](#)
	- [3.2 Producer å‘é€æ¶ˆæ¯](#)
	- [3.3 Consumer æ¶ˆè´¹æ¶ˆæ¯](#)
- [4. æ€»ç»“](#)

# 1. æ¦‚è¿°

æœ¬æ–‡ä¸»è¦è§£æ `Namesrv`ã€`Broker` å¦‚ä½•å®ç°é«˜å¯ç”¨ï¼Œ`Producer`ã€`Consumer` æ€ä¹ˆä¸å®ƒä»¬é€šä¿¡ä¿è¯é«˜å¯ç”¨ã€‚

# 2. Namesrv é«˜å¯ç”¨

**å¯åŠ¨å¤šä¸ª `Namesrv` å®ç°é«˜å¯ç”¨ã€‚**  
ç›¸è¾ƒäº `Zookeeper`ã€`Consul`ã€`Etcd` ç­‰ï¼Œ`Namesrv` æ˜¯ä¸€ä¸ª**è¶…è½»é‡çº§**çš„æ³¨å†Œä¸­å¿ƒï¼Œæä¾›**å‘½åæœåŠ¡**ã€‚

## 2.1 Broker æ³¨å†Œåˆ° Namesrv

* ğŸ“Œ **å¤šä¸ª `Namesrv` ä¹‹é—´ï¼Œæ²¡æœ‰ä»»ä½•å…³ç³»ï¼ˆä¸å­˜åœ¨ç±»ä¼¼ `Zookeeper` çš„ `Leader`/`Follower` ç­‰è§’è‰²ï¼‰ï¼Œä¸è¿›è¡Œé€šä¿¡ä¸æ•°æ®åŒæ­¥ã€‚é€šè¿‡ `Broker` å¾ªç¯æ³¨å†Œå¤šä¸ª `Namesrv`ã€‚**

```Java
  1: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€BrokerOuterAPI.javaã€‘
  2: public RegisterBrokerResult registerBrokerAll(
  3:     final String clusterName,
  4:     final String brokerAddr,
  5:     final String brokerName,
  6:     final long brokerId,
  7:     final String haServerAddr,
  8:     final TopicConfigSerializeWrapper topicConfigWrapper,
  9:     final List<String> filterServerList,
 10:     final boolean oneway,
 11:     final int timeoutMills) {
 12:     RegisterBrokerResult registerBrokerResult = null;
 13: 
 14:     List<String> nameServerAddressList = this.remotingClient.getNameServerAddressList();
 15:     if (nameServerAddressList != null) {
 16:         for (String namesrvAddr : nameServerAddressList) { // å¾ªç¯å¤šä¸ª Namesrv
 17:             try {
 18:                 RegisterBrokerResult result = this.registerBroker(namesrvAddr, clusterName, brokerAddr, brokerName, brokerId,
 19:                     haServerAddr, topicConfigWrapper, filterServerList, oneway, timeoutMills);
 20:                 if (result != null) {
 21:                     registerBrokerResult = result;
 22:                 }
 23: 
 24:                 log.info("register broker to name server {} OK", namesrvAddr);
 25:             } catch (Exception e) {
 26:                 log.warn("registerBroker Exception, {}", namesrvAddr, e);
 27:             }
 28:         }
 29:     }
 30: 
 31:     return registerBrokerResult;
 32: }
```

## 2.2 Producerã€Consumer è®¿é—® Namesrv

* ğŸ“Œ **`Producer`ã€`Consumer` ä» `Namesrv`åˆ—è¡¨é€‰æ‹©ä¸€ä¸ªå¯è¿æ¥çš„è¿›è¡Œé€šä¿¡ã€‚**

```Java
  1: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€NettyRemotingClient.javaã€‘
  2: private Channel getAndCreateNameserverChannel() throws InterruptedException {
  3:     // è¿”å›å·²é€‰æ‹©ã€å¯è¿æ¥Namesrv
  4:     String addr = this.namesrvAddrChoosed.get();
  5:     if (addr != null) {
  6:         ChannelWrapper cw = this.channelTables.get(addr);
  7:         if (cw != null && cw.isOK()) {
  8:             return cw.getChannel();
  9:         }
 10:     }
 11:     //
 12:     final List<String> addrList = this.namesrvAddrList.get();
 13:     if (this.lockNamesrvChannel.tryLock(LOCK_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)) {
 14:         try {
 15:             // è¿”å›å·²é€‰æ‹©ã€å¯è¿æ¥çš„Namesrv
 16:             addr = this.namesrvAddrChoosed.get();
 17:             if (addr != null) {
 18:                 ChannelWrapper cw = this.channelTables.get(addr);
 19:                 if (cw != null && cw.isOK()) {
 20:                     return cw.getChannel();
 21:                 }
 22:             }
 23:             // ä»ã€Namesrvåˆ—è¡¨ã€‘ä¸­é€‰æ‹©ä¸€ä¸ªè¿æ¥çš„è¿”å›
 24:             if (addrList != null && !addrList.isEmpty()) {
 25:                 for (int i = 0; i < addrList.size(); i++) {
 26:                     int index = this.namesrvIndex.incrementAndGet();
 27:                     index = Math.abs(index);
 28:                     index = index % addrList.size();
 29:                     String newAddr = addrList.get(index);
 30: 
 31:                     this.namesrvAddrChoosed.set(newAddr);
 32:                     Channel channelNew = this.createChannel(newAddr);
 33:                     if (channelNew != null)
 34:                         return channelNew;
 35:                 }
 36:             }
 37:         } catch (Exception e) {
 38:             log.error("getAndCreateNameserverChannel: create name server channel exception", e);
 39:         } finally {
 40:             this.lockNamesrvChannel.unlock();
 41:         }
 42:     } else {
 43:         log.warn("getAndCreateNameserverChannel: try to lock name server, but timeout, {}ms", LOCK_TIMEOUT_MILLIS);
 44:     }
 45: 
 46:     return null;
 47: }
```

# 3. Broker é«˜å¯ç”¨

**å¯åŠ¨å¤šä¸ª `Brokeråˆ†ç»„` å½¢æˆ `é›†ç¾¤` å®ç°é«˜å¯ç”¨ã€‚**  
**`Brokeråˆ†ç»„` = `MasterèŠ‚ç‚¹`x1 + `SlaveèŠ‚ç‚¹`xNã€‚**  
ç±»ä¼¼ `MySQL`ï¼Œ`MasterèŠ‚ç‚¹` æä¾›**è¯»å†™**æœåŠ¡ï¼Œ`SlaveèŠ‚ç‚¹` åªæä¾›**è¯»**æœåŠ¡ã€‚  

## 3.2 Broker ä¸»ä»

* **æ¯ä¸ªåˆ†ç»„ï¼Œ`Master`èŠ‚ç‚¹ ä¸æ–­å‘é€æ–°çš„ `CommitLog` ç»™ `Slave`èŠ‚ç‚¹ã€‚ `Slave`èŠ‚ç‚¹ ä¸æ–­ä¸ŠæŠ¥æœ¬åœ°çš„ `CommitLog` å·²ç»åŒæ­¥åˆ°çš„ä½ç½®ç»™ `Master`èŠ‚ç‚¹ã€‚**
* **`Brokeråˆ†ç»„` ä¸ `Brokeråˆ†ç»„` ä¹‹é—´æ²¡æœ‰ä»»ä½•å…³ç³»ï¼Œä¸è¿›è¡Œé€šä¿¡ä¸æ•°æ®åŒæ­¥ã€‚**
* **æ¶ˆè´¹è¿›åº¦ ç›®å‰ä¸æ”¯æŒ `Master`/`Slave` åŒæ­¥ã€‚**

é›†ç¾¤å†…ï¼Œ`Master`èŠ‚ç‚¹ æœ‰**ä¸¤ç§**ç±»å‹ï¼š`Master_SYNC`ã€`Master_ASYNC`ï¼šå‰è€…åœ¨ `Producer` å‘é€æ¶ˆæ¯æ—¶ï¼Œç­‰å¾… `Slave`èŠ‚ç‚¹ å­˜å‚¨å®Œæ¯•åå†è¿”å›å‘é€ç»“æœï¼Œè€Œåè€…ä¸éœ€è¦ç­‰å¾…ã€‚


### 3.1.1 é…ç½®

ç›®å‰å®˜æ–¹æä¾›ä¸‰å¥—é…ç½®ï¼š

* **2m-2s-async**

| brokerClusterName| brokerName | brokerRole | brokerId |
| --- | --- | --- | --- |
| DefaultCluster | broker-a | ASYNC_MASTER | 0 |
| DefaultCluster | broker-a | SLAVE | 1 |
| DefaultCluster | broker-b | ASYNC_MASTER | 0 |
| DefaultCluster | broker-b | SLAVE | 1 |

* **2m-2s-sync**

| brokerClusterName| brokerName | brokerRole | brokerId |
| ---| --- | --- | --- |
| DefaultCluster | broker-a | SYNC_MASTER | 0 |
| DefaultCluster | broker-a | SLAVE | 1 |
| DefaultCluster | broker-b | SYNC_MASTER | 0 |
| DefaultCluster | broker-b | SLAVE | 1 |

* **2m-noslave**

| brokerClusterName| brokerName | brokerRole | brokerId |
| ---| --- | --- | --- |
| DefaultCluster | broker-a | ASYNC_MASTER | 0 |
| DefaultCluster | broker-b | ASYNC_MASTER | 0 |

### 3.1.2 ç»„ä»¶

å†çœ‹å…·ä½“å®ç°ä»£ç ä¹‹å‰ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹ `Master`/`Slave`èŠ‚ç‚¹ åŒ…å«çš„ç»„ä»¶ï¼š  
![HAç»„ä»¶å›¾.png](http://www.yunai.me/images/RocketMQ/2017_05_14/04.png)

* `Master`èŠ‚ç‚¹
    * `AcceptSocketService` ï¼šæ¥æ”¶ `Slave`èŠ‚ç‚¹ è¿æ¥ã€‚
    * `HAConnection`
        * `ReadSocketService` ï¼š**è¯»**æ¥è‡ª `Slave`èŠ‚ç‚¹ çš„æ•°æ®ã€‚ 
        * `WriteSocketService` ï¼š**å†™**åˆ°å¾€ `Slave`èŠ‚ç‚¹ çš„æ•°æ®ã€‚
* `Slave`èŠ‚ç‚¹
    * `HAClient` ï¼šå¯¹ `Master`èŠ‚ç‚¹ è¿æ¥ã€è¯»å†™æ•°æ®ã€‚

### 3.1.3 é€šä¿¡åè®®

`Master`èŠ‚ç‚¹ ä¸ `Slave`èŠ‚ç‚¹ **é€šä¿¡åè®®**å¾ˆç®€å•ï¼Œåªæœ‰å¦‚ä¸‹ä¸¤æ¡ã€‚

| å¯¹è±¡ | ç”¨é€” | ç¬¬å‡ ä½ | å­—æ®µ | æ•°æ®ç±»å‹ | å­—èŠ‚æ•° | è¯´æ˜
| :-- | :-- | :-- | :-- | :-- | :-- | :-- |
| Slave=>Master | ä¸ŠæŠ¥CommitLog**å·²ç»**åŒæ­¥åˆ°çš„**ç‰©ç†**ä½ç½® |  |  |  |  |  |
|  | | 0 | maxPhyOffset  |  Long | 8 | CommitLogæœ€å¤§ç‰©ç†ä½ç½® |
| Master=>Slave | ä¼ è¾“æ–°çš„ `CommitLog` æ•°æ® |  |  |  |  |  |
| | | 0 | fromPhyOffset | Long | 8 | CommitLogå¼€å§‹ç‰©ç†ä½ç½® | 
| | | 1 | size | Int | 4 | ä¼ è¾“CommitLogæ•°æ®é•¿åº¦ | 
| | | 2 | body | Bytes | size | ä¼ è¾“CommitLogæ•°æ® | 

### 3.1.4 Slave

![HAClienté¡ºåºå›¾](http://www.yunai.me/images/RocketMQ/2017_05_14/02.png)

-------

* **`Slave` ä¸»å¾ªç¯ï¼Œå®ç°äº†**ä¸æ–­ä¸æ–­ä¸æ–­**ä» `Master` ä¼ è¾“ `CommitLog` æ•°æ®ï¼Œä¸Šä¼  `Master` è‡ªå·±æœ¬åœ°çš„ `CommitLog` å·²ç»åŒæ­¥ç‰©ç†ä½ç½®ã€‚**

```Java
  1: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€HAClient.javaã€‘
  2: public void run() {
  3:     log.info(this.getServiceName() + " service started");
  4: 
  5:     while (!this.isStopped()) {
  6:         try {
  7:             if (this.connectMaster()) {
  8:                 // è‹¥åˆ°æ»¡è¶³ä¸ŠæŠ¥é—´éš”ï¼Œä¸ŠæŠ¥åˆ°Masterè¿›åº¦
  9:                 if (this.isTimeToReportOffset()) {
 10:                     boolean result = this.reportSlaveMaxOffset(this.currentReportedOffset);
 11:                     if (!result) {
 12:                         this.closeMaster();
 13:                     }
 14:                 }
 15: 
 16:                 this.selector.select(1000);
 17: 
 18:                 // å¤„ç†è¯»å–äº‹ä»¶
 19:                 boolean ok = this.processReadEvent();
 20:                 if (!ok) {
 21:                     this.closeMaster();
 22:                 }
 23: 
 24:                 // è‹¥è¿›åº¦æœ‰å˜åŒ–ï¼Œä¸ŠæŠ¥åˆ°Masterè¿›åº¦
 25:                 if (!reportSlaveMaxOffsetPlus()) {
 26:                     continue;
 27:                 }
 28: 
 29:                 // Masterè¿‡ä¹…æœªè¿”å›æ•°æ®ï¼Œå…³é—­è¿æ¥
 30:                 long interval = HAService.this.getDefaultMessageStore().getSystemClock().now() - this.lastWriteTimestamp;
 31:                 if (interval > HAService.this.getDefaultMessageStore().getMessageStoreConfig()
 32:                     .getHaHousekeepingInterval()) {
 33:                     log.warn("HAClient, housekeeping, found this connection[" + this.masterAddress
 34:                         + "] expired, " + interval);
 35:                     this.closeMaster();
 36:                     log.warn("HAClient, master not response some time, so close connection");
 37:                 }
 38:             } else {
 39:                 this.waitForRunning(1000 * 5);
 40:             }
 41:         } catch (Exception e) {
 42:             log.warn(this.getServiceName() + " service has exception. ", e);
 43:             this.waitForRunning(1000 * 5);
 44:         }
 45:     }
 46: 
 47:     log.info(this.getServiceName() + " service end");
 48: }
```

* ç¬¬ 8 è‡³ 14 è¡Œ ï¼š**å›ºå®šé—´éš”ï¼ˆé»˜è®¤5sï¼‰**å‘ `Master` ä¸ŠæŠ¥ `Slave` æœ¬åœ° `CommitLog` å·²ç»åŒæ­¥åˆ°çš„ç‰©ç†ä½ç½®ã€‚è¯¥æ“ä½œè¿˜æœ‰**å¿ƒè·³**çš„ä½œç”¨ã€‚
* ç¬¬ 16 è‡³ 22 è¡Œ ï¼šå¤„ç† `Master` ä¼ è¾“ `Slave` çš„ `CommitLog` æ•°æ®ã€‚

-------

* **æˆ‘ä»¬æ¥çœ‹çœ‹ `#dispatchReadRequest(...)` ä¸ `#reportSlaveMaxOffset(...)` æ˜¯æ€ä¹ˆå®ç°çš„ã€‚**

```Java
  1: // ã€HAClient.javaã€‘
  2: /**
  3:  * è¯»å–Masterä¼ è¾“çš„CommitLogæ•°æ®ï¼Œå¹¶è¿”å›æ˜¯å¼‚å¸¸
  4:  * å¦‚æœè¯»å–åˆ°æ•°æ®ï¼Œå†™å…¥CommitLog
  5:  * å¼‚å¸¸åŸå› ï¼š
  6:  *   1. Masterä¼ è¾“æ¥çš„æ•°æ®offset ä¸ç­‰äº Slaveçš„CommitLogæ•°æ®æœ€å¤§offset
  7:  *   2. ä¸ŠæŠ¥åˆ°Masterè¿›åº¦å¤±è´¥
  8:  *
  9:  * @return æ˜¯å¦å¼‚å¸¸
 10:  */
 11: private boolean dispatchReadRequest() {
 12:     final int msgHeaderSize = 8 + 4; // phyoffset + size
 13:     int readSocketPos = this.byteBufferRead.position();
 14: 
 15:     while (true) {
 16:         // è¯»å–åˆ°è¯·æ±‚
 17:         int diff = this.byteBufferRead.position() - this.dispatchPostion;
 18:         if (diff >= msgHeaderSize) {
 19:             // è¯»å–masterPhyOffsetã€bodySizeã€‚ä½¿ç”¨dispatchPostionçš„åŸå› æ˜¯ï¼šå¤„ç†æ•°æ®â€œç²˜åŒ…â€å¯¼è‡´æ•°æ®è¯»å–ä¸å®Œæ•´ã€‚
 20:             long masterPhyOffset = this.byteBufferRead.getLong(this.dispatchPostion);
 21:             int bodySize = this.byteBufferRead.getInt(this.dispatchPostion + 8);
 22:             // æ ¡éªŒ Masterä¼ è¾“æ¥çš„æ•°æ®offset æ˜¯å¦å’Œ Slaveçš„CommitLogæ•°æ®æœ€å¤§offset æ˜¯å¦ç›¸åŒã€‚
 23:             long slavePhyOffset = HAService.this.defaultMessageStore.getMaxPhyOffset();
 24:             if (slavePhyOffset != 0) {
 25:                 if (slavePhyOffset != masterPhyOffset) {
 26:                     log.error("master pushed offset not equal the max phy offset in slave, SLAVE: "
 27:                         + slavePhyOffset + " MASTER: " + masterPhyOffset);
 28:                     return false;
 29:                 }
 30:             }
 31:             // è¯»å–åˆ°æ¶ˆæ¯
 32:             if (diff >= (msgHeaderSize + bodySize)) {
 33:                 // å†™å…¥CommitLog
 34:                 byte[] bodyData = new byte[bodySize];
 35:                 this.byteBufferRead.position(this.dispatchPostion + msgHeaderSize);
 36:                 this.byteBufferRead.get(bodyData);
 37:                 HAService.this.defaultMessageStore.appendToCommitLog(masterPhyOffset, bodyData);
 38:                 // è®¾ç½®å¤„ç†åˆ°çš„ä½ç½®
 39:                 this.byteBufferRead.position(readSocketPos);
 40:                 this.dispatchPostion += msgHeaderSize + bodySize;
 41:                 // ä¸ŠæŠ¥åˆ°Masterè¿›åº¦
 42:                 if (!reportSlaveMaxOffsetPlus()) {
 43:                     return false;
 44:                 }
 45:                 // ç»§ç»­å¾ªç¯
 46:                 continue;
 47:             }
 48:         }
 49: 
 50:         // ç©ºé—´å†™æ»¡ï¼Œé‡æ–°åˆ†é…ç©ºé—´
 51:         if (!this.byteBufferRead.hasRemaining()) {
 52:             this.reallocateByteBuffer();
 53:         }
 54: 
 55:         break;
 56:     }
 57: 
 58:     return true;
 59: }
 60: 
 61: /**
 62:  * ä¸ŠæŠ¥è¿›åº¦
 63:  *
 64:  * @param maxOffset è¿›åº¦
 65:  * @return æ˜¯å¦ä¸ŠæŠ¥æˆåŠŸ
 66:  */
 67: private boolean reportSlaveMaxOffset(final long maxOffset) {
 68:     this.reportOffset.position(0);
 69:     this.reportOffset.limit(8);
 70:     this.reportOffset.putLong(maxOffset);
 71:     this.reportOffset.position(0);
 72:     this.reportOffset.limit(8);
 73: 
 74:     for (int i = 0; i < 3 && this.reportOffset.hasRemaining(); i++) {
 75:         try {
 76:             this.socketChannel.write(this.reportOffset);
 77:         } catch (IOException e) {
 78:             log.error(this.getServiceName()
 79:                 + "reportSlaveMaxOffset this.socketChannel.write exception", e);
 80:             return false;
 81:         }
 82:     }
 83: 
 84:     return !this.reportOffset.hasRemaining();
 85: }
```

### 3.1.5 Master

* **`ReadSocketService` é€»è¾‘åŒ `HAClient#processReadEvent(...)` åŸºæœ¬ç›¸åŒï¼Œæˆ‘ä»¬ç›´æ¥çœ‹ä»£ç ã€‚**

```Java
  1: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€ReadSocketService.javaã€‘
  2: private boolean processReadEvent() {
  3:     int readSizeZeroTimes = 0;
  4: 
  5:     // æ¸…ç©ºbyteBufferRead
  6:     if (!this.byteBufferRead.hasRemaining()) {
  7:         this.byteBufferRead.flip();
  8:         this.processPostion = 0;
  9:     }
 10: 
 11:     while (this.byteBufferRead.hasRemaining()) {
 12:         try {
 13:             int readSize = this.socketChannel.read(this.byteBufferRead);
 14:             if (readSize > 0) {
 15:                 readSizeZeroTimes = 0;
 16: 
 17:                 // è®¾ç½®æœ€åè¯»å–æ—¶é—´
 18:                 this.lastReadTimestamp = HAConnection.this.haService.getDefaultMessageStore().getSystemClock().now();
 19: 
 20:                 if ((this.byteBufferRead.position() - this.processPostion) >= 8) {
 21:                     // è¯»å–Slave è¯·æ±‚æ¥çš„CommitLogçš„æœ€å¤§ä½ç½®
 22:                     int pos = this.byteBufferRead.position() - (this.byteBufferRead.position() % 8);
 23:                     long readOffset = this.byteBufferRead.getLong(pos - 8);
 24:                     this.processPostion = pos;
 25: 
 26:                     // è®¾ç½®Slave CommitLogçš„æœ€å¤§ä½ç½®
 27:                     HAConnection.this.slaveAckOffset = readOffset;
 28: 
 29:                     // è®¾ç½®Slave ç¬¬ä¸€æ¬¡è¯·æ±‚çš„ä½ç½®
 30:                     if (HAConnection.this.slaveRequestOffset < 0) {
 31:                         HAConnection.this.slaveRequestOffset = readOffset;
 32:                         log.info("slave[" + HAConnection.this.clientAddr + "] request offset " + readOffset);
 33:                     }
 34: 
 35:                     // é€šçŸ¥ç›®å‰Slaveè¿›åº¦ã€‚ä¸»è¦ç”¨äºMasterèŠ‚ç‚¹ä¸ºåŒæ­¥ç±»å‹çš„ã€‚
 36:                     HAConnection.this.haService.notifyTransferSome(HAConnection.this.slaveAckOffset);
 37:                 }
 38:             } else if (readSize == 0) {
 39:                 if (++readSizeZeroTimes >= 3) {
 40:                     break;
 41:                 }
 42:             } else {
 43:                 log.error("read socket[" + HAConnection.this.clientAddr + "] < 0");
 44:                 return false;
 45:             }
 46:         } catch (IOException e) {
 47:             log.error("processReadEvent exception", e);
 48:             return false;
 49:         }
 50:     }
 51: 
 52:     return true;
 53: }
```

-------

* **`WriteSocketService` è®¡ç®— `Slave`å¼€å§‹åŒæ­¥çš„ä½ç½®åï¼Œä¸æ–­å‘ `Slave` ä¼ è¾“æ–°çš„ `CommitLog`æ•°æ®ã€‚**

![HA.WriteSocketServiceæµç¨‹å›¾](http://www.yunai.me/images/RocketMQ/2017_05_14/01.png)

```Java
  1: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€WriteSocketService.javaã€‘
  2: @Override
  3: public void run() {
  4:     HAConnection.log.info(this.getServiceName() + " service started");
  5: 
  6:     while (!this.isStopped()) {
  7:         try {
  8:             this.selector.select(1000);
  9: 
 10:             // æœªè·å¾—Slaveè¯»å–è¿›åº¦è¯·æ±‚ï¼Œsleepç­‰å¾…ã€‚
 11:             if (-1 == HAConnection.this.slaveRequestOffset) {
 12:                 Thread.sleep(10);
 13:                 continue;
 14:             }
 15: 
 16:             // è®¡ç®—åˆå§‹åŒ–nextTransferFromWhere
 17:             if (-1 == this.nextTransferFromWhere) {
 18:                 if (0 == HAConnection.this.slaveRequestOffset) {
 19:                     long masterOffset = HAConnection.this.haService.getDefaultMessageStore().getCommitLog().getMaxOffset();
 20:                     masterOffset = masterOffset - (masterOffset % HAConnection.this.haService.getDefaultMessageStore().getMessageStoreConfig().getMapedFileSizeCommitLog());
 21:                     if (masterOffset < 0) {
 22:                         masterOffset = 0;
 23:                     }
 24: 
 25:                     this.nextTransferFromWhere = masterOffset;
 26:                 } else {
 27:                     this.nextTransferFromWhere = HAConnection.this.slaveRequestOffset;
 28:                 }
 29: 
 30:                 log.info("master transfer data from " + this.nextTransferFromWhere + " to slave[" + HAConnection.this.clientAddr
 31:                     + "], and slave request " + HAConnection.this.slaveRequestOffset);
 32:             }
 33: 
 34:             if (this.lastWriteOver) {
 35:                 long interval = HAConnection.this.haService.getDefaultMessageStore().getSystemClock().now() - this.lastWriteTimestamp;
 36:                 if (interval > HAConnection.this.haService.getDefaultMessageStore().getMessageStoreConfig().getHaSendHeartbeatInterval()) { // å¿ƒè·³
 37: 
 38:                     // Build Header
 39:                     this.byteBufferHeader.position(0);
 40:                     this.byteBufferHeader.limit(headerSize);
 41:                     this.byteBufferHeader.putLong(this.nextTransferFromWhere);
 42:                     this.byteBufferHeader.putInt(0);
 43:                     this.byteBufferHeader.flip();
 44: 
 45:                     this.lastWriteOver = this.transferData();
 46:                     if (!this.lastWriteOver)
 47:                         continue;
 48:                 }
 49:             } else { // æœªä¼ è¾“å®Œæˆï¼Œç»§ç»­ä¼ è¾“
 50:                 this.lastWriteOver = this.transferData();
 51:                 if (!this.lastWriteOver)
 52:                     continue;
 53:             }
 54: 
 55:             // é€‰æ‹©æ–°çš„CommitLogæ•°æ®è¿›è¡Œä¼ è¾“
 56:             SelectMappedBufferResult selectResult =
 57:                 HAConnection.this.haService.getDefaultMessageStore().getCommitLogData(this.nextTransferFromWhere);
 58:             if (selectResult != null) {
 59:                 int size = selectResult.getSize();
 60:                 if (size > HAConnection.this.haService.getDefaultMessageStore().getMessageStoreConfig().getHaTransferBatchSize()) {
 61:                     size = HAConnection.this.haService.getDefaultMessageStore().getMessageStoreConfig().getHaTransferBatchSize();
 62:                 }
 63: 
 64:                 long thisOffset = this.nextTransferFromWhere;
 65:                 this.nextTransferFromWhere += size;
 66: 
 67:                 selectResult.getByteBuffer().limit(size);
 68:                 this.selectMappedBufferResult = selectResult;
 69: 
 70:                 // Build Header
 71:                 this.byteBufferHeader.position(0);
 72:                 this.byteBufferHeader.limit(headerSize);
 73:                 this.byteBufferHeader.putLong(thisOffset);
 74:                 this.byteBufferHeader.putInt(size);
 75:                 this.byteBufferHeader.flip();
 76: 
 77:                 this.lastWriteOver = this.transferData();
 78:             } else { // æ²¡æ–°çš„æ¶ˆæ¯ï¼ŒæŒ‚èµ·ç­‰å¾…
 79:                 HAConnection.this.haService.getWaitNotifyObject().allWaitForRunning(100);
 80:             }
 81:         } catch (Exception e) {
 82: 
 83:             HAConnection.log.error(this.getServiceName() + " service has exception.", e);
 84:             break;
 85:         }
 86:     }
 87: 
 88:     // æ–­å¼€è¿æ¥ & æš‚åœå†™çº¿ç¨‹ & æš‚åœè¯»çº¿ç¨‹ & é‡Šæ”¾CommitLog
 89:     if (this.selectMappedBufferResult != null) {
 90:         this.selectMappedBufferResult.release();
 91:     }
 92: 
 93:     this.makeStop();
 94: 
 95:     readSocketService.makeStop();
 96: 
 97:     haService.removeConnection(HAConnection.this);
 98: 
 99:     SelectionKey sk = this.socketChannel.keyFor(this.selector);
100:     if (sk != null) {
101:         sk.cancel();
102:     }
103: 
104:     try {
105:         this.selector.close();
106:         this.socketChannel.close();
107:     } catch (IOException e) {
108:         HAConnection.log.error("", e);
109:     }
110: 
111:     HAConnection.log.info(this.getServiceName() + " service end");
112: }
113: 
114: /**
115:  * ä¼ è¾“æ•°æ®
116:  */
117: private boolean transferData() throws Exception {
118:     int writeSizeZeroTimes = 0;
119:     // Write Header
120:     while (this.byteBufferHeader.hasRemaining()) {
121:         int writeSize = this.socketChannel.write(this.byteBufferHeader);
122:         if (writeSize > 0) {
123:             writeSizeZeroTimes = 0;
124:             this.lastWriteTimestamp = HAConnection.this.haService.getDefaultMessageStore().getSystemClock().now();
125:         } else if (writeSize == 0) {
126:             if (++writeSizeZeroTimes >= 3) {
127:                 break;
128:             }
129:         } else {
130:             throw new Exception("ha master write header error < 0");
131:         }
132:     }
133: 
134:     if (null == this.selectMappedBufferResult) {
135:         return !this.byteBufferHeader.hasRemaining();
136:     }
137: 
138:     writeSizeZeroTimes = 0;
139: 
140:     // Write Body
141:     if (!this.byteBufferHeader.hasRemaining()) {
142:         while (this.selectMappedBufferResult.getByteBuffer().hasRemaining()) {
143:             int writeSize = this.socketChannel.write(this.selectMappedBufferResult.getByteBuffer());
144:             if (writeSize > 0) {
145:                 writeSizeZeroTimes = 0;
146:                 this.lastWriteTimestamp = HAConnection.this.haService.getDefaultMessageStore().getSystemClock().now();
147:             } else if (writeSize == 0) {
148:                 if (++writeSizeZeroTimes >= 3) {
149:                     break;
150:                 }
151:             } else {
152:                 throw new Exception("ha master write body error < 0");
153:             }
154:         }
155:     }
156: 
157:     boolean result = !this.byteBufferHeader.hasRemaining() && !this.selectMappedBufferResult.getByteBuffer().hasRemaining();
158: 
159:     if (!this.selectMappedBufferResult.getByteBuffer().hasRemaining()) {
160:         this.selectMappedBufferResult.release();
161:         this.selectMappedBufferResult = null;
162:     }
163: 
164:     return result;
165: }
```

### 3.1.6 Master_SYNC

* **`Producer` å‘é€æ¶ˆæ¯æ—¶ï¼Œ`Master_SYNC`èŠ‚ç‚¹ ä¼šç­‰å¾… `Slave`èŠ‚ç‚¹ å­˜å‚¨å®Œæ¯•åå†è¿”å›å‘é€ç»“æœã€‚**

æ ¸å¿ƒä»£ç å¦‚ä¸‹ï¼š

```Java
  1: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€CommitLog.javaã€‘
  2: public PutMessageResult putMessage(final MessageExtBrokerInner msg) {
  3:     // ....çœç•¥å¤„ç†å‘é€ä»£ç  
  4:     // Synchronous write double å¦‚æœæ˜¯åŒæ­¥Masterï¼ŒåŒæ­¥åˆ°ä»èŠ‚ç‚¹
  5:     if (BrokerRole.SYNC_MASTER == this.defaultMessageStore.getMessageStoreConfig().getBrokerRole()) {
  6:         HAService service = this.defaultMessageStore.getHaService();
  7:         if (msg.isWaitStoreMsgOK()) {
  8:             // Determine whether to wait
  9:             if (service.isSlaveOK(result.getWroteOffset() + result.getWroteBytes())) {
 10:                 if (null == request) {
 11:                     request = new GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());
 12:                 }
 13:                 service.putRequest(request);
 14: 
 15:                 // å”¤é†’WriteSocketService
 16:                 service.getWaitNotifyObject().wakeupAll();
 17: 
 18:                 boolean flushOK = request.waitForFlush(this.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());
 19:                 if (!flushOK) {
 20:                     log.error("do sync transfer other node, wait return, but failed, topic: " + msg.getTopic() + " tags: "
 21:                         + msg.getTags() + " client address: " + msg.getBornHostString());
 22:                     putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_SLAVE_TIMEOUT);
 23:                 }
 24:             }
 25:             // Slave problem
 26:             else {
 27:                 // Tell the producer, slave not available
 28:                 putMessageResult.setPutMessageStatus(PutMessageStatus.SLAVE_NOT_AVAILABLE);
 29:             }
 30:         }
 31:     }
 32: 
 33:     return putMessageResult;
 34: }
```

* ç¬¬ 16 è¡Œ ï¼šå”¤é†’ `WriteSocketService`ã€‚
    * å”¤é†’åï¼Œ`WriteSocketService` æŒ‚èµ·ç­‰å¾…æ–°æ¶ˆæ¯ç»“æŸï¼Œ`Master` ä¼ è¾“ `Slave` æ–°çš„ `CommitLog` æ•°æ®ã€‚
    * `Slave` æ”¶åˆ°æ•°æ®åï¼Œ**ç«‹å³**ä¸ŠæŠ¥æœ€æ–°çš„ `CommitLog` åŒæ­¥è¿›åº¦åˆ° `Master`ã€‚`ReadSocketService` å”¤é†’**ç¬¬ 18 è¡Œ**ï¼š`request#waitForFlush(...)`ã€‚

æˆ‘ä»¬æ¥çœ‹ä¸‹ `GroupTransferService` çš„æ ¸å¿ƒé€»è¾‘ä»£ç ï¼š

```Java
  1: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€GroupTransferService.javaã€‘
  2: private void doWaitTransfer() {
  3:     synchronized (this.requestsRead) {
  4:         if (!this.requestsRead.isEmpty()) {
  5:             for (CommitLog.GroupCommitRequest req : this.requestsRead) {
  6:                 // ç­‰å¾…Slaveä¸Šä¼ è¿›åº¦
  7:                 boolean transferOK = HAService.this.push2SlaveMaxOffset.get() >= req.getNextOffset();
  8:                 for (int i = 0; !transferOK && i < 5; i++) {
  9:                     this.notifyTransferObject.waitForRunning(1000); // å”¤é†’
 10:                     transferOK = HAService.this.push2SlaveMaxOffset.get() >= req.getNextOffset();
 11:                 }
 12: 
 13:                 if (!transferOK) {
 14:                     log.warn("transfer messsage to slave timeout, " + req.getNextOffset());
 15:                 }
 16: 
 17:                 // å”¤é†’è¯·æ±‚ï¼Œå¹¶è®¾ç½®æ˜¯å¦SlaveåŒæ­¥æˆåŠŸ
 18:                 req.wakeupCustomer(transferOK);
 19:             }
 20: 
 21:             this.requestsRead.clear();
 22:         }
 23:     }
 24: }
```

## 3.2 Producer å‘é€æ¶ˆæ¯

* **`Producer` å‘é€æ¶ˆæ¯æ—¶ï¼Œä¼šå¯¹ `Broker`é›†ç¾¤ çš„æ‰€æœ‰é˜Ÿåˆ—è¿›è¡Œé€‰æ‹©ã€‚**

æ ¸å¿ƒä»£ç å¦‚ä¸‹ï¼š

```Java
  1: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€DefaultMQProducerImpl.javaã€‘
  2: private SendResult sendDefaultImpl(//
  3:     Message msg, //
  4:     final CommunicationMode communicationMode, //
  5:     final SendCallback sendCallback, //
  6:     final long timeout//
  7: ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
  8:     // .... çœç•¥ï¼šå¤„ç†ã€æ ¡éªŒé€»è¾‘ã€‘
  9:     // è·å– Topicè·¯ç”±ä¿¡æ¯
 10:     TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic());
 11:     if (topicPublishInfo != null && topicPublishInfo.ok()) {
 12:         MessageQueue mq = null; // æœ€åé€‰æ‹©æ¶ˆæ¯è¦å‘é€åˆ°çš„é˜Ÿåˆ—
 13:         Exception exception = null;
 14:         SendResult sendResult = null; // æœ€åä¸€æ¬¡å‘é€ç»“æœ
 15:         int timesTotal = communicationMode == CommunicationMode.SYNC ? 1 + this.defaultMQProducer.getRetryTimesWhenSendFailed() : 1; // åŒæ­¥å¤šæ¬¡è°ƒç”¨
 16:         int times = 0; // ç¬¬å‡ æ¬¡å‘é€
 17:         String[] brokersSent = new String[timesTotal]; // å­˜å‚¨æ¯æ¬¡å‘é€æ¶ˆæ¯é€‰æ‹©çš„brokerå
 18:         // å¾ªç¯è°ƒç”¨å‘é€æ¶ˆæ¯ï¼Œç›´åˆ°æˆåŠŸ
 19:         for (; times < timesTotal; times++) {
 20:             String lastBrokerName = null == mq ? null : mq.getBrokerName();
 21:             MessageQueue tmpmq = this.selectOneMessageQueue(topicPublishInfo, lastBrokerName); // é€‰æ‹©æ¶ˆæ¯è¦å‘é€åˆ°çš„é˜Ÿåˆ—
 22:             if (tmpmq != null) {
 23:                 mq = tmpmq;
 24:                 brokersSent[times] = mq.getBrokerName();
 25:                 try {
 26:                     beginTimestampPrev = System.currentTimeMillis();
 27:                     // è°ƒç”¨å‘é€æ¶ˆæ¯æ ¸å¿ƒæ–¹æ³•
 28:                     sendResult = this.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout);
 29:                     endTimestamp = System.currentTimeMillis();
 30:                     // æ›´æ–°Brokerå¯ç”¨æ€§ä¿¡æ¯
 31:                     this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false);
 32:                     // .... çœç•¥ï¼šå¤„ç†ã€å‘é€è¿”å›ç»“æœã€‘
 33:                     }
 34:                 } catch (e) { // .... çœç•¥ï¼šå¤„ç†ã€å¼‚å¸¸ã€‘
 35:                     
 36:                 }
 37:             } else {
 38:                 break;
 39:             }
 40:         }
 41:         // .... çœç•¥ï¼šå¤„ç†ã€å‘é€è¿”å›ç»“æœã€‘
 42:     }
 43:     // .... çœç•¥ï¼šå¤„ç†ã€æ‰¾ä¸åˆ°æ¶ˆæ¯è·¯ç”±ã€‘
 44: }
```

å¦‚ä¸‹æ˜¯è°ƒè¯• `#sendDefaultImpl(...)` æ—¶ `TopicPublishInfo` çš„ç»“æœï¼Œ`Producer` è·å¾—åˆ°äº† `broker-a`,`broker-b` ä¸¤ä¸ª `Broker`åˆ†ç»„ çš„æ¶ˆæ¯é˜Ÿåˆ—ï¼š
![Producer.TopicPublishInfo.è°ƒè¯•.png](http://www.yunai.me/images/RocketMQ/2017_05_14/05.png)

## 3.3 Consumer æ¶ˆè´¹æ¶ˆæ¯

* **`Consumer` æ¶ˆè´¹æ¶ˆæ¯æ—¶ï¼Œä¼šå¯¹ `Broker`é›†ç¾¤ çš„æ‰€æœ‰é˜Ÿåˆ—è¿›è¡Œé€‰æ‹©ã€‚**

# 4. æ€»ç»“

![HAæ€»ç»“.jpeg](http://www.yunai.me/images/RocketMQ/2017_05_14/03.jpeg)


