title: RocketMQ æºç åˆ†æ â€”â€” äº‹åŠ¡æ¶ˆæ¯
date: 2017-05-21
tags:
categories: RocketMQ
permalink: RocketMQ/message-transaction

-------

![](http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg)

> ğŸ™‚ğŸ™‚ğŸ™‚å…³æ³¨**å¾®ä¿¡å…¬ä¼—å·ï¼šã€èŠ‹é“æºç ã€‘**æœ‰ç¦åˆ©ï¼š  
> 1. RocketMQ / MyCAT / Sharding-JDBC **æ‰€æœ‰**æºç åˆ†ææ–‡ç« åˆ—è¡¨  
> 2. RocketMQ / MyCAT / Sharding-JDBC **ä¸­æ–‡æ³¨é‡Šæºç  GitHub åœ°å€**  
> 3. æ‚¨å¯¹äºæºç çš„ç–‘é—®æ¯æ¡ç•™è¨€**éƒ½**å°†å¾—åˆ°**è®¤çœŸ**å›å¤ã€‚**ç”šè‡³ä¸çŸ¥é“å¦‚ä½•è¯»æºç ä¹Ÿå¯ä»¥è¯·æ•™å™¢**ã€‚  
> 4. **æ–°çš„**æºç è§£ææ–‡ç« **å®æ—¶**æ”¶åˆ°é€šçŸ¥ã€‚**æ¯å‘¨æ›´æ–°ä¸€ç¯‡å·¦å³**ã€‚
> 5. **è®¤çœŸçš„**æºç äº¤æµå¾®ä¿¡ç¾¤ã€‚

-------

- [1. æ¦‚è¿°](#)
- [2. äº‹åŠ¡æ¶ˆæ¯å‘é€](#)
	- [2.1 Producer å‘é€äº‹åŠ¡æ¶ˆæ¯](#)
	- [2.2 Broker å¤„ç†ç»“æŸäº‹åŠ¡è¯·æ±‚](#)
	- [2.3 Broker ç”Ÿæˆ ConsumeQueue](#)
- [3. äº‹åŠ¡æ¶ˆæ¯å›æŸ¥](#)
	- [3.1 Broker å‘èµ·ã€äº‹åŠ¡æ¶ˆæ¯å›æŸ¥ã€‘](#)
		- [3.1.1 å®˜æ–¹V3.1.4ï¼šåŸºäºæ–‡ä»¶ç³»ç»Ÿ](#)
			- [3.1.1.1 å­˜å‚¨æ¶ˆæ¯åˆ° CommitLog](#)
			- [3.1.1.2 å†™ã€äº‹åŠ¡æ¶ˆæ¯ã€‘çŠ¶æ€å­˜å‚¨ï¼ˆTranStateTableï¼‰](#)
			- [3.1.1.3 ã€äº‹åŠ¡æ¶ˆæ¯ã€‘å›æŸ¥](#)
			- [3.1.1.4 åˆå§‹åŒ–ã€äº‹åŠ¡æ¶ˆæ¯ã€‘çŠ¶æ€å­˜å‚¨ï¼ˆTranStateTableï¼‰](#)
			- [3.1.1.5 è¡¥å……](#)
		- [3.1.2 å®˜æ–¹V4.0.0ï¼šåŸºäºæ•°æ®åº“](#)
	- [3.2 Producer æ¥æ”¶ã€äº‹åŠ¡æ¶ˆæ¯å›æŸ¥ã€‘](#)

# 1. æ¦‚è¿°

**å¿…é¡»å¿…é¡»å¿…é¡»** å‰ç½®é˜…è¯»å†…å®¹ï¼š

* [ã€Šäº‹åŠ¡æ¶ˆæ¯ï¼ˆé˜¿é‡Œäº‘ï¼‰ã€‹](https://help.aliyun.com/document_detail/43348.html?spm=5176.doc43490.6.566.Zd5Bl7)

# 2. äº‹åŠ¡æ¶ˆæ¯å‘é€

## 2.1 Producer å‘é€äº‹åŠ¡æ¶ˆæ¯

* æ´»åŠ¨å›¾å¦‚ä¸‹ï¼ˆç»“åˆ `æ ¸å¿ƒä»£ç ` ç†è§£ï¼‰ï¼š

![Producerå‘é€äº‹åŠ¡æ¶ˆæ¯](http://www.iocoder.cn/images/RocketMQ/2017_05_21/03.png)

* å®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
  1: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€DefaultMQProducerImpl.javaã€‘
  2: /**
  3:  * å‘é€äº‹åŠ¡æ¶ˆæ¯
  4:  *
  5:  * @param msg æ¶ˆæ¯
  6:  * @param tranExecuter ã€æœ¬åœ°äº‹åŠ¡ã€‘æ‰§è¡Œå™¨
  7:  * @param arg ã€æœ¬åœ°äº‹åŠ¡ã€‘æ‰§è¡Œå™¨å‚æ•°
  8:  * @return äº‹åŠ¡å‘é€ç»“æœ
  9:  * @throws MQClientException å½“ Client å‘ç”Ÿå¼‚å¸¸æ—¶
 10:  */
 11: public TransactionSendResult sendMessageInTransaction(final Message msg, final LocalTransactionExecuter tranExecuter, final Object arg)
 12:     throws MQClientException {
 13:     if (null == tranExecuter) {
 14:         throw new MQClientException("tranExecutor is null", null);
 15:     }
 16:     Validators.checkMessage(msg, this.defaultMQProducer);
 17: 
 18:     // å‘é€ã€Halfæ¶ˆæ¯ã€‘
 19:     SendResult sendResult;
 20:     MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, "true");
 21:     MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, this.defaultMQProducer.getProducerGroup());
 22:     try {
 23:         sendResult = this.send(msg);
 24:     } catch (Exception e) {
 25:         throw new MQClientException("send message Exception", e);
 26:     }
 27: 
 28:     // å¤„ç†å‘é€ã€Halfæ¶ˆæ¯ã€‘ç»“æœ
 29:     LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;
 30:     Throwable localException = null;
 31:     switch (sendResult.getSendStatus()) {
 32:         // å‘é€ã€Halfæ¶ˆæ¯ã€‘æˆåŠŸï¼Œæ‰§è¡Œã€æœ¬åœ°äº‹åŠ¡ã€‘é€»è¾‘
 33:         case SEND_OK: {
 34:             try {
 35:                 if (sendResult.getTransactionId() != null) { // äº‹åŠ¡ç¼–å·ã€‚ç›®å‰å¼€æºç‰ˆæœ¬æš‚æ—¶æ²¡ç”¨åˆ°ï¼ŒçŒœæƒ³ONSåœ¨ä½¿ç”¨ã€‚
 36:                     msg.putUserProperty("__transactionId__", sendResult.getTransactionId());
 37:                 }
 38: 
 39:                 // æ‰§è¡Œã€æœ¬åœ°äº‹åŠ¡ã€‘é€»è¾‘
 40:                 localTransactionState = tranExecuter.executeLocalTransactionBranch(msg, arg);
 41:                 if (null == localTransactionState) {
 42:                     localTransactionState = LocalTransactionState.UNKNOW;
 43:                 }
 44: 
 45:                 if (localTransactionState != LocalTransactionState.COMMIT_MESSAGE) {
 46:                     log.info("executeLocalTransactionBranch return {}", localTransactionState);
 47:                     log.info(msg.toString());
 48:                 }
 49:             } catch (Throwable e) {
 50:                 log.info("executeLocalTransactionBranch exception", e);
 51:                 log.info(msg.toString());
 52:                 localException = e;
 53:             }
 54:         }
 55:         break;
 56:         // å‘é€ã€Halfæ¶ˆæ¯ã€‘å¤±è´¥ï¼Œæ ‡è®°ã€æœ¬åœ°äº‹åŠ¡ã€‘çŠ¶æ€ä¸ºå›æ»š
 57:         case FLUSH_DISK_TIMEOUT:
 58:         case FLUSH_SLAVE_TIMEOUT:
 59:         case SLAVE_NOT_AVAILABLE:
 60:             localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE;
 61:             break;
 62:         default:
 63:             break;
 64:     }
 65: 
 66:     // ç»“æŸäº‹åŠ¡ï¼šæäº¤æ¶ˆæ¯ COMMIT / ROLLBACK
 67:     try {
 68:         this.endTransaction(sendResult, localTransactionState, localException);
 69:     } catch (Exception e) {
 70:         log.warn("local transaction execute " + localTransactionState + ", but end broker transaction failed", e);
 71:     }
 72: 
 73:     // è¿”å›ã€äº‹åŠ¡å‘é€ç»“æœã€‘
 74:     TransactionSendResult transactionSendResult = new TransactionSendResult();
 75:     transactionSendResult.setSendStatus(sendResult.getSendStatus());
 76:     transactionSendResult.setMessageQueue(sendResult.getMessageQueue());
 77:     transactionSendResult.setMsgId(sendResult.getMsgId());
 78:     transactionSendResult.setQueueOffset(sendResult.getQueueOffset());
 79:     transactionSendResult.setTransactionId(sendResult.getTransactionId());
 80:     transactionSendResult.setLocalTransactionState(localTransactionState);
 81:     return transactionSendResult;
 82: }
 83: 
 84: /**
 85:  * ç»“æŸäº‹åŠ¡ï¼šæäº¤æ¶ˆæ¯ COMMIT / ROLLBACK
 86:  *
 87:  * @param sendResult å‘é€ã€Halfæ¶ˆæ¯ã€‘ç»“æœ
 88:  * @param localTransactionState ã€æœ¬åœ°äº‹åŠ¡ã€‘çŠ¶æ€
 89:  * @param localException æ‰§è¡Œã€æœ¬åœ°äº‹åŠ¡ã€‘é€»è¾‘äº§ç”Ÿçš„å¼‚å¸¸
 90:  * @throws RemotingException å½“è¿œç¨‹è°ƒç”¨å‘ç”Ÿå¼‚å¸¸æ—¶
 91:  * @throws MQBrokerException å½“ Broker å‘ç”Ÿå¼‚å¸¸æ—¶
 92:  * @throws InterruptedException å½“çº¿ç¨‹ä¸­æ–­æ—¶
 93:  * @throws UnknownHostException å½“è§£ç æ¶ˆæ¯ç¼–å·å¤±è´¥æ˜¯
 94:  */
 95: public void endTransaction(//
 96:     final SendResult sendResult, //
 97:     final LocalTransactionState localTransactionState, //
 98:     final Throwable localException) throws RemotingException, MQBrokerException, InterruptedException, UnknownHostException {
 99:     // è§£ç æ¶ˆæ¯ç¼–å·
100:     final MessageId id;
101:     if (sendResult.getOffsetMsgId() != null) {
102:         id = MessageDecoder.decodeMessageId(sendResult.getOffsetMsgId());
103:     } else {
104:         id = MessageDecoder.decodeMessageId(sendResult.getMsgId());
105:     }
106: 
107:     // åˆ›å»ºè¯·æ±‚
108:     String transactionId = sendResult.getTransactionId();
109:     final String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(sendResult.getMessageQueue().getBrokerName());
110:     EndTransactionRequestHeader requestHeader = new EndTransactionRequestHeader();
111:     requestHeader.setTransactionId(transactionId);
112:     requestHeader.setCommitLogOffset(id.getOffset());
113:     switch (localTransactionState) {
114:         case COMMIT_MESSAGE:
115:             requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);
116:             break;
117:         case ROLLBACK_MESSAGE:
118:             requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);
119:             break;
120:         case UNKNOW:
121:             requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);
122:             break;
123:         default:
124:             break;
125:     }
126:     requestHeader.setProducerGroup(this.defaultMQProducer.getProducerGroup());
127:     requestHeader.setTranStateTableOffset(sendResult.getQueueOffset());
128:     requestHeader.setMsgId(sendResult.getMsgId());
129:     String remark = localException != null ? ("executeLocalTransactionBranch exception: " + localException.toString()) : null;
130: 
131:     // æäº¤æ¶ˆæ¯ COMMIT / ROLLBACKã€‚ï¼ï¼ï¼é€šä¿¡æ–¹å¼ä¸ºï¼šOnewayï¼ï¼ï¼
132:     this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, requestHeader, remark, this.defaultMQProducer.getSendMsgTimeout());
133: }
```

## 2.2 Broker å¤„ç†ç»“æŸäº‹åŠ¡è¯·æ±‚

* ğŸ¦… æŸ¥è¯¢è¯·æ±‚çš„æ¶ˆæ¯ï¼Œè¿›è¡Œ**æäº¤ / å›æ»š**ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
  1: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€EndTransactionProcessor.javaã€‘
  2: public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException {
  3:     final RemotingCommand response = RemotingCommand.createResponseCommand(null);
  4:     final EndTransactionRequestHeader requestHeader = (EndTransactionRequestHeader) request.decodeCommandCustomHeader(EndTransactionRequestHeader.class);
  5: 
  6:     // çœç•¥ä»£ç  =ã€‹æ‰“å°æ—¥å¿—ï¼ˆåªå¤„ç† COMMIT / ROLLBACKï¼‰
  7: 
  8:     // æŸ¥è¯¢æäº¤çš„æ¶ˆæ¯
  9:     final MessageExt msgExt = this.brokerController.getMessageStore().lookMessageByOffset(requestHeader.getCommitLogOffset());
 10:     if (msgExt != null) {
 11:         // çœç•¥ä»£ç  =ã€‹æ ¡éªŒæ¶ˆæ¯
 12: 
 13:         // ç”Ÿæˆæ¶ˆæ¯
 14:         MessageExtBrokerInner msgInner = this.endMessageTransaction(msgExt);
 15:         msgInner.setSysFlag(MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), requestHeader.getCommitOrRollback()));
 16:         msgInner.setQueueOffset(requestHeader.getTranStateTableOffset());
 17:         msgInner.setPreparedTransactionOffset(requestHeader.getCommitLogOffset());
 18:         msgInner.setStoreTimestamp(msgExt.getStoreTimestamp());
 19:         if (MessageSysFlag.TRANSACTION_ROLLBACK_TYPE == requestHeader.getCommitOrRollback()) {
 20:             msgInner.setBody(null);
 21:         }
 22: 
 23:         // å­˜å‚¨ç”Ÿæˆæ¶ˆæ¯
 24:         final MessageStore messageStore = this.brokerController.getMessageStore();
 25:         final PutMessageResult putMessageResult = messageStore.putMessage(msgInner);
 26: 
 27:         // å¤„ç†å­˜å‚¨ç»“æœ
 28:         if (putMessageResult != null) {
 29:             switch (putMessageResult.getPutMessageStatus()) {
 30:                 // Success
 31:                 case PUT_OK:
 32:                 case FLUSH_DISK_TIMEOUT:
 33:                 case FLUSH_SLAVE_TIMEOUT:
 34:                 case SLAVE_NOT_AVAILABLE:
 35:                     response.setCode(ResponseCode.SUCCESS);
 36:                     response.setRemark(null);
 37:                     break;
 38:                 // Failed
 39:                 case CREATE_MAPEDFILE_FAILED:
 40:                     response.setCode(ResponseCode.SYSTEM_ERROR);
 41:                     response.setRemark("create maped file failed.");
 42:                     break;
 43:                 case MESSAGE_ILLEGAL:
 44:                 case PROPERTIES_SIZE_EXCEEDED:
 45:                     response.setCode(ResponseCode.MESSAGE_ILLEGAL);
 46:                     response.setRemark("the message is illegal, maybe msg body or properties length not matched. msg body length limit 128k, msg properties length limit 32k.");
 47:                     break;
 48:                 case SERVICE_NOT_AVAILABLE:
 49:                     response.setCode(ResponseCode.SERVICE_NOT_AVAILABLE);
 50:                     response.setRemark("service not available now.");
 51:                     break;
 52:                 case OS_PAGECACHE_BUSY:
 53:                     response.setCode(ResponseCode.SYSTEM_ERROR);
 54:                     response.setRemark("OS page cache busy, please try another machine");
 55:                     break;
 56:                 case UNKNOWN_ERROR:
 57:                     response.setCode(ResponseCode.SYSTEM_ERROR);
 58:                     response.setRemark("UNKNOWN_ERROR");
 59:                     break;
 60:                 default:
 61:                     response.setCode(ResponseCode.SYSTEM_ERROR);
 62:                     response.setRemark("UNKNOWN_ERROR DEFAULT");
 63:                     break;
 64:             }
 65: 
 66:             return response;
 67:         } else {
 68:             response.setCode(ResponseCode.SYSTEM_ERROR);
 69:             response.setRemark("store putMessage return null");
 70:         }
 71:     } else {
 72:         response.setCode(ResponseCode.SYSTEM_ERROR);
 73:         response.setRemark("find prepared transaction message failed");
 74:         return response;
 75:     }
 76: 
 77:     return response;
 78: }
```

## 2.3 Broker ç”Ÿæˆ ConsumeQueue

* ğŸ¦… äº‹åŠ¡æ¶ˆæ¯ï¼Œæäº¤ï¼ˆ`COMMIT`ï¼‰åæ‰ç”Ÿæˆ `ConsumeQueue`ã€‚

```Java
  1: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€DefaultMessageStore.javaã€‘
  2: public void doDispatch(DispatchRequest req) {
  3:     // éäº‹åŠ¡æ¶ˆæ¯ æˆ– äº‹åŠ¡æäº¤æ¶ˆæ¯ å»ºç«‹ æ¶ˆæ¯ä½ç½®ä¿¡æ¯ åˆ° ConsumeQueue
  4:     final int tranType = MessageSysFlag.getTransactionValue(req.getSysFlag());
  5:     switch (tranType) {
  6:         case MessageSysFlag.TRANSACTION_NOT_TYPE: // éäº‹åŠ¡æ¶ˆæ¯
  7:         case MessageSysFlag.TRANSACTION_COMMIT_TYPE: // äº‹åŠ¡æ¶ˆæ¯COMMIT
  8:             DefaultMessageStore.this.putMessagePositionInfo(req.getTopic(), req.getQueueId(), req.getCommitLogOffset(), req.getMsgSize(),
  9:                 req.getTagsCode(), req.getStoreTimestamp(), req.getConsumeQueueOffset());
 10:             break;
 11:         case MessageSysFlag.TRANSACTION_PREPARED_TYPE: // äº‹åŠ¡æ¶ˆæ¯PREPARED
 12:         case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE: // äº‹åŠ¡æ¶ˆæ¯ROLLBACK
 13:             break;
 14:     }
 15:     // çœç•¥ä»£ç  =ã€‹ å»ºç«‹ ç´¢å¼•ä¿¡æ¯ åˆ° IndexFile
 16: }
```

# 3. äº‹åŠ¡æ¶ˆæ¯å›æŸ¥

* ã€äº‹åŠ¡æ¶ˆæ¯å›æŸ¥ã€‘åŠŸèƒ½æ›¾ç»å¼€æºè¿‡ï¼Œç›®å‰ï¼ˆV4.0.0ï¼‰æš‚æœªå¼€æºã€‚å¦‚ä¸‹æ˜¯è¯¥åŠŸèƒ½çš„å¼€æºæƒ…å†µï¼š

| ç‰ˆæœ¬ | ã€äº‹åŠ¡æ¶ˆæ¯å›æŸ¥ã€‘ | |
| --- | --- | --- |
| å®˜æ–¹V3.0.4 ~ V3.1.4 | åŸºäº æ–‡ä»¶ç³»ç»Ÿ å®ç° | å·²å¼€æº |
| å®˜æ–¹V3.1.5 ~ V4.0.0 | åŸºäº æ•°æ®åº“ å®ç° | æœªå®Œå…¨å¼€æº |

æˆ‘ä»¬æ¥çœ‹çœ‹ä¸¤ç§æƒ…å†µä¸‹æ˜¯æ€ä¹ˆå®ç°çš„ã€‚

## 3.1 Broker å‘èµ·ã€äº‹åŠ¡æ¶ˆæ¯å›æŸ¥ã€‘

### 3.1.1 å®˜æ–¹V3.1.4ï¼šåŸºäºæ–‡ä»¶ç³»ç»Ÿ

> ä»“åº“åœ°å€ï¼šhttps://github.com/YunaiV/rocketmq-3.1.9/tree/release_3.1.4

ç›¸è¾ƒäºæ™®é€šæ¶ˆæ¯ï¼Œã€äº‹åŠ¡æ¶ˆæ¯ã€‘å¤šä¾èµ–å¦‚ä¸‹ä¸‰ä¸ªç»„ä»¶ï¼š

* **TransactionStateService** ï¼šäº‹åŠ¡çŠ¶æ€æœåŠ¡ï¼Œè´Ÿè´£å¯¹ã€äº‹åŠ¡æ¶ˆæ¯ã€‘è¿›è¡Œç®¡ç†ï¼ŒåŒ…æ‹¬å­˜å‚¨ä¸æ›´æ–°äº‹åŠ¡æ¶ˆæ¯çŠ¶æ€ã€å›æŸ¥äº‹åŠ¡æ¶ˆæ¯çŠ¶æ€ç­‰ç­‰ã€‚
* **TranStateTable** ï¼šã€äº‹åŠ¡æ¶ˆæ¯ã€‘çŠ¶æ€å­˜å‚¨ã€‚åŸºäº `MappedFileQueue` å®ç°ï¼Œé»˜è®¤å­˜å‚¨è·¯å¾„ä¸º `~/store/transaction/statetable`ï¼Œæ¯æ¡ã€äº‹åŠ¡æ¶ˆæ¯ã€‘çŠ¶æ€å­˜å‚¨ç»“æ„å¦‚ä¸‹ï¼š

| ç¬¬å‡ ä½ | å­—æ®µ | è¯´æ˜ | æ•°æ®ç±»å‹ | å­—èŠ‚æ•° |
| :-- | :-- | :-- | :-- | :-- |
| 1 | offset | CommitLog ç‰©ç†å­˜å‚¨ä½ç½® | Long | 8 |
| 2 | size | æ¶ˆæ¯é•¿åº¦ | Int | 4 |
| 3 | timestamp | æ¶ˆæ¯å­˜å‚¨æ—¶é—´ï¼Œå•ä½ï¼šç§’ | Int | 4 |
| 4 | producerGroupHash | producerGroup æ±‚ HashCode | Int | 4 |
| 5 | state | äº‹åŠ¡çŠ¶æ€ | Int | 4 |

* **TranRedoLog** ï¼š`TranStateTable` é‡æ”¾æ—¥å¿—ï¼Œæ¯æ¬¡**å†™æ“ä½œ** `TranStateTable` è®°å½•é‡æ”¾æ—¥å¿—ã€‚å½“ `Broker` å¼‚å¸¸å…³é—­æ—¶ï¼Œä½¿ç”¨ `TranRedoLog` æ¢å¤ `TranStateTable`ã€‚åŸºäº `ConsumeQueue` å®ç°ï¼Œ`Topic` ä¸º `TRANSACTION_REDOLOG_TOPIC_XXXX`ï¼Œé»˜è®¤å­˜å‚¨è·¯å¾„ä¸º `~/store/transaction/redolog`ã€‚

-------

ç®€å•æ‰‹ç»˜é€»è¾‘å›¾å¦‚ä¸‹ğŸ˜ˆï¼š

![Broker_V3.1.4_åŸºäºæ–‡ä»¶ç³»ç»Ÿ](http://www.iocoder.cn/images/RocketMQ/2017_05_21/01.jpeg)

#### 3.1.1.1 å­˜å‚¨æ¶ˆæ¯åˆ° CommitLog

* ğŸ¦…å­˜å‚¨ã€halfæ¶ˆæ¯ã€‘åˆ° `CommitLog` æ—¶ï¼Œæ¶ˆæ¯é˜Ÿåˆ—ä½ç½®ï¼ˆ`queueOffset`ï¼‰ä½¿ç”¨ `TranStateTable` æœ€å¤§ç‰©ç†ä½ç½®ï¼ˆå¯å†™å…¥ç‰©ç†ä½ç½®ï¼‰ã€‚è¿™æ ·ï¼Œæ¶ˆæ¯å¯ä»¥ç´¢å¼•åˆ°è‡ªå·±å¯¹åº”çš„ `TranStateTable` çš„ä½ç½®å’Œè®°å½•ã€‚

æ ¸å¿ƒä»£ç å¦‚ä¸‹ï¼š

```Java
  1: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€DefaultAppendMessageCallback.javaã€‘
  2: class DefaultAppendMessageCallback implements AppendMessageCallback {
  3:     public AppendMessageResult doAppend(final long fileFromOffset, final ByteBuffer byteBuffer,  final int maxBlank, final Object msg) {
  4:         // ...çœç•¥ä»£ç 
  5: 
  6:         // äº‹åŠ¡æ¶ˆæ¯éœ€è¦ç‰¹æ®Šå¤„ç† 
  7:         final int tranType = MessageSysFlag.getTransactionValue(msgInner.getSysFlag());
  8:         switch (tranType) {
  9:         case MessageSysFlag.TransactionPreparedType: // æ¶ˆæ¯é˜Ÿåˆ—ä½ç½®ï¼ˆqueueOffsetï¼‰ä½¿ç”¨ TranStateTable æœ€å¤§ç‰©ç†ä½ç½®ï¼ˆå¯å†™å…¥ç‰©ç†ä½ç½®ï¼‰ 
 10:             queueOffset = CommitLog.this.defaultMessageStore.getTransactionStateService().getTranStateTableOffset().get();
 11:             break;
 12:         case MessageSysFlag.TransactionRollbackType:
 13:             queueOffset = msgInner.getQueueOffset();
 14:             break;
 15:         case MessageSysFlag.TransactionNotType:
 16:         case MessageSysFlag.TransactionCommitType:
 17:         default:
 18:             break;
 19:         }
 20: 
 21:         // ...çœç•¥ä»£ç 
 22: 
 23:         switch (tranType) {
 24:         case MessageSysFlag.TransactionPreparedType:
 25:             // æ›´æ–° TranStateTable æœ€å¤§ç‰©ç†ä½ç½®ï¼ˆå¯å†™å…¥ç‰©ç†ä½ç½®ï¼‰ 
 26:             CommitLog.this.defaultMessageStore.getTransactionStateService().getTranStateTableOffset().incrementAndGet();
 27:             break;
 28:         case MessageSysFlag.TransactionRollbackType:
 29:             break;
 30:         case MessageSysFlag.TransactionNotType:
 31:         case MessageSysFlag.TransactionCommitType:
 32:             // æ›´æ–°ä¸‹ä¸€æ¬¡çš„ConsumeQueueä¿¡æ¯
 33:             CommitLog.this.topicQueueTable.put(key, ++queueOffset);
 34:             break;
 35:         default:
 36:             break;
 37:         }
 38: 
 39:         // è¿”å›ç»“æœ
 40:         return result;
 41:     }
 42: }
```

#### 3.1.1.2 å†™ã€äº‹åŠ¡æ¶ˆæ¯ã€‘çŠ¶æ€å­˜å‚¨ï¼ˆTranStateTableï¼‰

* ğŸ¦…å¤„ç†ã€Halfæ¶ˆæ¯ã€‘æ—¶ï¼Œæ–°å¢ã€äº‹åŠ¡æ¶ˆæ¯ã€‘çŠ¶æ€å­˜å‚¨ï¼ˆ`TranStateTable`ï¼‰ã€‚
* ğŸ¦…å¤„ç†ã€Commit / Rollbackæ¶ˆæ¯ã€‘æ—¶ï¼Œæ›´æ–° ã€äº‹åŠ¡æ¶ˆæ¯ã€‘çŠ¶æ€å­˜å‚¨ï¼ˆ`TranStateTable`ï¼‰ COMMIT / ROLLBACKã€‚
* ğŸ¦…æ¯æ¬¡**å†™æ“ä½œã€**äº‹åŠ¡æ¶ˆæ¯ã€‘çŠ¶æ€å­˜å‚¨ï¼ˆ`TranStateTable`ï¼‰ï¼Œè®°å½•é‡æ”¾æ—¥å¿—ï¼ˆ`TranRedoLog`ï¼‰ã€‚

æ ¸å¿ƒä»£ç å¦‚ä¸‹ï¼š

```Java
  1: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€DispatchMessageService.javaã€‘
  2: private void doDispatch() {
  3:     if (!this.requestsRead.isEmpty()) {
  4:         for (DispatchRequest req : this.requestsRead) {
  5: 
  6:             // ...çœç•¥ä»£ç 
  7: 
  8:             // 2ã€å†™ã€äº‹åŠ¡æ¶ˆæ¯ã€‘çŠ¶æ€å­˜å‚¨ï¼ˆTranStateTableï¼‰
  9:             if (req.getProducerGroup() != null) {
 10:                 switch (tranType) {
 11:                 case MessageSysFlag.TransactionNotType:
 12:                     break;
 13:                 case MessageSysFlag.TransactionPreparedType:
 14:                     // æ–°å¢ ã€äº‹åŠ¡æ¶ˆæ¯ã€‘çŠ¶æ€å­˜å‚¨ï¼ˆTranStateTableï¼‰
 15:                     DefaultMessageStore.this.getTransactionStateService().appendPreparedTransaction(
 16:                         req.getCommitLogOffset(), req.getMsgSize(), (int) (req.getStoreTimestamp() / 1000), req.getProducerGroup().hashCode());
 17:                     break;
 18:                 case MessageSysFlag.TransactionCommitType:
 19:                 case MessageSysFlag.TransactionRollbackType:
 20:                     // æ›´æ–° ã€äº‹åŠ¡æ¶ˆæ¯ã€‘çŠ¶æ€å­˜å‚¨ï¼ˆTranStateTableï¼‰ COMMIT / ROLLBACK
 21:                     DefaultMessageStore.this.getTransactionStateService().updateTransactionState(
 22:                         req.getTranStateTableOffset(), req.getPreparedTransactionOffset(), req.getProducerGroup().hashCode(), tranType);
 23:                     break;
 24:                 }
 25:             }
 26:             // 3ã€è®°å½• TranRedoLog
 27:             switch (tranType) {
 28:             case MessageSysFlag.TransactionNotType:
 29:                 break;
 30:             case MessageSysFlag.TransactionPreparedType:
 31:                 // è®°å½• TranRedoLog
 32:                 DefaultMessageStore.this.getTransactionStateService().getTranRedoLog().putMessagePostionInfoWrapper(
 33:                         req.getCommitLogOffset(), req.getMsgSize(), TransactionStateService.PreparedMessageTagsCode,
 34:                         req.getStoreTimestamp(), 0L);
 35:                 break;
 36:             case MessageSysFlag.TransactionCommitType:
 37:             case MessageSysFlag.TransactionRollbackType:
 38:                 // è®°å½• TranRedoLog
 39:                 DefaultMessageStore.this.getTransactionStateService().getTranRedoLog().putMessagePostionInfoWrapper(
 40:                         req.getCommitLogOffset(), req.getMsgSize(), req.getPreparedTransactionOffset(),
 41:                         req.getStoreTimestamp(), 0L);
 42:                 break;
 43:             }
 44:         }
 45: 
 46:         // ...çœç•¥ä»£ç 
 47:     }
 48: }
 49: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€TransactionStateService.javaã€‘
 50: /**
 51:  * æ–°å¢äº‹åŠ¡çŠ¶æ€
 52:  *
 53:  * @param clOffset commitLog ç‰©ç†ä½ç½®
 54:  * @param size æ¶ˆæ¯é•¿åº¦
 55:  * @param timestamp æ¶ˆæ¯å­˜å‚¨æ—¶é—´
 56:  * @param groupHashCode groupHashCode
 57:  * @return æ˜¯å¦æˆåŠŸ
 58:  */
 59: public boolean appendPreparedTransaction(//
 60:         final long clOffset,//
 61:         final int size,//
 62:         final int timestamp,//
 63:         final int groupHashCode//
 64: ) {
 65:     MapedFile mapedFile = this.tranStateTable.getLastMapedFile();
 66:     if (null == mapedFile) {
 67:         log.error("appendPreparedTransaction: create mapedfile error.");
 68:         return false;
 69:     }
 70: 
 71:     // é¦–æ¬¡åˆ›å»ºï¼ŒåŠ å…¥å®šæ—¶ä»»åŠ¡ä¸­
 72:     if (0 == mapedFile.getWrotePostion()) {
 73:         this.addTimerTask(mapedFile);
 74:     }
 75: 
 76:     this.byteBufferAppend.position(0);
 77:     this.byteBufferAppend.limit(TSStoreUnitSize);
 78: 
 79:     // Commit Log Offset
 80:     this.byteBufferAppend.putLong(clOffset);
 81:     // Message Size
 82:     this.byteBufferAppend.putInt(size);
 83:     // Timestamp
 84:     this.byteBufferAppend.putInt(timestamp);
 85:     // Producer Group Hashcode
 86:     this.byteBufferAppend.putInt(groupHashCode);
 87:     // Transaction State
 88:     this.byteBufferAppend.putInt(MessageSysFlag.TransactionPreparedType);
 89: 
 90:     return mapedFile.appendMessage(this.byteBufferAppend.array());
 91: }
 92: 
 93: /**
 94:  * æ›´æ–°äº‹åŠ¡çŠ¶æ€
 95:  *
 96:  * @param tsOffset tranStateTable ç‰©ç†ä½ç½®
 97:  * @param clOffset commitLog ç‰©ç†ä½ç½®
 98:  * @param groupHashCode groupHashCode
 99:  * @param state äº‹åŠ¡çŠ¶æ€
100:  * @return æ˜¯å¦æˆåŠŸ
101:  */
102: public boolean updateTransactionState(
103:         final long tsOffset,
104:         final long clOffset,
105:         final int groupHashCode,
106:         final int state) {
107:     SelectMapedBufferResult selectMapedBufferResult = this.findTransactionBuffer(tsOffset);
108:     if (selectMapedBufferResult != null) {
109:         try {
110: 
111:             // ....çœç•¥ä»£ç ï¼šæ ¡éªŒæ˜¯å¦èƒ½å¤Ÿæ›´æ–°
112: 
113:             // æ›´æ–°äº‹åŠ¡çŠ¶æ€
114:             selectMapedBufferResult.getByteBuffer().putInt(TS_STATE_POS, state);
115:         }
116:         catch (Exception e) {
117:             log.error("updateTransactionState exception", e);
118:         }
119:         finally {
120:             selectMapedBufferResult.release();
121:         }
122:     }
123: 
124:     return false;
125: }
```

#### 3.1.1.3 ã€äº‹åŠ¡æ¶ˆæ¯ã€‘å›æŸ¥

* ğŸ¦…`TranStateTable` æ¯ä¸ª `MappedFile` éƒ½å¯¹åº”ä¸€ä¸ª `Timer`ã€‚`Timer` å›ºå®šå‘¨æœŸï¼ˆé»˜è®¤ï¼š60sï¼‰éå† `MappedFile`ï¼ŒæŸ¥æ‰¾ã€halfæ¶ˆæ¯ã€‘ï¼Œå‘ `Producer` å‘èµ·ã€äº‹åŠ¡æ¶ˆæ¯ã€‘å›æŸ¥è¯·æ±‚ã€‚ã€äº‹åŠ¡æ¶ˆæ¯ã€‘å›æŸ¥ç»“æœçš„é€»è¾‘ä¸åœ¨æ­¤å¤„è¿›è¡Œï¼Œåœ¨ [CommitLog dispatch](#3112-å†™äº‹åŠ¡æ¶ˆæ¯çŠ¶æ€å­˜å‚¨transtatetable)æ—¶æ‰§è¡Œã€‚

å®ç°ä»£ç å¦‚ä¸‹ï¼š

```Java
  1: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€TransactionStateService.javaã€‘
  2: /**
  3:  * åˆå§‹åŒ–å®šæ—¶ä»»åŠ¡
  4:  */
  5: private void initTimerTask() {
  6:     //
  7:     final List<MapedFile> mapedFiles = this.tranStateTable.getMapedFiles();
  8:     for (MapedFile mf : mapedFiles) {
  9:         this.addTimerTask(mf);
 10:     }
 11: }
 12: 
 13: /**
 14:  * æ¯ä¸ªæ–‡ä»¶åˆå§‹åŒ–å®šæ—¶ä»»åŠ¡
 15:  * @param mf æ–‡ä»¶
 16:  */
 17: private void addTimerTask(final MapedFile mf) {
 18:     this.timer.scheduleAtFixedRate(new TimerTask() {
 19:         private final MapedFile mapedFile = mf;
 20:         private final TransactionCheckExecuter transactionCheckExecuter = TransactionStateService.this.defaultMessageStore.getTransactionCheckExecuter();
 21:         private final long checkTransactionMessageAtleastInterval = TransactionStateService.this.defaultMessageStore.getMessageStoreConfig()
 22:                     .getCheckTransactionMessageAtleastInterval();
 23:         private final boolean slave = TransactionStateService.this.defaultMessageStore.getMessageStoreConfig().getBrokerRole() == BrokerRole.SLAVE;
 24: 
 25:         @Override
 26:         public void run() {
 27:             // Slaveä¸éœ€è¦å›æŸ¥äº‹åŠ¡çŠ¶æ€
 28:             if (slave) {
 29:                 return;
 30:             }
 31:             // CheckåŠŸèƒ½æ˜¯å¦å¼€å¯
 32:             if (!TransactionStateService.this.defaultMessageStore.getMessageStoreConfig()
 33:                 .isCheckTransactionMessageEnable()) {
 34:                 return;
 35:             }
 36: 
 37:             try {
 38:                 SelectMapedBufferResult selectMapedBufferResult = mapedFile.selectMapedBuffer(0);
 39:                 if (selectMapedBufferResult != null) {
 40:                     long preparedMessageCountInThisMapedFile = 0; // å›æŸ¥çš„ã€halfæ¶ˆæ¯ã€‘æ•°é‡
 41:                     int i = 0;
 42:                     try {
 43:                         // å¾ªç¯æ¯æ¡ã€äº‹åŠ¡æ¶ˆæ¯ã€‘çŠ¶æ€ï¼Œå¯¹ã€halfæ¶ˆæ¯ã€‘è¿›è¡Œå›æŸ¥
 44:                         for (; i < selectMapedBufferResult.getSize(); i += TSStoreUnitSize) {
 45:                             selectMapedBufferResult.getByteBuffer().position(i);
 46: 
 47:                             // Commit Log Offset
 48:                             long clOffset = selectMapedBufferResult.getByteBuffer().getLong();
 49:                             // Message Size
 50:                             int msgSize = selectMapedBufferResult.getByteBuffer().getInt();
 51:                             // Timestamp
 52:                             int timestamp = selectMapedBufferResult.getByteBuffer().getInt();
 53:                             // Producer Group Hashcode
 54:                             int groupHashCode = selectMapedBufferResult.getByteBuffer().getInt();
 55:                             // Transaction State
 56:                             int tranType = selectMapedBufferResult.getByteBuffer().getInt();
 57: 
 58:                             // å·²ç»æäº¤æˆ–è€…å›æ»šçš„æ¶ˆæ¯è·³è¿‡
 59:                             if (tranType != MessageSysFlag.TransactionPreparedType) {
 60:                                 continue;
 61:                             }
 62: 
 63:                             // é‡åˆ°æ—¶é—´ä¸ç¬¦åˆæœ€å°è½®è¯¢é—´éš”ï¼Œç»ˆæ­¢
 64:                             long timestampLong = timestamp * 1000;
 65:                             long diff = System.currentTimeMillis() - timestampLong;
 66:                             if (diff < checkTransactionMessageAtleastInterval) {
 67:                                 break;
 68:                             }
 69: 
 70:                             preparedMessageCountInThisMapedFile++;
 71: 
 72:                             // å›æŸ¥Producer
 73:                             try {
 74:                                 this.transactionCheckExecuter.gotoCheck(groupHashCode, getTranStateOffset(i), clOffset, msgSize);
 75:                             } catch (Exception e) {
 76:                                 tranlog.warn("gotoCheck Exception", e);
 77:                             }
 78:                         }
 79: 
 80:                         // æ— å›æŸ¥çš„ã€halfæ¶ˆæ¯ã€‘æ•°é‡ï¼Œä¸”éå†å®Œï¼Œåˆ™ç»ˆæ­¢å®šæ—¶ä»»åŠ¡
 81:                         if (0 == preparedMessageCountInThisMapedFile //
 82:                                 && i == mapedFile.getFileSize()) {
 83:                             tranlog.info("remove the transaction timer task, because no prepared message in this mapedfile[{}]", mapedFile.getFileName());
 84:                             this.cancel();
 85:                         }
 86:                     } finally {
 87:                         selectMapedBufferResult.release();
 88:                     }
 89: 
 90:                     tranlog.info("the transaction timer task execute over in this period, {} Prepared Message: {} Check Progress: {}/{}", mapedFile.getFileName(),//
 91:                             preparedMessageCountInThisMapedFile, i / TSStoreUnitSize, mapedFile.getFileSize() / TSStoreUnitSize);
 92:                 } else if (mapedFile.isFull()) {
 93:                     tranlog.info("the mapedfile[{}] maybe deleted, cancel check transaction timer task", mapedFile.getFileName());
 94:                     this.cancel();
 95:                     return;
 96:                 }
 97:             } catch (Exception e) {
 98:                 log.error("check transaction timer task Exception", e);
 99:             }
100:         }
101: 
102: 
103:         private long getTranStateOffset(final long currentIndex) {
104:             long offset = (this.mapedFile.getFileFromOffset() + currentIndex) / TransactionStateService.TSStoreUnitSize;
105:             return offset;
106:         }
107:     }, 1000 * 60, this.defaultMessageStore.getMessageStoreConfig().getCheckTransactionMessageTimerInterval());
108: }
109: 
110: // ã€DefaultTransactionCheckExecuter.javaã€‘
111: @Override
112: public void gotoCheck(int producerGroupHashCode, long tranStateTableOffset, long commitLogOffset,
113:         int msgSize) {
114:     // ç¬¬ä¸€æ­¥ã€æŸ¥è¯¢Producer
115:     final ClientChannelInfo clientChannelInfo = this.brokerController.getProducerManager().pickProducerChannelRandomly(producerGroupHashCode);
116:     if (null == clientChannelInfo) {
117:         log.warn("check a producer transaction state, but not find any channel of this group[{}]", producerGroupHashCode);
118:         return;
119:     }
120: 
121:     // ç¬¬äºŒæ­¥ã€æŸ¥è¯¢æ¶ˆæ¯
122:     SelectMapedBufferResult selectMapedBufferResult = this.brokerController.getMessageStore().selectOneMessageByOffset(commitLogOffset, msgSize);
123:     if (null == selectMapedBufferResult) {
124:         log.warn("check a producer transaction state, but not find message by commitLogOffset: {}, msgSize: ", commitLogOffset, msgSize);
125:         return;
126:     }
127: 
128:     // ç¬¬ä¸‰æ­¥ã€å‘Producerå‘èµ·è¯·æ±‚
129:     final CheckTransactionStateRequestHeader requestHeader = new CheckTransactionStateRequestHeader();
130:     requestHeader.setCommitLogOffset(commitLogOffset);
131:     requestHeader.setTranStateTableOffset(tranStateTableOffset);
132:     this.brokerController.getBroker2Client().checkProducerTransactionState(clientChannelInfo.getChannel(), requestHeader, selectMapedBufferResult);
133: }
```

#### 3.1.1.4 åˆå§‹åŒ–ã€äº‹åŠ¡æ¶ˆæ¯ã€‘çŠ¶æ€å­˜å‚¨ï¼ˆTranStateTableï¼‰

* ğŸ¦…æ ¹æ®æœ€å Broker å…³é—­æ˜¯å¦æ­£å¸¸ï¼Œä¼šæœ‰ä¸åŒçš„åˆå§‹åŒ–æ–¹å¼ã€‚

æ ¸å¿ƒä»£ç å¦‚ä¸‹ï¼š

```Java
  1: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€TransactionStateService.javaã€‘
  2: /**
  3:  * åˆå§‹åŒ– TranRedoLog
  4:  * @param lastExitOK æ˜¯å¦æ­£å¸¸é€€å‡º
  5:  */
  6: public void recoverStateTable(final boolean lastExitOK) {
  7:     if (lastExitOK) {
  8:         this.recoverStateTableNormal();
  9:     } else {
 10:         // ç¬¬ä¸€æ­¥ï¼Œåˆ é™¤State Table
 11:         this.tranStateTable.destroy();
 12:         // ç¬¬äºŒæ­¥ï¼Œé€šè¿‡RedoLogå…¨é‡æ¢å¤StateTable
 13:         this.recreateStateTable();
 14:     }
 15: }
 16: 
 17: /**
 18:  * æ‰«æ TranRedoLog é‡å»º StateTable
 19:  */
 20: private void recreateStateTable() {
 21:     this.tranStateTable = new MapedFileQueue(StorePathConfigHelper.getTranStateTableStorePath(defaultMessageStore
 22:                 .getMessageStoreConfig().getStorePathRootDir()), defaultMessageStore
 23:                 .getMessageStoreConfig().getTranStateTableMapedFileSize(), null);
 24: 
 25:     final TreeSet<Long> preparedItemSet = new TreeSet<Long>();
 26: 
 27:     // ç¬¬ä¸€æ­¥ï¼Œä»å¤´æ‰«æRedoLog
 28:     final long minOffset = this.tranRedoLog.getMinOffsetInQuque();
 29:     long processOffset = minOffset;
 30:     while (true) {
 31:         SelectMapedBufferResult bufferConsumeQueue = this.tranRedoLog.getIndexBuffer(processOffset);
 32:         if (bufferConsumeQueue != null) {
 33:             try {
 34:                 long i = 0;
 35:                 for (; i < bufferConsumeQueue.getSize(); i += ConsumeQueue.CQStoreUnitSize) {
 36:                     long offsetMsg = bufferConsumeQueue.getByteBuffer().getLong();
 37:                     int sizeMsg = bufferConsumeQueue.getByteBuffer().getInt();
 38:                     long tagsCode = bufferConsumeQueue.getByteBuffer().getLong();
 39: 
 40:                     if (TransactionStateService.PreparedMessageTagsCode == tagsCode) { // Prepared
 41:                         preparedItemSet.add(offsetMsg);
 42:                     } else { // Commit/Rollback
 43:                         preparedItemSet.remove(tagsCode);
 44:                     }
 45:                 }
 46: 
 47:                 processOffset += i;
 48:             } finally { // å¿…é¡»é‡Šæ”¾èµ„æº
 49:                 bufferConsumeQueue.release();
 50:             }
 51:         } else {
 52:             break;
 53:         }
 54:     }
 55:     log.info("scan transaction redolog over, End offset: {},  Prepared Transaction Count: {}", processOffset, preparedItemSet.size());
 56: 
 57:     // ç¬¬äºŒæ­¥ï¼Œé‡å»ºStateTable
 58:     Iterator<Long> it = preparedItemSet.iterator();
 59:     while (it.hasNext()) {
 60:         Long offset = it.next();
 61:         MessageExt msgExt = this.defaultMessageStore.lookMessageByOffset(offset);
 62:         if (msgExt != null) {
 63:             this.appendPreparedTransaction(msgExt.getCommitLogOffset(), msgExt.getStoreSize(),
 64:                 (int) (msgExt.getStoreTimestamp() / 1000),
 65:                 msgExt.getProperty(MessageConst.PROPERTY_PRODUCER_GROUP).hashCode());
 66:             this.tranStateTableOffset.incrementAndGet();
 67:         }
 68:     }
 69: }
 70: 
 71: /**
 72:  * åŠ è½½ï¼ˆè§£æï¼‰TranStateTable çš„ MappedFile
 73:  * 1. æ¸…ç†å¤šä½™ MappedFileï¼Œè®¾ç½®æœ€åä¸€ä¸ª MappedFileçš„å†™å…¥ä½ç½®(position
 74:  * 2. è®¾ç½® TanStateTable æœ€å¤§ç‰©ç†ä½ç½®ï¼ˆå¯å†™å…¥ä½ç½®ï¼‰
 75:  */
 76: private void recoverStateTableNormal() {
 77:     final List<MapedFile> mapedFiles = this.tranStateTable.getMapedFiles();
 78:     if (!mapedFiles.isEmpty()) {
 79:         // ä»å€’æ•°ç¬¬ä¸‰ä¸ªæ–‡ä»¶å¼€å§‹æ¢å¤
 80:         int index = mapedFiles.size() - 3;
 81:         if (index < 0) {
 82:             index = 0;
 83:         }
 84: 
 85:         int mapedFileSizeLogics = this.tranStateTable.getMapedFileSize();
 86:         MapedFile mapedFile = mapedFiles.get(index);
 87:         ByteBuffer byteBuffer = mapedFile.sliceByteBuffer();
 88:         long processOffset = mapedFile.getFileFromOffset();
 89:         long mapedFileOffset = 0;
 90:         while (true) {
 91:             for (int i = 0; i < mapedFileSizeLogics; i += TSStoreUnitSize) {
 92: 
 93:                 final long clOffset_read = byteBuffer.getLong();
 94:                 final int size_read = byteBuffer.getInt();
 95:                 final int timestamp_read = byteBuffer.getInt();
 96:                 final int groupHashCode_read = byteBuffer.getInt();
 97:                 final int state_read = byteBuffer.getInt();
 98: 
 99:                 boolean stateOK = false;
100:                 switch (state_read) {
101:                 case MessageSysFlag.TransactionPreparedType:
102:                 case MessageSysFlag.TransactionCommitType:
103:                 case MessageSysFlag.TransactionRollbackType:
104:                     stateOK = true;
105:                     break;
106:                 default:
107:                     break;
108:                 }
109: 
110:                 // è¯´æ˜å½“å‰å­˜å‚¨å•å…ƒæœ‰æ•ˆ
111:                 if (clOffset_read >= 0 && size_read > 0 && stateOK) {
112:                     mapedFileOffset = i + TSStoreUnitSize;
113:                 } else {
114:                     log.info("recover current transaction state table file over,  " + mapedFile.getFileName() + " "
115:                             + clOffset_read + " " + size_read + " " + timestamp_read);
116:                     break;
117:                 }
118:             }
119: 
120:             // èµ°åˆ°æ–‡ä»¶æœ«å°¾ï¼Œåˆ‡æ¢è‡³ä¸‹ä¸€ä¸ªæ–‡ä»¶
121:             if (mapedFileOffset == mapedFileSizeLogics) {
122:                 index++;
123:                 if (index >= mapedFiles.size()) { // å¾ªç¯whileç»“æŸ
124:                     log.info("recover last transaction state table file over, last maped file " + mapedFile.getFileName());
125:                     break;
126:                 } else { // åˆ‡æ¢ä¸‹ä¸€ä¸ªæ–‡ä»¶
127:                     mapedFile = mapedFiles.get(index);
128:                     byteBuffer = mapedFile.sliceByteBuffer();
129:                     processOffset = mapedFile.getFileFromOffset();
130:                     mapedFileOffset = 0;
131:                     log.info("recover next transaction state table file, " + mapedFile.getFileName());
132:                 }
133:             } else {
134:                 log.info("recover current transaction state table queue over " + mapedFile.getFileName() + " " + (processOffset + mapedFileOffset));
135:                 break;
136:             }
137:         }
138: 
139:         // æ¸…ç†å¤šä½™ MappedFileï¼Œè®¾ç½®æœ€åä¸€ä¸ª MappedFileçš„å†™å…¥ä½ç½®(position
140:         processOffset += mapedFileOffset;
141:         this.tranStateTable.truncateDirtyFiles(processOffset);
142: 
143:         // è®¾ç½® TanStateTable æœ€å¤§ç‰©ç†ä½ç½®ï¼ˆå¯å†™å…¥ä½ç½®ï¼‰
144:         this.tranStateTableOffset.set(this.tranStateTable.getMaxOffset() / TSStoreUnitSize);
145:         log.info("recover normal over, transaction state table max offset: {}", this.tranStateTableOffset.get());
146:     }
147: }
```

#### 3.1.1.5 è¡¥å……

* ä¸ºä»€ä¹ˆ V3.1.5 å¼€å§‹ï¼Œä½¿ç”¨ æ•°æ®åº“ å®ç°ã€äº‹åŠ¡çŠ¶æ€ã€‘çš„å­˜å‚¨ï¼Ÿå¦‚ä¸‹æ˜¯æ¥è‡ªå®˜æ–¹æ–‡æ¡£çš„è¯´æ˜ï¼Œå¯èƒ½æ˜¯ä¸€éƒ¨åˆ†åŸå› ï¼š

> RocketMQ è¿™ç§å®ç°äº‹åŠ¡æ–¹å¼ï¼Œæ²¡æœ‰é€šè¿‡ KV å­˜å‚¨åšï¼Œè€Œæ˜¯é€šè¿‡ Offset æ–¹å¼ï¼Œå­˜åœ¨ä¸€ä¸ªæ˜¾è‘—ç¼ºé™·ï¼Œå³é€šè¿‡ Offset æ›´æ”¹æ•°æ®ï¼Œä¼šä»¤ç³»ç»Ÿçš„è„é¡µè¿‡å¤šï¼Œéœ€è¦ç‰¹åˆ«å…³æ³¨ã€‚

### 3.1.2 å®˜æ–¹V4.0.0ï¼šåŸºäºæ•°æ®åº“

> ä»“åº“åœ°å€ï¼šhttps://github.com/apache/incubator-rocketmq

å®˜æ–¹V4.0.0 æš‚æ—¶æœª**å®Œå…¨**å¼€æºã€äº‹åŠ¡æ¶ˆæ¯å›æŸ¥ã€‘åŠŸèƒ½ï¼Œ**So æˆ‘ä»¬éœ€è¦è¿›è¡Œä¸€äº›çŒœæƒ³ï¼Œå¯èƒ½ä¸ä¸€å®šæ­£ç¡®ğŸ˜ˆ**ã€‚

ğŸ˜†æˆ‘ä»¬æ¥å¯¹æ¯”ã€å®˜æ–¹V3.1.4ï¼šåŸºäºæ–‡ä»¶ã€‘çš„å®ç°ã€‚

* TransactionRecord ï¼šè®°å½•æ¯æ¡ã€äº‹åŠ¡æ¶ˆæ¯ã€‘ã€‚ç±»ä¼¼ `TranStateTable`ã€‚

| TranStateTable | TransactionRecord |  |
| --- | --- | --- |
| offset | offset |  |
| producerGroupHash | producerGroup |  |
| size | æ—  | éå¿…é¡»å­—æ®µï¼šã€äº‹åŠ¡æ¶ˆæ¯ã€‘å›æŸ¥æ—¶ï¼Œä½¿ç”¨ offset è¯»å– CommitLog è·å¾—ã€‚ |
| timestamp | æ—  | éå¿…é¡»å­—æ®µï¼šã€äº‹åŠ¡æ¶ˆæ¯ã€‘å›æŸ¥æ—¶ï¼Œä½¿ç”¨ offset è¯»å– CommitLog è·å¾—ã€‚ |
| state | æ—  | éå¿…é¡»å­—æ®µï¼š äº‹åŠ¡å¼€å§‹ï¼Œå¢åŠ è®°å½•ï¼›äº‹åŠ¡ç»“æŸï¼Œåˆ é™¤è®°å½•ã€‚|

å¦å¤–ï¼Œæ•°æ®åº“æœ¬èº«ä¿è¯äº†æ•°æ®å­˜å‚¨çš„å¯é æ€§ï¼Œæ— éœ€ `TranRedoLog`ã€‚

-------

ç®€å•æ‰‹ç»˜é€»è¾‘å›¾å¦‚ä¸‹ğŸ˜ˆï¼š

![Broker_V4.0.0_åŸºäºæ•°æ®åº“](http://www.iocoder.cn/images/RocketMQ/2017_05_21/02.jpeg)

## 3.2 Producer æ¥æ”¶ã€äº‹åŠ¡æ¶ˆæ¯å›æŸ¥ã€‘

* é¡ºåºå›¾å¦‚ä¸‹ï¼š

![Produceræ¥æ”¶ã€äº‹åŠ¡æ¶ˆæ¯å›æŸ¥ã€‘](http://www.iocoder.cn/images/RocketMQ/2017_05_21/04.png)

* æ ¸å¿ƒä»£ç å¦‚ä¸‹ï¼š

```Java
  1: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€DefaultMQProducerImpl.javaã€‘
  2: /**
  3:  * æ£€æŸ¥ã€äº‹åŠ¡çŠ¶æ€ã€‘çŠ¶æ€
  4:  *
  5:  * @param addr brokeråœ°å€
  6:  * @param msg æ¶ˆæ¯
  7:  * @param header è¯·æ±‚
  8:  */
  9: @Override
 10: public void checkTransactionState(final String addr, final MessageExt msg, final CheckTransactionStateRequestHeader header) {
 11:     Runnable request = new Runnable() {
 12:         private final String brokerAddr = addr;
 13:         private final MessageExt message = msg;
 14:         private final CheckTransactionStateRequestHeader checkRequestHeader = header;
 15:         private final String group = DefaultMQProducerImpl.this.defaultMQProducer.getProducerGroup();
 16: 
 17:         @Override
 18:         public void run() {
 19:             TransactionCheckListener transactionCheckListener = DefaultMQProducerImpl.this.checkListener();
 20:             if (transactionCheckListener != null) {
 21:                 // è·å–äº‹åŠ¡æ‰§è¡ŒçŠ¶æ€
 22:                 LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;
 23:                 Throwable exception = null;
 24:                 try {
 25:                     localTransactionState = transactionCheckListener.checkLocalTransactionState(message);
 26:                 } catch (Throwable e) {
 27:                     log.error("Broker call checkTransactionState, but checkLocalTransactionState exception", e);
 28:                     exception = e;
 29:                 }
 30: 
 31:                 // å¤„ç†äº‹åŠ¡ç»“æœï¼Œæäº¤æ¶ˆæ¯ COMMIT / ROLLBACK
 32:                 this.processTransactionState(//
 33:                     localTransactionState, //
 34:                     group, //
 35:                     exception);
 36:             } else {
 37:                 log.warn("checkTransactionState, pick transactionCheckListener by group[{}] failed", group);
 38:             }
 39:         }
 40: 
 41:         /**
 42:          * å¤„ç†äº‹åŠ¡ç»“æœï¼Œæäº¤æ¶ˆæ¯ COMMIT / ROLLBACK
 43:          *
 44:          * @param localTransactionState ã€æœ¬åœ°äº‹åŠ¡ã€‘çŠ¶æ€
 45:          * @param producerGroup producerGroup
 46:          * @param exception æ£€æŸ¥ã€æœ¬åœ°äº‹åŠ¡ã€‘çŠ¶æ€å‘ç”Ÿçš„å¼‚å¸¸
 47:          */
 48:         private void processTransactionState(//
 49:             final LocalTransactionState localTransactionState, //
 50:             final String producerGroup, //
 51:             final Throwable exception) {
 52:             final EndTransactionRequestHeader thisHeader = new EndTransactionRequestHeader();
 53:             thisHeader.setCommitLogOffset(checkRequestHeader.getCommitLogOffset());
 54:             thisHeader.setProducerGroup(producerGroup);
 55:             thisHeader.setTranStateTableOffset(checkRequestHeader.getTranStateTableOffset());
 56:             thisHeader.setFromTransactionCheck(true);
 57: 
 58:             // è®¾ç½®æ¶ˆæ¯ç¼–å·
 59:             String uniqueKey = message.getProperties().get(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);
 60:             if (uniqueKey == null) {
 61:                 uniqueKey = message.getMsgId();
 62:             }
 63:             thisHeader.setMsgId(uniqueKey);
 64: 
 65:             thisHeader.setTransactionId(checkRequestHeader.getTransactionId());
 66:             switch (localTransactionState) {
 67:                 case COMMIT_MESSAGE:
 68:                     thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);
 69:                     break;
 70:                 case ROLLBACK_MESSAGE:
 71:                     thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);
 72:                     log.warn("when broker check, client rollback this transaction, {}", thisHeader);
 73:                     break;
 74:                 case UNKNOW:
 75:                     thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);
 76:                     log.warn("when broker check, client does not know this transaction state, {}", thisHeader);
 77:                     break;
 78:                 default:
 79:                     break;
 80:             }
 81: 
 82:             String remark = null;
 83:             if (exception != null) {
 84:                 remark = "checkLocalTransactionState Exception: " + RemotingHelper.exceptionSimpleDesc(exception);
 85:             }
 86: 
 87:             try {
 88:                 // æäº¤æ¶ˆæ¯ COMMIT / ROLLBACK
 89:                 DefaultMQProducerImpl.this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, thisHeader, remark,
 90:                     3000);
 91:             } catch (Exception e) {
 92:                 log.error("endTransactionOneway exception", e);
 93:             }
 94:         }
 95:     };
 96: 
 97:     // æäº¤æ‰§è¡Œ
 98:     this.checkExecutor.submit(request);
 99: }
100: 
101: // â¬‡ï¸â¬‡ï¸â¬‡ï¸ã€DefaultMQProducerImpl.javaã€‘
102: /**
103:  * ã€äº‹åŠ¡æ¶ˆæ¯å›æŸ¥ã€‘æ£€æŸ¥ç›‘å¬å™¨
104:  */
105: public interface TransactionCheckListener {
106: 
107:     /**
108:      * è·å–ï¼ˆæ£€æŸ¥ï¼‰ã€æœ¬åœ°äº‹åŠ¡ã€‘çŠ¶æ€
109:      *
110:      * @param msg æ¶ˆæ¯
111:      * @return äº‹åŠ¡çŠ¶æ€
112:      */
113:     LocalTransactionState checkLocalTransactionState(final MessageExt msg);
114: 
115: }
```
