title: ã€æ­»ç£• Java å¹¶å‘ã€‘â€”â€“ J.U.C ä¹‹ AQSï¼šåŒæ­¥çŠ¶æ€çš„è·å–ä¸é‡Šæ”¾
date: 2018-05-26
tag: 
categories: JUC
permalink: JUC/sike/aqs-2
author: å°æ˜å“¥
from_url: http://cmsblogs.com/?p=2197
wechat_url: https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247483981&idx=1&sn=7d8f6cb8344fc560f25fb2b71cc2a5df&chksm=fa497dfccd3ef4eae718540b0b81e84ba29aa29db15977417eb46b05f034aad564dcb2269a2f#rd

-------

æ‘˜è¦: åŸåˆ›å‡ºå¤„ http://cmsblogs.com/?p=2197 ã€Œå°æ˜å“¥ã€æ¬¢è¿è½¬è½½ï¼Œä¿ç•™æ‘˜è¦ï¼Œè°¢è°¢ï¼

ä½œä¸ºã€Œå°æ˜å“¥ã€çš„å¿ å®è¯»è€…ï¼Œã€Œè€è‰¿è‰¿ã€ç•¥ä½œä¿®æ”¹ï¼Œè®°å½•åœ¨ç†è§£è¿‡ç¨‹ä¸­ï¼Œå‚è€ƒçš„èµ„æ–™ã€‚

- [1. ç‹¬å å¼](http://www.iocoder.cn/JUC/sike/aqs-2/)
  - [1.1 ç‹¬å å¼åŒæ­¥çŠ¶æ€è·å–](http://www.iocoder.cn/JUC/sike/aqs-2/)
  - [1.2 ç‹¬å å¼è·å–å“åº”ä¸­æ–­](http://www.iocoder.cn/JUC/sike/aqs-2/)
  - [1.3 ç‹¬å å¼è¶…æ—¶è·å–](http://www.iocoder.cn/JUC/sike/aqs-2/)
  - [1.4 ç‹¬å å¼åŒæ­¥çŠ¶æ€é‡Šæ”¾](http://www.iocoder.cn/JUC/sike/aqs-2/)
  - [1.5 æ€»ç»“](http://www.iocoder.cn/JUC/sike/aqs-2/)
- [2. å…±äº«å¼](http://www.iocoder.cn/JUC/sike/aqs-2/)
  - [2.1 å…±äº«å¼åŒæ­¥çŠ¶æ€è·å–](http://www.iocoder.cn/JUC/sike/aqs-2/)
  - [2.2 å…±äº«å¼è·å–å“åº”ä¸­æ–­](http://www.iocoder.cn/JUC/sike/aqs-2/)
  - [2.3 å…±äº«å¼è¶…æ—¶è·å–](http://www.iocoder.cn/JUC/sike/aqs-2/)
  - [2.4 å…±äº«å¼åŒæ­¥çŠ¶æ€é‡Šæ”¾](http://www.iocoder.cn/JUC/sike/aqs-2/)
- [å‚è€ƒèµ„æ–™](http://www.iocoder.cn/JUC/sike/aqs-2/)
- [666. å½©è›‹](http://www.iocoder.cn/JUC/sike/aqs-2/)

-------

![](http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg)

> ğŸ™‚ğŸ™‚ğŸ™‚å…³æ³¨**å¾®ä¿¡å…¬ä¼—å·ï¼šã€èŠ‹é“æºç ã€‘**æœ‰ç¦åˆ©ï¼š  
> 1. RocketMQ / MyCAT / Sharding-JDBC **æ‰€æœ‰**æºç åˆ†ææ–‡ç« åˆ—è¡¨  
> 2. RocketMQ / MyCAT / Sharding-JDBC **ä¸­æ–‡æ³¨é‡Šæºç  GitHub åœ°å€**  
> 3. æ‚¨å¯¹äºæºç çš„ç–‘é—®æ¯æ¡ç•™è¨€**éƒ½**å°†å¾—åˆ°**è®¤çœŸ**å›å¤ã€‚**ç”šè‡³ä¸çŸ¥é“å¦‚ä½•è¯»æºç ä¹Ÿå¯ä»¥è¯·æ•™å™¢**ã€‚  
> 4. **æ–°çš„**æºç è§£ææ–‡ç« **å®æ—¶**æ”¶åˆ°é€šçŸ¥ã€‚**æ¯å‘¨æ›´æ–°ä¸€ç¯‡å·¦å³**ã€‚  
> 5. **è®¤çœŸçš„**æºç äº¤æµå¾®ä¿¡ç¾¤ã€‚

-------

> æ­¤ç¯‡åšå®¢æ‰€æœ‰æºç å‡æ¥è‡ªJDK 1.8

åœ¨å‰é¢æåˆ°è¿‡ï¼ŒAQS æ˜¯æ„å»º Java åŒæ­¥ç»„ä»¶çš„åŸºç¡€ï¼Œæˆ‘ä»¬æœŸå¾…å®ƒèƒ½å¤Ÿæˆä¸ºå®ç°å¤§éƒ¨åˆ†åŒæ­¥éœ€æ±‚çš„åŸºç¡€ã€‚

AQS çš„è®¾è®¡æ¨¡å¼é‡‡ç”¨çš„**æ¨¡æ¿æ–¹æ³•æ¨¡å¼**ï¼Œå­ç±»é€šè¿‡ç»§æ‰¿çš„æ–¹å¼ï¼Œå®ç°å®ƒçš„æŠ½è±¡æ–¹æ³•æ¥ç®¡ç†åŒæ­¥çŠ¶æ€ã€‚å¯¹äºå­ç±»è€Œè¨€ï¼Œå®ƒå¹¶æ²¡æœ‰å¤ªå¤šçš„æ´»è¦åšï¼ŒAQS å·²ç»æä¾›äº†å¤§é‡çš„æ¨¡æ¿æ–¹æ³•æ¥å®ç°åŒæ­¥ï¼Œä¸»è¦æ˜¯åˆ†ä¸ºä¸‰ç±»ï¼š

* ç‹¬å å¼è·å–å’Œé‡Šæ”¾åŒæ­¥çŠ¶æ€
* å…±äº«å¼è·å–å’Œé‡Šæ”¾åŒæ­¥çŠ¶æ€
* æŸ¥è¯¢åŒæ­¥é˜Ÿåˆ—ä¸­çš„ç­‰å¾…çº¿ç¨‹æƒ…å†µã€‚

è‡ªå®šä¹‰å­ç±»ä½¿ç”¨ AQS æä¾›çš„æ¨¡æ¿æ–¹æ³•ï¼Œå°±å¯ä»¥å®ç°**è‡ªå·±çš„åŒæ­¥è¯­ä¹‰**ã€‚

# 1. ç‹¬å å¼

ç‹¬å å¼ï¼Œ**åŒä¸€æ—¶åˆ»ï¼Œä»…æœ‰ä¸€ä¸ªçº¿ç¨‹æŒæœ‰åŒæ­¥çŠ¶æ€**ã€‚

## 1.1 ç‹¬å å¼åŒæ­¥çŠ¶æ€è·å–

> è€è‰¿è‰¿ï¼š[ã€Œ1.1 ç‹¬å å¼åŒæ­¥çŠ¶æ€è·å–ã€](#) æ•´ä¸ªå°èŠ‚ï¼Œæ˜¯æœ¬æ–‡æœ€éš¾çš„éƒ¨åˆ†ã€‚è¯·ä¸€å®šä¿æŒè€å¿ƒã€‚

`#acquire(int arg)` æ–¹æ³•ï¼Œä¸º AQS æä¾›çš„**æ¨¡æ¿æ–¹æ³•**ã€‚è¯¥æ–¹æ³•ä¸ºç‹¬å å¼è·å–åŒæ­¥çŠ¶æ€ï¼Œä½†æ˜¯è¯¥æ–¹æ³•å¯¹**ä¸­æ–­ä¸æ•æ„Ÿ**ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œç”±äºçº¿ç¨‹è·å–åŒæ­¥çŠ¶æ€å¤±è´¥è€ŒåŠ å…¥åˆ° CLH åŒæ­¥é˜Ÿåˆ—ä¸­ï¼Œåç»­å¯¹è¯¥çº¿ç¨‹è¿›è¡Œä¸­æ–­æ“ä½œæ—¶ï¼Œçº¿ç¨‹**ä¸ä¼š**ä» CLH åŒæ­¥é˜Ÿåˆ—ä¸­**ç§»é™¤**ã€‚ä»£ç å¦‚ä¸‹ï¼š

```Java
  1: public final void acquire(int arg) {
  2:     if (!tryAcquire(arg) &&
  3:         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
  4:         selfInterrupt();
  5: }
```

* ç¬¬ 2 è¡Œï¼šè°ƒç”¨ `#tryAcquire(int arg)` æ–¹æ³•ï¼Œå»å°è¯•è·å–åŒæ­¥çŠ¶æ€ï¼Œè·å–æˆåŠŸåˆ™è®¾ç½®é”çŠ¶æ€å¹¶è¿”å› true ï¼Œå¦åˆ™è·å–å¤±è´¥ï¼Œè¿”å› false ã€‚è‹¥è·å–æˆåŠŸï¼Œ`#acquire(int arg)` æ–¹æ³•ï¼Œç›´æ¥è¿”å›ï¼Œ**ä¸ç”¨çº¿ç¨‹é˜»å¡**ï¼Œè‡ªæ—‹ç›´åˆ°è·å¾—åŒæ­¥çŠ¶æ€æˆåŠŸã€‚
    * `#tryAcquire(int arg)` æ–¹æ³•ï¼Œ**éœ€è¦**è‡ªå®šä¹‰åŒæ­¥ç»„ä»¶**è‡ªå·±å®ç°**ï¼Œè¯¥æ–¹æ³•å¿…é¡»è¦ä¿è¯**çº¿ç¨‹å®‰å…¨**çš„è·å–åŒæ­¥çŠ¶æ€ã€‚ä»£ç å¦‚ä¸‹ï¼š

        ```Java
        protected boolean tryAcquire(int arg) {
            throw new UnsupportedOperationException();
        }
        ```
        * **ç›´æ¥**æŠ›å‡º UnsupportedOperationException å¼‚å¸¸ã€‚

* ç¬¬ 3 è¡Œï¼šå¦‚æœ `#tryAcquire(int arg)` æ–¹æ³•è¿”å› false ï¼Œå³è·å–åŒæ­¥çŠ¶æ€å¤±è´¥ï¼Œåˆ™è°ƒç”¨ `#addWaiter(Node mode)` æ–¹æ³•ï¼Œå°†å½“å‰çº¿ç¨‹åŠ å…¥åˆ° CLH åŒæ­¥é˜Ÿåˆ—å°¾éƒ¨ã€‚å¹¶ä¸”ï¼Œ `mode` æ–¹æ³•å‚æ•°ä¸º `Node.EXCLUSIVE` ï¼Œè¡¨ç¤º**ç‹¬å **æ¨¡å¼ã€‚
* ç¬¬ 3 è¡Œï¼šè°ƒç”¨ `boolean #acquireQueued(Node node, int arg)` æ–¹æ³•ï¼Œè‡ªæ—‹ç›´åˆ°è·å¾—åŒæ­¥çŠ¶æ€æˆåŠŸã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ1.1.1 acquireQueuedã€](#) ä¸­ã€‚å¦å¤–ï¼Œè¯¥æ–¹æ³•çš„è¿”å›å€¼ç±»å‹ä¸º `boolean` ï¼Œå½“è¿”å› true æ—¶ï¼Œè¡¨ç¤ºåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œå‘ç”Ÿè¿‡**çº¿ç¨‹ä¸­æ–­**ã€‚ä½†æ˜¯å‘¢ï¼Œè¿™ä¸ªæ–¹æ³•åˆä¼š**æ¸…ç†**çº¿ç¨‹ä¸­æ–­çš„**æ ‡è¯†**ï¼Œæ‰€ä»¥åœ¨ç§æƒ…å†µä¸‹ï¼Œéœ€è¦è°ƒç”¨ã€ç¬¬ 4 è¡Œã€‘çš„ `#selfInterrupt()` æ–¹æ³•ï¼Œæ¢å¤çº¿ç¨‹ä¸­æ–­çš„**æ ‡è¯†**ï¼Œä»£ç å¦‚ä¸‹ï¼š

    ```Java
    static void selfInterrupt() {
        Thread.currentThread().interrupt();
    }
    ```

### 1.1.1 acquireQueued

`boolean #acquireQueued(Node node, int arg)` æ–¹æ³•ï¼Œä¸ºä¸€ä¸ª**è‡ªæ—‹**çš„è¿‡ç¨‹ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå½“å‰çº¿ç¨‹ï¼ˆNodeï¼‰è¿›å…¥åŒæ­¥é˜Ÿåˆ—åï¼Œå°±ä¼šè¿›å…¥ä¸€ä¸ªè‡ªæ—‹çš„è¿‡ç¨‹ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½ä¼š**è‡ªçœ**åœ°è§‚å¯Ÿï¼Œå½“æ¡ä»¶æ»¡è¶³ï¼Œè·å–åˆ°åŒæ­¥çŠ¶æ€åï¼Œå°±å¯ä»¥ä»è¿™ä¸ªè‡ªæ—‹è¿‡ç¨‹ä¸­é€€å‡ºï¼Œå¦åˆ™ä¼šä¸€ç›´æ‰§è¡Œä¸‹å»ã€‚

**æµç¨‹å›¾**å¦‚ä¸‹ï¼š

![æµç¨‹å›¾](https://gitee.com/chenssy/blog-home/raw/master/image/sijava/2018120811001.png)

**ä»£ç **å¦‚ä¸‹ï¼š

```Java
  1: final boolean acquireQueued(final Node node, int arg) {
  2:     // è®°å½•æ˜¯å¦è·å–åŒæ­¥çŠ¶æ€æˆåŠŸ
  3:     boolean failed = true;
  4:     try {
  5:         // è®°å½•è¿‡ç¨‹ä¸­ï¼Œæ˜¯å¦å‘ç”Ÿçº¿ç¨‹ä¸­æ–­
  6:         boolean interrupted = false;
  7:         /*
  8:          * è‡ªæ—‹è¿‡ç¨‹ï¼Œå…¶å®å°±æ˜¯ä¸€ä¸ªæ­»å¾ªç¯è€Œå·²
  9:          */
 10:         for (;;) {
 11:             // å½“å‰çº¿ç¨‹çš„å‰é©±èŠ‚ç‚¹
 12:             final Node p = node.predecessor();
 13:             // å½“å‰çº¿ç¨‹çš„å‰é©±èŠ‚ç‚¹æ˜¯å¤´ç»“ç‚¹ï¼Œä¸”åŒæ­¥çŠ¶æ€æˆåŠŸ
 14:             if (p == head && tryAcquire(arg)) {
 15:                 setHead(node);
 16:                 p.next = null; // help GC
 17:                 failed = false;
 18:                 return interrupted;
 19:             }
 20:             // è·å–å¤±è´¥ï¼Œçº¿ç¨‹ç­‰å¾…--å…·ä½“åé¢ä»‹ç»
 21:             if (shouldParkAfterFailedAcquire(p, node) &&
 22:                     parkAndCheckInterrupt())
 23:                 interrupted = true;
 24:         }
 25:     } finally {
 26:         // è·å–åŒæ­¥çŠ¶æ€å‘ç”Ÿå¼‚å¸¸ï¼Œå–æ¶ˆè·å–ã€‚
 27:         if (failed)
 28:             cancelAcquire(node);
 29:     }
 30: }
```

* ç¬¬ 3 è¡Œï¼š`failed` å˜é‡ï¼Œè®°å½•æ˜¯å¦**è·å–åŒæ­¥çŠ¶æ€**æˆåŠŸã€‚
* ç¬¬ 6 è¡Œï¼š`interrupted` å˜é‡ï¼Œè®°å½•è·å–è¿‡ç¨‹ä¸­ï¼Œæ˜¯å¦å‘ç”Ÿ**çº¿ç¨‹ä¸­æ–­**ã€‚
* ========== ç¬¬ 7 è‡³ 24 è¡Œï¼šâ€œæ­»â€å¾ªç¯ï¼Œè‡ªæ—‹ç›´åˆ°è·å¾—åŒæ­¥çŠ¶æ€æˆåŠŸã€‚==========
* ç¬¬ 12 è¡Œï¼šè°ƒç”¨ `Node#predecessor()` æ–¹æ³•ï¼Œè·å¾—å½“å‰çº¿ç¨‹çš„**å‰ä¸€ä¸ª**èŠ‚ç‚¹ `p` ã€‚
* ç¬¬ 14 è¡Œï¼š`p == head` ä»£ç å—ï¼Œè‹¥æ»¡è¶³ï¼Œåˆ™è¡¨ç¤ºå½“å‰çº¿ç¨‹çš„**å‰ä¸€ä¸ª**èŠ‚ç‚¹ä¸º**å¤´**èŠ‚ç‚¹ï¼Œå› ä¸º `head` æ˜¯**æœ€åä¸€ä¸ª**è·å¾—åŒæ­¥çŠ¶æ€æˆåŠŸçš„èŠ‚ç‚¹ï¼Œæ­¤æ—¶è°ƒç”¨ `#tryAcquire(int arg)` æ–¹æ³•ï¼Œå°è¯•è·å¾—åŒæ­¥çŠ¶æ€ã€‚ğŸ™‚ åœ¨ `#acquire(int arg)` æ–¹æ³•çš„ã€ç¬¬ 2 è¡Œã€‘ï¼Œä¹Ÿè°ƒç”¨äº†è¿™ä¸ªæ–¹æ³•ã€‚
* ç¬¬ 15 è‡³ 18 è¡Œï¼šå½“å‰èŠ‚ç‚¹( çº¿ç¨‹ )è·å–åŒæ­¥çŠ¶æ€**æˆåŠŸ**ï¼š
    * ç¬¬ 15 è¡Œï¼šè®¾ç½®å½“å‰èŠ‚ç‚¹( çº¿ç¨‹ )ä¸º**æ–°**çš„ `head` ã€‚
    * ç¬¬ 16 è¡Œï¼šè®¾ç½®**è€**çš„**å¤´**èŠ‚ç‚¹ `p` ä¸å†æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè®©å®ƒè‡ªèº«æ›´å¿«çš„è¢« GC ã€‚
    * ç¬¬ 17 è¡Œï¼šæ ‡è®° `failed = false` ï¼Œè¡¨ç¤º**è·å–åŒæ­¥çŠ¶æ€**æˆåŠŸã€‚
    * ç¬¬ 18 è¡Œï¼šè¿”å›è®°å½•è·å–è¿‡ç¨‹ä¸­ï¼Œæ˜¯å¦å‘ç”Ÿ**çº¿ç¨‹ä¸­æ–­**ã€‚
* ç¬¬ 20 è‡³ 24 è¡Œï¼šè·å–å¤±è´¥ï¼Œçº¿ç¨‹ç­‰å¾…**å”¤é†’**ï¼Œä»è€Œè¿›è¡Œä¸‹ä¸€æ¬¡çš„åŒæ­¥çŠ¶æ€è·å–çš„å°è¯•ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Šã€æ­»ç£• Java å¹¶å‘ã€‘â€”â€“ J.U.C ä¹‹ AQSï¼šé˜»å¡å’Œå”¤é†’çº¿ç¨‹ã€‹](http://www.iocoder.cn/JUC/sike/aqs-3) ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ1.1.2 shouldParkAfterFailedAcquireã€](#) ã€‚
    * ç¬¬ 21 è¡Œï¼šè°ƒç”¨ `#shouldParkAfterFailedAcquire(Node pre, Node node)` æ–¹æ³•ï¼Œåˆ¤æ–­è·å–å¤±è´¥åï¼Œæ˜¯å¦å½“å‰çº¿ç¨‹éœ€è¦é˜»å¡ç­‰å¾…ã€‚ 
* ========== ç¬¬ 26 è‡³ 29 è¡Œï¼šè·å–åŒæ­¥çŠ¶æ€çš„è¿‡ç¨‹ä¸­ï¼Œ**å‘ç”Ÿå¼‚å¸¸**ï¼Œå–æ¶ˆè·å–ã€‚==========
* ç¬¬ 28 è¡Œï¼šè°ƒç”¨ `#cancelAcquire(Node node)` æ–¹æ³•ï¼Œå–æ¶ˆè·å–åŒæ­¥çŠ¶æ€ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ1.1.3 cancelAcquireã€](#) ã€‚

### 1.1.2 shouldParkAfterFailedAcquire

```Java
  1: private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
  2:     // è·å¾—å‰ä¸€ä¸ªèŠ‚ç‚¹çš„ç­‰å¾…çŠ¶æ€
  3:     int ws = pred.waitStatus;
  4:     if (ws == Node.SIGNAL) //  Node.SIGNAL
  5:         /*
  6:          * This node has already set status asking a release
  7:          * to signal it, so it can safely park.
  8:          */
  9:         return true;
 10:     if (ws > 0) { // Node.CANCEL
 11:         /*
 12:          * Predecessor was cancelled. Skip over predecessors and
 13:          * indicate retry.
 14:          */
 15:         do {
 16:             node.prev = pred = pred.prev;
 17:         } while (pred.waitStatus > 0);
 18:         pred.next = node;
 19:     } else { // 0 æˆ–è€… Node.PROPAGATE
 20:         /*
 21:          * waitStatus must be 0 or PROPAGATE.  Indicate that we
 22:          * need a signal, but don't park yet.  Caller will need to
 23:          * retry to make sure it cannot acquire before parking.
 24:          */
 25:         compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
 26:     }
 27:     return false;
 28: }
```

* `pred` å’Œ `node` æ–¹æ³•å‚æ•°ï¼Œä¼ å…¥æ—¶ï¼Œè¦æ±‚å‰è€…**å¿…é¡»æ˜¯**åè€…çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ã€‚
* ç¬¬ 3 è¡Œï¼šè·å¾—å‰ä¸€ä¸ªèŠ‚ç‚¹( `pre` )çš„ç­‰å¾…çŠ¶æ€ã€‚ä¸‹é¢ä¼šæ ¹æ®è¿™ä¸ªçŠ¶æ€æœ‰**ä¸‰ç§**æƒ…å†µçš„å¤„ç†ã€‚
* ç¬¬ 4 è‡³ 9 è¡Œï¼šç­‰å¾…çŠ¶æ€ä¸º `Node.SIGNAL` æ—¶ï¼Œè¡¨ç¤º `pred` çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ `node` çš„çº¿ç¨‹**éœ€è¦**é˜»å¡**ç­‰å¾…**ã€‚åœ¨ `pred` çš„çº¿ç¨‹é‡Šæ”¾åŒæ­¥çŠ¶æ€æ—¶ï¼Œä¼šå¯¹ `node` çš„çº¿ç¨‹è¿›è¡Œ**å”¤é†’**é€šçŸ¥ã€‚æ‰€ä»¥ï¼Œã€ç¬¬ 9 è¡Œã€‘è¿”å› true ï¼Œè¡¨æ˜å½“å‰çº¿ç¨‹å¯ä»¥è¢« **park**ï¼Œ**å®‰å…¨**çš„é˜»å¡ç­‰å¾…ã€‚
* ç¬¬ 19 è‡³ 26 è¡Œï¼šç­‰å¾…çŠ¶æ€ä¸º `0` æˆ–è€… `Node.PROPAGATE` æ—¶ï¼Œé€šè¿‡ **CAS** è®¾ç½®ï¼Œå°†çŠ¶æ€ä¿®æ”¹ä¸º `Node.SIGNAL` ï¼Œå³ä¸‹ä¸€æ¬¡é‡æ–°æ‰§è¡Œ `#shouldParkAfterFailedAcquire(Node pred, Node node)` æ–¹æ³•æ—¶ï¼Œæ»¡è¶³ã€ç¬¬ 4 è‡³ 9 è¡Œã€‘çš„æ¡ä»¶ã€‚
    * ä½†æ˜¯ï¼Œå¯¹äºæœ¬æ¬¡æ‰§è¡Œï¼Œã€ç¬¬ 27 è¡Œã€‘è¿”å› false ã€‚ 
    * å¦å¤–ï¼Œç­‰å¾…çŠ¶æ€ä¸ä¼šä¸º `Node.CONDITION` ï¼Œå› ä¸ºå®ƒç”¨åœ¨ ConditonObject ä¸­ã€‚
* ç¬¬ 10 è‡³ 18 è¡Œï¼šç­‰å¾…çŠ¶æ€ä¸º `NODE.CANCELLED` æ—¶ï¼Œåˆ™è¡¨æ˜è¯¥çº¿ç¨‹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹å·²ç»ç­‰å¾…è¶…æ—¶æˆ–è€…è¢«ä¸­æ–­äº†ï¼Œåˆ™éœ€è¦ä» CLH é˜Ÿåˆ—ä¸­å°†è¯¥å‰ä¸€ä¸ªèŠ‚ç‚¹åˆ é™¤æ‰ï¼Œå¾ªç¯å›æº¯ï¼Œç›´åˆ°å‰ä¸€ä¸ªèŠ‚ç‚¹çŠ¶æ€ `<= 0` ã€‚
    * å¯¹äºæœ¬æ¬¡æ‰§è¡Œï¼Œã€ç¬¬ 27 è¡Œã€‘è¿”å› false ï¼Œéœ€è¦ä¸‹ä¸€æ¬¡å†é‡æ–°æ‰§è¡Œ `#shouldParkAfterFailedAcquire(Node pred, Node node)` æ–¹æ³•ï¼Œçœ‹çœ‹æ»¡è¶³å“ªä¸ªæ¡ä»¶ã€‚
    * æ•´ä¸ªè¿‡ç¨‹å¦‚ä¸‹å›¾ï¼š![è¿‡ç¨‹](http://www.iocoder.cn/images/JUC/shouldParkAfterFailedAcquire-02.png)

### 1.1.3 cancelAcquire

```Java
  1: private void cancelAcquire(Node node) {
  2:     // Ignore if node doesn't exist
  3:     if (node == null)
  4:         return;
  5: 
  6:     node.thread = null;
  7: 
  8:     // Skip cancelled predecessors
  9:     Node pred = node.prev;
 10:     while (pred.waitStatus > 0)
 11:         node.prev = pred = pred.prev;
 12: 
 13:     // predNext is the apparent node to unsplice. CASes below will
 14:     // fail if not, in which case, we lost race vs another cancel
 15:     // or signal, so no further action is necessary.
 16:     Node predNext = pred.next;
 17: 
 18:     // Can use unconditional write instead of CAS here.
 19:     // After this atomic step, other Nodes can skip past us.
 20:     // Before, we are free of interference from other threads.
 21:     node.waitStatus = Node.CANCELLED;
 22: 
 23:     // If we are the tail, remove ourselves.
 24:     if (node == tail && compareAndSetTail(node, pred)) {
 25:         compareAndSetNext(pred, predNext, null);
 26:     } else {
 27:         // If successor needs signal, try to set pred's next-link
 28:         // so it will get one. Otherwise wake it up to propagate.
 29:         int ws;
 30:         if (pred != head &&
 31:             ((ws = pred.waitStatus) == Node.SIGNAL ||
 32:              (ws <= 0 && compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &&
 33:             pred.thread != null) {
 34:             Node next = node.next;
 35:             if (next != null && next.waitStatus <= 0)
 36:                 compareAndSetNext(pred, predNext, next);
 37:         } else {
 38:             unparkSuccessor(node);
 39:         }
 40: 
 41:         node.next = node; // help GC
 42:     }
 43: }
```

* ç¬¬ 2 è‡³ 4 è¡Œï¼šå¿½ç•¥ï¼Œè‹¥ä¼ å…¥å‚æ•° `node` ä¸ºç©ºã€‚
* ç¬¬ 6 è¡Œï¼šå°†èŠ‚ç‚¹çš„ç­‰å¾…çº¿ç¨‹ç½®**ç©º**ã€‚
* ç¬¬ 9 è¡Œï¼šè·å¾— `node` èŠ‚ç‚¹çš„**å‰**ä¸€ä¸ªèŠ‚ç‚¹ `pred` ã€‚
    * ç¬¬ 10 è‡³ 11 è¡Œï¼š é€»è¾‘åŒ `#shouldParkAfterFailedAcquire(Node pred, Node node)` çš„ã€ç¬¬ 15 è‡³ 17 è¡Œã€‘ã€‚
* ç¬¬ 16 è¡Œï¼šè·å¾— `pred` çš„**ä¸‹**ä¸€ä¸ªèŠ‚ç‚¹ `predNext` ã€‚åœ¨è¿™ä¸ªå˜é‡ä¸Šï¼Œæœ‰å¾ˆâ€œå¤æ‚â€çš„è‹±æ–‡ï¼Œæˆ‘ä»¬æ¥ç†è§£ä¸‹ï¼š`predNext` ä»è¡¨é¢ä¸Šçœ‹ï¼Œå’Œ `node` æ˜¯ç­‰ä»·çš„ã€‚
    * ä½†æ˜¯å®é™…ä¸Šï¼Œå­˜åœ¨å¤šçº¿ç¨‹å¹¶å‘çš„æƒ…å†µï¼Œæ‰€ä»¥åœ¨ã€ç¬¬ 25 è¡Œã€‘æˆ–è€…ã€ç¬¬ 36 è¡Œã€‘ä¸­ï¼Œæˆ‘ä»¬è°ƒç”¨ `#compareAndSetNext(...)` æ–¹æ³•ï¼Œä½¿ç”¨ **CAS** çš„æ–¹å¼ï¼Œè®¾ç½® `pred` çš„**ä¸‹**ä¸€ä¸ªèŠ‚ç‚¹ã€‚
    * å¦‚æœè®¾ç½®å¤±è´¥ï¼Œè¯´æ˜å½“å‰çº¿ç¨‹å’Œå…¶å®ƒçº¿ç¨‹ç«äº‰**å¤±è´¥**ï¼Œä¸éœ€è¦åšå…¶å®ƒé€»è¾‘ï¼Œå› ä¸º `pred` çš„**ä¸‹**ä¸€ä¸ªèŠ‚ç‚¹å·²ç»è¢«å…¶å®ƒçº¿ç¨‹è®¾ç½®**æˆåŠŸ**ã€‚
* ç¬¬ 21 è¡Œï¼šè®¾ç½® `node` èŠ‚ç‚¹çš„ä¸º**å–æ¶ˆ**çš„ç­‰å¾…çŠ¶æ€ `Node.CANCELLED` ã€‚åœ¨è¿™ä¸ªå˜é‡ä¸Šï¼Œæœ‰å¾ˆâ€œå¤æ‚â€çš„è‹±æ–‡ï¼Œæˆ‘ä»¬å†æ¥ç†è§£ä¸‹ï¼š
    * è¿™é‡Œå¯ä»¥ä½¿ç”¨**ç›´æ¥å†™**ï¼Œè€Œä¸æ˜¯ CAS ã€‚
    * åœ¨è¿™ä¸ªæ“ä½œä¹‹åï¼Œå…¶å®ƒ Node èŠ‚ç‚¹å¯ä»¥å¿½ç•¥ `node` ã€‚
    * `Before, we are free of interference from other threads.` TODO 9000 èŠ‹è‰¿ï¼Œå¦‚ä½•ç†è§£ã€‚
* ä¸‹é¢å¼€å§‹å¼€å§‹ä¿®æ”¹ `pred` çš„**æ–°**çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä¸€å…±åˆ†æˆ**ä¸‰**ç§æƒ…å†µã€‚
* ========== ç¬¬ä¸€ç§ ==========
* ç¬¬ 24 è¡Œï¼šå¦‚æœ `node` æ˜¯**å°¾**èŠ‚ç‚¹ï¼Œè°ƒç”¨ `#compareAndSetTail(...)` æ–¹æ³•ï¼Œ**CAS** è®¾ç½® `pred` ä¸º**æ–°**çš„**å°¾**èŠ‚ç‚¹ã€‚
    * ç¬¬ 25 è¡Œï¼šè‹¥ä¸Šè¿°æ“ä½œæˆåŠŸï¼Œè°ƒç”¨ `#compareAndSetNext(...)`  æ–¹æ³•ï¼Œ**CAS** è®¾ç½® `pred` çš„**ä¸‹**ä¸€ä¸ªèŠ‚ç‚¹ä¸ºç©º( `null` )ã€‚
* ========== ç¬¬äºŒç§ ==========
* ç¬¬ 30 è¡Œï¼š`pred` é**é¦–**èŠ‚ç‚¹ã€‚
* ç¬¬ 31 è‡³ 32 è¡Œï¼š`pred` çš„**ç­‰å¾…çŠ¶æ€**ä¸º `Node.SIGNAL` ï¼Œæˆ–è€…å¯è¢« **CAS** ä¸º `Node.SIGNAL` ã€‚
* ç¬¬ 33 è¡Œï¼š`pred` çš„çº¿ç¨‹**éç©º**ã€‚
    * TODO 9001 èŠ‹è‰¿ï¼Œå¦‚ä½•ç†è§£ã€‚ç›®å‰èƒ½æƒ³è±¡åˆ°çš„ï¼Œä¸€å¼€å§‹ 30 è¡Œä¸ºéå¤´èŠ‚ç‚¹ï¼Œåœ¨ 33 çš„æ—¶å€™ï¼Œç»“æœæˆä¸ºå¤´èŠ‚ç‚¹ï¼Œçº¿ç¨‹å·²ç»ä¸ºç©ºäº†ã€‚
* ç¬¬ 34 è‡³ 36 è¡Œï¼šè‹¥ `node` çš„ **ä¸‹**ä¸€ä¸ªèŠ‚ç‚¹ `next` çš„**ç­‰å¾…çŠ¶æ€**é `Node.CANCELLED` ï¼Œåˆ™è°ƒç”¨ `#compareAndSetNext(...)` æ–¹æ³•ï¼Œ**CAS** è®¾ç½® `pred` çš„**ä¸‹**ä¸€ä¸ªèŠ‚ç‚¹ä¸º `next` ã€‚
* ========== ç¬¬ä¸‰ç§ ==========
* ç¬¬ 37 è‡³ 39 è¡Œï¼šå¦‚æœ `pred` ä¸º**é¦–**èŠ‚ç‚¹( ğŸ™‚ åœ¨ã€ç¬¬ 31 è‡³ 33 è¡Œã€‘ä¹Ÿä¼šæœ‰åˆ«çš„æƒ…å†µ )ï¼Œè°ƒç”¨ `#unparkSuccessor(Node node)` æ–¹æ³•ï¼Œå”¤é†’ `node` çš„**ä¸‹**ä¸€ä¸ªèŠ‚ç‚¹çš„çº¿ç¨‹ç­‰å¾…ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Šã€æ­»ç£• Java å¹¶å‘ã€‘â€”â€“ J.U.C ä¹‹ AQSï¼šé˜»å¡å’Œå”¤é†’çº¿ç¨‹ã€‹](http://www.iocoder.cn/JUC/sike/aqs-3) ã€‚
    * ä¸ºä»€ä¹ˆæ­¤å¤„éœ€è¦å”¤é†’å‘¢ï¼Ÿå› ä¸ºï¼Œ`pred` ä¸º**é¦–**èŠ‚ç‚¹ï¼Œ`node` çš„**ä¸‹**ä¸€ä¸ªèŠ‚ç‚¹çš„é˜»å¡ç­‰å¾…ï¼Œéœ€è¦ `node` é‡Šæ”¾åŒæ­¥çŠ¶æ€æ—¶è¿›è¡Œå”¤é†’ã€‚ä½†æ˜¯ï¼Œ`node` å–æ¶ˆè·å–åŒæ­¥çŠ¶æ€ï¼Œåˆ™ä¸ä¼šå†å‡ºç° `node` é‡Šæ”¾åŒæ­¥çŠ¶æ€æ—¶è¿›è¡Œå”¤é†’ `node` çš„**ä¸‹**ä¸€ä¸ªèŠ‚ç‚¹ã€‚å› æ­¤ï¼Œéœ€è¦æ­¤å¤„è¿›è¡Œå”¤é†’ã€‚
* ========== ç¬¬ äºŒ + ä¸‰ç§ ==========
* ç¬¬ 41 è¡Œï¼šTODO èŠ‹è‰¿ 9002 ä¸ºå•¥æ˜¯ next ä¸º node ã€‚ç›®å‰æ”¶é›†åˆ°çš„èµ„æ–™å¦‚ä¸‹ï¼š
    * http://donald-draper.iteye.com/blog/2360256
    * `next` çš„æ³¨é‡Šå¦‚ä¸‹ï¼š

        ```Java
        /**
         * Link to the successor node that the current node/thread
         * unparks upon release. Assigned during enqueuing, adjusted
         * when bypassing cancelled predecessors, and nulled out (for
         * sake of GC) when dequeued.  The enq operation does not
         * assign next field of a predecessor until after attachment,
         * so seeing a null next field does not necessarily mean that
         * node is at end of queue. However, if a next field appears
         * to be null, we can scan prev's from the tail to
         * double-check.  The next field of cancelled nodes is set to
         * point to the node itself instead of null, to make life
         * easier for isOnSyncQueue.
         */
        ```
        * æœ€åä¸€å¥è¯

## 1.2 ç‹¬å å¼è·å–å“åº”ä¸­æ–­

AQS æä¾›äº†`acquire(int arg)` æ–¹æ³•ï¼Œä»¥ä¾›ç‹¬å å¼è·å–åŒæ­¥çŠ¶æ€ï¼Œä½†æ˜¯è¯¥æ–¹æ³•**å¯¹ä¸­æ–­ä¸å“åº”**ï¼Œå¯¹çº¿ç¨‹è¿›è¡Œä¸­æ–­æ“ä½œåï¼Œè¯¥çº¿ç¨‹ä¼šä¾ç„¶ä½äºCLHåŒæ­¥é˜Ÿåˆ—ä¸­ï¼Œç­‰å¾…ç€è·å–åŒæ­¥çŠ¶æ€ã€‚ä¸ºäº†**å“åº”ä¸­æ–­**ï¼ŒAQS æä¾›äº† `#acquireInterruptibly(int arg)` æ–¹æ³•ã€‚è¯¥æ–¹æ³•åœ¨ç­‰å¾…è·å–åŒæ­¥çŠ¶æ€æ—¶ï¼Œå¦‚æœå½“å‰çº¿ç¨‹è¢«ä¸­æ–­äº†ï¼Œä¼š**ç«‹åˆ»**å“åº”ä¸­æ–­ï¼Œå¹¶æŠ›å‡º InterruptedException å¼‚å¸¸ã€‚

```Java
public final void acquireInterruptibly(int arg) throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (!tryAcquire(arg))
        doAcquireInterruptibly(arg);
}
```

* é¦–å…ˆï¼Œæ ¡éªŒè¯¥çº¿ç¨‹æ˜¯å¦å·²ç»ä¸­æ–­äº†ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™æŠ›å‡ºInterruptedException å¼‚å¸¸ã€‚
* ç„¶åï¼Œè°ƒç”¨ `#tryAcquire(int arg)` æ–¹æ³•ï¼Œå°è¯•è·å–åŒæ­¥çŠ¶æ€ï¼Œå¦‚æœè·å–æˆåŠŸï¼Œåˆ™ç›´æ¥è¿”å›ã€‚
* æœ€åï¼Œè°ƒç”¨ `#doAcquireInterruptibly(int arg)` æ–¹æ³•ï¼Œè‡ªæ—‹ç›´åˆ°è·å¾—åŒæ­¥çŠ¶æ€æˆåŠŸï¼Œ**æˆ–çº¿ç¨‹ä¸­æ–­æŠ›å‡º InterruptedException å¼‚å¸¸**ã€‚
* åº”è¯¥ä¸ä»…ä»… help gc

### 1.2.1 doAcquireInterruptibly

```Java
private void doAcquireInterruptibly(int arg)
    throws InterruptedException {
    final Node node = addWaiter(Node.EXCLUSIVE);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return;
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                throw new InterruptedException(); // <1>
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

å®ƒä¸ `#acquire(int arg)` æ–¹æ³•**ä»…æœ‰ä¸¤ä¸ªå·®åˆ«**ï¼š

1. æ–¹æ³•å£°æ˜æŠ›å‡º InterruptedException å¼‚å¸¸ã€‚
2. åœ¨ä¸­æ–­æ–¹æ³•å¤„ä¸å†æ˜¯ä½¿ç”¨ `interrupted` æ ‡å¿—ï¼Œè€Œæ˜¯ç›´æ¥æŠ›å‡º InterruptedException å¼‚å¸¸ï¼Œå³ `<1>` å¤„ã€‚

## 1.3 ç‹¬å å¼è¶…æ—¶è·å–

AQS é™¤äº†æä¾›ä¸Šé¢ä¸¤ä¸ªæ–¹æ³•å¤–ï¼Œè¿˜æä¾›äº†ä¸€ä¸ªå¢å¼ºç‰ˆçš„æ–¹æ³• `#tryAcquireNanos(int arg, long nanos)` ã€‚è¯¥æ–¹æ³•ä¸º `#acquireInterruptibly(int arg)` æ–¹æ³•çš„è¿›ä¸€æ­¥å¢å¼ºï¼Œå®ƒé™¤äº†å“åº”ä¸­æ–­å¤–ï¼Œè¿˜æœ‰**è¶…æ—¶æ§åˆ¶**ã€‚å³å¦‚æœå½“å‰çº¿ç¨‹æ²¡æœ‰åœ¨æŒ‡å®šæ—¶é—´å†…è·å–åŒæ­¥çŠ¶æ€ï¼Œåˆ™ä¼šè¿”å› false ï¼Œå¦åˆ™è¿”å› true ã€‚

**æµç¨‹å›¾**å¦‚ä¸‹ï¼š

![æµç¨‹å›¾](https://gitee.com/chenssy/blog-home/raw/master/image/sijava/2018120811002.png)

**ä»£ç **å¦‚ä¸‹ï¼š

```Java
public final boolean tryAcquireNanos(int arg, long nanosTimeout)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    return tryAcquire(arg) ||
        doAcquireNanos(arg, nanosTimeout);
}
```

* é¦–å…ˆï¼Œæ ¡éªŒè¯¥çº¿ç¨‹æ˜¯å¦å·²ç»ä¸­æ–­äº†ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™æŠ›å‡ºInterruptedException å¼‚å¸¸ã€‚
* ç„¶åï¼Œè°ƒç”¨ `#tryAcquire(int arg)` æ–¹æ³•ï¼Œå°è¯•è·å–åŒæ­¥çŠ¶æ€ï¼Œå¦‚æœè·å–æˆåŠŸï¼Œåˆ™ç›´æ¥è¿”å›ã€‚
* æœ€åï¼Œè°ƒç”¨ `#tryAcquireNanos(int arg)` æ–¹æ³•ï¼Œè‡ªæ—‹ç›´åˆ°è·å¾—åŒæ­¥çŠ¶æ€æˆåŠŸï¼Œæˆ–çº¿ç¨‹ä¸­æ–­æŠ›å‡º InterruptedException å¼‚å¸¸ï¼Œ**æˆ–è¶…è¿‡æŒ‡å®šæ—¶é—´è¿”å›è·å–åŒæ­¥çŠ¶æ€å¤±è´¥**ã€‚

### 1.3.1 tryAcquireNanos

```Java
static final long spinForTimeoutThreshold = 1000L;

  1: private boolean doAcquireNanos(int arg, long nanosTimeout)
  2:         throws InterruptedException {
  3:     // nanosTimeout <= 0
  4:     if (nanosTimeout <= 0L)
  5:         return false;
  6:     // è¶…æ—¶æ—¶é—´
  7:     final long deadline = System.nanoTime() + nanosTimeout;
  8:     // æ–°å¢ Node èŠ‚ç‚¹
  9:     final Node node = addWaiter(Node.EXCLUSIVE);
 10:     boolean failed = true;
 11:     try {
 12:         // è‡ªæ—‹
 13:         for (;;) {
 14:             final Node p = node.predecessor();
 15:             // è·å–åŒæ­¥çŠ¶æ€æˆåŠŸ
 16:             if (p == head && tryAcquire(arg)) {
 17:                 setHead(node);
 18:                 p.next = null; // help GC
 19:                 failed = false;
 20:                 return true;
 21:             }
 22:             /*
 23:              * è·å–å¤±è´¥ï¼Œåšè¶…æ—¶ã€ä¸­æ–­åˆ¤æ–­
 24:              */
 25:             // é‡æ–°è®¡ç®—éœ€è¦ä¼‘çœ çš„æ—¶é—´
 26:             nanosTimeout = deadline - System.nanoTime();
 27:             // å·²ç»è¶…æ—¶ï¼Œè¿”å›false
 28:             if (nanosTimeout <= 0L)
 29:                 return false;
 30:             // å¦‚æœæ²¡æœ‰è¶…æ—¶ï¼Œåˆ™ç­‰å¾…nanosTimeoutçº³ç§’
 31:             // æ³¨ï¼šè¯¥çº¿ç¨‹ä¼šç›´æ¥ä»LockSupport.parkNanosä¸­è¿”å›ï¼Œ
 32:             // LockSupport ä¸º J.U.C æä¾›çš„ä¸€ä¸ªé˜»å¡å’Œå”¤é†’çš„å·¥å…·ç±»ï¼Œåé¢åšè¯¦ç»†ä»‹ç»
 33:             if (shouldParkAfterFailedAcquire(p, node) &&
 34:                     nanosTimeout > spinForTimeoutThreshold)
 35:                 LockSupport.parkNanos(this, nanosTimeout);
 36:             // çº¿ç¨‹æ˜¯å¦å·²ç»ä¸­æ–­äº†
 37:             if (Thread.interrupted())
 38:                 throw new InterruptedException();
 39:         }
 40:     } finally {
 41:         if (failed)
 42:             cancelAcquire(node);
 43:     }
 44: }
```

* å› ä¸ºæ˜¯åœ¨ `#doAcquireInterruptibly(int arg)` æ–¹æ³•çš„åŸºç¡€ä¸Šï¼Œåšäº†**è¶…æ—¶**æ§åˆ¶çš„å¢å¼ºï¼Œæ‰€ä»¥**ç›¸åŒéƒ¨åˆ†ï¼Œæˆ‘ä»¬ç›´æ¥è·³è¿‡**ã€‚
* ç¬¬ 3 è‡³ 5 è¡Œï¼šå¦‚æœè¶…æ—¶æ—¶é—´å°äº 0 ï¼Œç›´æ¥è¿”å› false ï¼Œå·²ç»è¶…æ—¶ã€‚
* ç¬¬ 7 è¡Œï¼šè®¡ç®—æœ€ç»ˆè¶…æ—¶æ—¶é—´ `deadline` ã€‚
* ç¬¬ 9 è¡Œï¼šã€ç›¸åŒï¼Œè·³è¿‡ã€‘
* ç¬¬ 10 è¡Œï¼šã€ç›¸åŒï¼Œè·³è¿‡ã€‘
* ç¬¬ 13 è¡Œï¼šã€ç›¸åŒï¼Œè·³è¿‡ã€‘
* ç¬¬ 14 è¡Œï¼šã€ç›¸åŒï¼Œè·³è¿‡ã€‘
* ç¬¬ 15 è‡³ 21 è¡Œï¼šã€ç›¸åŒï¼Œè·³è¿‡ã€‘
* ç¬¬ 26 è¡Œï¼šé‡æ–°è®¡ç®—**å‰©ä½™**å¯è·å–åŒæ­¥çŠ¶æ€çš„æ—¶é—´ `nanosTimeout` ã€‚
* ç¬¬ 27 è‡³ 29 è¡Œï¼šå¦‚æœå‰©ä½™æ—¶é—´å°äº 0 ï¼Œç›´æ¥è¿”å› false ï¼Œå·²ç»è¶…æ—¶ã€‚
* ç¬¬ 33 è¡Œï¼šã€ç›¸åŒï¼Œè·³è¿‡ã€‘
* ç¬¬ 34 è‡³ 35 è¡Œï¼šå¦‚æœå‰©ä½™æ—¶é—´å¤§äº `spinForTimeoutThreshold` ï¼Œåˆ™è°ƒç”¨ `LockSupport#parkNanos(Object blocker, long nanos)` æ–¹æ³•ï¼Œä¼‘çœ  `nanosTimeout` **çº³**ç§’ã€‚å¦åˆ™ï¼Œå°±ä¸éœ€è¦ä¼‘çœ äº†ï¼Œç›´æ¥è¿›å…¥**å¿«é€Ÿè‡ªæ—‹**çš„è¿‡ç¨‹ã€‚åŸå› åœ¨äºï¼Œ`spinForTimeoutThreshold` å·²ç»éå¸¸å°äº†ï¼Œ**éå¸¸çŸ­çš„æ—¶é—´ç­‰å¾…æ— æ³•åšåˆ°ååˆ†ç²¾ç¡®**ï¼Œå¦‚æœè¿™æ—¶å†æ¬¡è¿›è¡Œè¶…æ—¶ç­‰å¾…ï¼Œç›¸åä¼šè®© `nanosTimeout` çš„è¶…æ—¶ä»æ•´ä½“ä¸Šé¢è¡¨ç°å¾—ä¸æ˜¯é‚£ä¹ˆç²¾ç¡®ã€‚**æ‰€ä»¥ï¼Œåœ¨è¶…æ—¶éå¸¸çŸ­çš„åœºæ™¯ä¸­ï¼ŒAQS ä¼šè¿›è¡Œæ— æ¡ä»¶çš„å¿«é€Ÿè‡ªæ—‹**ã€‚
* ç¬¬ 36 è‡³ 39 è¡Œï¼šè‹¥çº¿ç¨‹å·²ç»ä¸­æ–­äº†ï¼ŒæŠ›å‡º InterruptedException å¼‚å¸¸ã€‚
* ç¬¬ 40 è‡³ 43 è¡Œï¼šã€ç›¸åŒï¼Œè·³è¿‡ã€‘

## 1.4 ç‹¬å å¼åŒæ­¥çŠ¶æ€é‡Šæ”¾

å½“çº¿ç¨‹è·å–åŒæ­¥çŠ¶æ€åï¼Œæ‰§è¡Œå®Œç›¸åº”é€»è¾‘åï¼Œå°±éœ€è¦**é‡Šæ”¾åŒæ­¥çŠ¶æ€**ã€‚AQS æä¾›äº†`#release(int arg)`æ–¹æ³•ï¼Œé‡Šæ”¾åŒæ­¥çŠ¶æ€ã€‚ä»£ç å¦‚ä¸‹ï¼š

```Java
  1: public final boolean release(int arg) {
  2:     if (tryRelease(arg)) {
  3:         Node h = head;
  4:         if (h != null && h.waitStatus != 0)
  5:             unparkSuccessor(h);
  6:         return true;
  7:     }
  8:     return false;
  9: }
```

* ç¬¬ 2 è¡Œï¼šè°ƒç”¨ `#tryRelease(int arg)` æ–¹æ³•ï¼Œå»å°è¯•é‡Šæ”¾åŒæ­¥çŠ¶æ€ï¼Œé‡Šæ”¾æˆåŠŸåˆ™è®¾ç½®é”çŠ¶æ€å¹¶è¿”å› true ï¼Œå¦åˆ™è·å–å¤±è´¥ï¼Œè¿”å› false ã€‚åŒæ—¶ï¼Œå®ƒä»¬åˆ†åˆ«å¯¹åº”ã€ç¬¬ 3 è‡³ 6ã€‘å’Œã€ç¬¬ 8 è¡Œã€‘çš„é€»è¾‘ã€‚
    * `#tryRelease(int arg)` æ–¹æ³•ï¼Œ**éœ€è¦**è‡ªå®šä¹‰åŒæ­¥ç»„ä»¶**è‡ªå·±å®ç°**ï¼Œè¯¥æ–¹æ³•å¿…é¡»è¦ä¿è¯**çº¿ç¨‹å®‰å…¨**çš„é‡Šæ”¾åŒæ­¥çŠ¶æ€ã€‚ä»£ç å¦‚ä¸‹ï¼š

        ```Java
        protected boolean tryRelease(int arg) {
            throw new UnsupportedOperationException();
        }
        ```
        * **ç›´æ¥**æŠ›å‡º UnsupportedOperationException å¼‚å¸¸ã€‚

* ç¬¬ 3 è¡Œï¼šè·å¾—**å½“å‰**çš„ `head` ï¼Œé¿å…å¹¶å‘é—®é¢˜ã€‚
* ç¬¬ 4 è¡Œï¼šå¤´ç»“ç‚¹ä¸ä¸ºç©ºï¼Œå¹¶ä¸”å¤´ç»“ç‚¹çŠ¶æ€ä¸ä¸º 0 ( `INITAL` æœªåˆå§‹åŒ–)ã€‚ä¸ºä»€ä¹ˆä¼šå‡ºç° 0 çš„æƒ…å†µå‘¢ï¼Ÿè€è‰¿è‰¿çš„æƒ³æ³•æ˜¯ï¼Œä»¥ ReentrantReadWriteLock ( ğŸ˜ˆ å†…éƒ¨åŸºäº AQS å®ç° ) ä¸¾ä¾‹å­ï¼š
    * çº¿ç¨‹ A å’Œçº¿ç¨‹ B ï¼Œéƒ½è·å–äº†è¯»é”ã€‚
    * çº¿ç¨‹ A å’Œçº¿ç¨‹ B ï¼ŒåŸºæœ¬åŒæ—¶é‡Šæ”¾é”ï¼Œé‚£ä¹ˆæ­¤æ—¶ã€ç¬¬ 3 è¡Œã€‘`h` å¯èƒ½è·å–åˆ°çš„æ˜¯**ç›¸åŒ**çš„ `head` èŠ‚ç‚¹ã€‚æ­¤æ—¶ï¼ŒA çº¿ç¨‹æ°å¥½å…ˆæ‰§è¡Œäº† `#unparkSuccessor(Node node)` æ–¹æ³•ï¼Œä¼šå°† `waitStatus` è®¾ç½®ä¸º 0 ã€‚å› æ­¤ï¼Œ`#unparkSuccessor(Node node)` æ–¹æ³•ï¼Œå¯¹äº B çº¿ç¨‹å°±ä¸éœ€è¦è°ƒç”¨äº†ã€‚å½“ç„¶ï¼Œæ›´æç«¯çš„æƒ…å†µä¸‹ï¼Œå¯èƒ½ A å’Œ B çº¿ç¨‹ï¼Œéƒ½è°ƒç”¨äº† `#unparkSuccessor(Node node)` æ–¹æ³•ã€‚

        > è€è‰¿è‰¿ï¼šå¦‚ä¸Šæ˜¯æˆ‘çš„çŒœæƒ³ï¼Œå¹¶æœªå®é™…éªŒè¯ã€‚å¦‚æœä¸æ­£ç¡®ï¼Œæˆ–è€…æœ‰å…¶ä»–æƒ…å†µï¼Œæ¬¢è¿æ–§æ­£ã€‚

* ç¬¬ 5 è¡Œï¼šè°ƒç”¨ `#unparkSuccessor(Node node)` æ–¹æ³•ï¼Œå”¤é†’ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„çº¿ç¨‹ç­‰å¾…ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Šã€æ­»ç£• Java å¹¶å‘ã€‘â€”â€“ J.U.C ä¹‹ AQSï¼šé˜»å¡å’Œå”¤é†’çº¿ç¨‹ã€‹](http://www.iocoder.cn/JUC/sike/aqs-3) ã€‚

## 1.5 æ€»ç»“

è¿™é‡Œç¨å¾®æ€»ç»“ä¸‹ï¼š

> åœ¨ AQS ä¸­ç»´æŠ¤ç€ä¸€ä¸ª FIFO çš„åŒæ­¥é˜Ÿåˆ—ã€‚
> 
> * å½“çº¿ç¨‹è·å–åŒæ­¥çŠ¶æ€å¤±è´¥åï¼Œåˆ™ä¼šåŠ å…¥åˆ°è¿™ä¸ª CLH åŒæ­¥é˜Ÿåˆ—çš„å¯¹å°¾ï¼Œå¹¶ä¸€ç›´ä¿æŒç€è‡ªæ—‹ã€‚
> * åœ¨ CLH åŒæ­¥é˜Ÿåˆ—ä¸­çš„çº¿ç¨‹åœ¨è‡ªæ—‹æ—¶ï¼Œä¼šåˆ¤æ–­å…¶å‰é©±èŠ‚ç‚¹æ˜¯å¦ä¸ºé¦–èŠ‚ç‚¹ï¼Œå¦‚æœä¸ºé¦–èŠ‚ç‚¹åˆ™ä¸æ–­å°è¯•è·å–åŒæ­¥çŠ¶æ€ï¼Œè·å–æˆåŠŸåˆ™é€€å‡ºCLHåŒæ­¥é˜Ÿåˆ—ã€‚
> * å½“çº¿ç¨‹æ‰§è¡Œå®Œé€»è¾‘åï¼Œä¼šé‡Šæ”¾åŒæ­¥çŠ¶æ€ï¼Œé‡Šæ”¾åä¼šå”¤é†’å…¶åç»§èŠ‚ç‚¹ã€‚

# 2. å…±äº«å¼

å…±äº«å¼ä¸ç‹¬å å¼çš„æœ€ä¸»è¦åŒºåˆ«åœ¨äºï¼Œ**åŒä¸€æ—¶åˆ»**ï¼š

* ç‹¬å å¼åªèƒ½æœ‰**ä¸€ä¸ª**çº¿ç¨‹è·å–åŒæ­¥çŠ¶æ€ã€‚
* å…±äº«å¼å¯ä»¥æœ‰**å¤šä¸ª**çº¿ç¨‹è·å–åŒæ­¥çŠ¶æ€ã€‚

ä¾‹å¦‚ï¼Œè¯»æ“ä½œå¯ä»¥æœ‰å¤šä¸ªçº¿ç¨‹åŒæ—¶è¿›è¡Œï¼Œè€Œå†™æ“ä½œåŒä¸€æ—¶åˆ»åªèƒ½æœ‰ä¸€ä¸ªçº¿ç¨‹è¿›è¡Œå†™æ“ä½œï¼Œå…¶ä»–æ“ä½œéƒ½ä¼šè¢«é˜»å¡ã€‚å‚è§ ReentrantReadWriteLock ã€‚

## 2.1 å…±äº«å¼åŒæ­¥çŠ¶æ€è·å–

AQS æä¾› `#acquireShared(int arg)` æ–¹æ³•ï¼Œå…±äº«å¼è·å–åŒæ­¥çŠ¶æ€ã€‚ä»£ç å¦‚ä¸‹ï¼š

>  `#acquireShared(int arg)` æ–¹æ³•ï¼Œå¯¹æ ‡ `#acquire(int arg)` æ–¹æ³•ã€‚

```Java
  1: public final void acquireShared(int arg) {
  2:     if (tryAcquireShared(arg) < 0)
  3:         doAcquireShared(arg);
  4: }
```

* ç¬¬ 2 è¡Œï¼šè°ƒç”¨ `#tryAcquireShared(int arg)` æ–¹æ³•ï¼Œå°è¯•è·å–åŒæ­¥çŠ¶æ€ï¼Œè·å–æˆåŠŸåˆ™è®¾ç½®é”çŠ¶æ€å¹¶è¿”å›å¤§äºç­‰äº 0 ï¼Œå¦åˆ™è·å–å¤±è´¥ï¼Œè¿”å›å°äº 0 ã€‚è‹¥è·å–æˆåŠŸï¼Œç›´æ¥è¿”å›ï¼Œ**ä¸ç”¨çº¿ç¨‹é˜»å¡**ï¼Œè‡ªæ—‹ç›´åˆ°è·å¾—åŒæ­¥çŠ¶æ€æˆåŠŸã€‚
    * `#tryAcquireShared(int arg)` æ–¹æ³•ï¼Œ**éœ€è¦**è‡ªå®šä¹‰åŒæ­¥ç»„ä»¶**è‡ªå·±å®ç°**ï¼Œè¯¥æ–¹æ³•å¿…é¡»è¦ä¿è¯**çº¿ç¨‹å®‰å…¨**çš„è·å–åŒæ­¥çŠ¶æ€ã€‚ä»£ç å¦‚ä¸‹ï¼š

        ```Java
        protected int tryAcquireShared(int arg) {
            throw new UnsupportedOperationException();
        }
        ```
        * **ç›´æ¥**æŠ›å‡º UnsupportedOperationException å¼‚å¸¸ã€‚

### 2.1.1 doAcquireShared

```Java
  1: private void doAcquireShared(int arg) {
  2:     // å…±äº«å¼èŠ‚ç‚¹
  3:     final Node node = addWaiter(Node.SHARED);
  4:     boolean failed = true;
  5:     try {
  6:         boolean interrupted = false;
  7:         for (;;) {
  8:             // å‰é©±èŠ‚ç‚¹
  9:             final Node p = node.predecessor();
 10:             // å¦‚æœå…¶å‰é©±èŠ‚ç‚¹ï¼Œè·å–åŒæ­¥çŠ¶æ€
 11:             if (p == head) {
 12:                 // å°è¯•è·å–åŒæ­¥
 13:                 int r = tryAcquireShared(arg);
 14:                 if (r >= 0) {
 15:                     setHeadAndPropagate(node, r);
 16:                     p.next = null; // help GC
 17:                     if (interrupted)
 18:                         selfInterrupt();
 19:                     failed = false;
 20:                     return;
 21:                 }
 22:             }
 23:             if (shouldParkAfterFailedAcquire(p, node) &&
 24:                     parkAndCheckInterrupt())
 25:                 interrupted = true;
 26:         }
 27:     } finally {
 28:         if (failed)
 29:             cancelAcquire(node);
 30:     }
 31: }
```

* å› ä¸ºå’Œ `#acquireQueued(int arg)` æ–¹æ³•çš„åŸºç¡€ä¸Šï¼Œæ‰€ä»¥**ç›¸åŒéƒ¨åˆ†ï¼Œæˆ‘ä»¬ç›´æ¥è·³è¿‡**ã€‚
* ç¬¬ 3 è¡Œï¼šè°ƒç”¨ `#addWaiter(Node mode)` æ–¹æ³•ï¼Œå°†å½“å‰çº¿ç¨‹åŠ å…¥åˆ° CLH åŒæ­¥é˜Ÿåˆ—å°¾éƒ¨ã€‚å¹¶ä¸”ï¼Œ `mode` æ–¹æ³•å‚æ•°ä¸º `Node.SHARED` ï¼Œè¡¨ç¤º**å…±äº«**æ¨¡å¼ã€‚
* ç¬¬ 6 è¡Œï¼šã€ç›¸åŒï¼Œè·³è¿‡ã€‘
* ç¬¬ 9 è‡³ 22 è¡Œï¼šã€å¤§ä½“ç›¸åŒï¼Œéƒ¨åˆ†è·³è¿‡ã€‘
    * ç¬¬ 13 è¡Œï¼šè°ƒç”¨ `#tryAcquireShared(int arg)` æ–¹æ³•ï¼Œå°è¯•è·å¾—åŒæ­¥çŠ¶æ€ã€‚ğŸ™‚ åœ¨ `#acquireShared(int arg)` æ–¹æ³•çš„ã€ç¬¬ 2 è¡Œã€‘ï¼Œä¹Ÿè°ƒç”¨äº†è¿™ä¸ªæ–¹æ³•ã€‚
    * ç¬¬ 15 è¡Œï¼šè°ƒç”¨ `#setHeadAndPropagate(Node node, int propagate)` æ–¹æ³•ï¼Œè®¾ç½®**æ–°**çš„é¦–èŠ‚ç‚¹ï¼Œå¹¶**æ ¹æ®æ¡ä»¶**ï¼Œå”¤é†’ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ2.1.2 setHeadAndPropagateã€](#) ã€‚
        * è¿™é‡Œå’Œ**ç‹¬å å¼**åŒæ­¥çŠ¶æ€è·å–å¾ˆå¤§çš„ä¸åŒï¼šé€šè¿‡è¿™æ ·çš„æ–¹å¼ï¼Œä¸æ–­å”¤é†’ä¸‹ä¸€ä¸ª**å…±äº«å¼**åŒæ­¥çŠ¶æ€ï¼Œ ä»è€Œå®ç°åŒæ­¥çŠ¶æ€è¢«**å¤šä¸ª**çº¿ç¨‹çš„**å…±äº«è·å–**ã€‚
    * ç¬¬ 17 è‡³ 18 è¡Œï¼šå’Œ `#acquire(int arg)` æ–¹æ³•ï¼Œå¯¹äº**çº¿ç¨‹ä¸­æ–­**çš„å¤„ç†æ–¹å¼ç›¸åŒï¼Œåªæ˜¯ä»£ç æ”¾ç½®çš„ä½ç½®ä¸åŒã€‚
* ç¬¬ 23 è‡³ 25 è¡Œï¼šã€ç›¸åŒï¼Œè·³è¿‡ã€‘
* ç¬¬ 27 è‡³ 30 è¡Œï¼šã€ç›¸åŒï¼Œè·³è¿‡ã€‘

### 2.1.2 setHeadAndPropagate

```Java
  1: private void setHeadAndPropagate(Node node, int propagate) {
  2:     Node h = head; // Record old head for check below
  3:     setHead(node);
  4:     /*
  5:      * Try to signal next queued node if:
  6:      *   Propagation was indicated by caller,
  7:      *     or was recorded (as h.waitStatus either before
  8:      *     or after setHead) by a previous operation
  9:      *     (note: this uses sign-check of waitStatus because
 10:      *      PROPAGATE status may transition to SIGNAL.)
 11:      * and
 12:      *   The next node is waiting in shared mode,
 13:      *     or we don't know, because it appears null
 14:      *
 15:      * The conservatism in both of these checks may cause
 16:      * unnecessary wake-ups, but only when there are multiple
 17:      * racing acquires/releases, so most need signals now or soon
 18:      * anyway.
 19:      */
 20:     if (propagate > 0 || h == null || h.waitStatus < 0 ||
 21:         (h = head) == null || h.waitStatus < 0) {
 22:         Node s = node.next;
 23:         if (s == null || s.isShared())
 24:             doReleaseShared();
 25:     }
 26: }
```

* ç¬¬ 2 è¡Œï¼šè®°å½•**åŸæ¥**çš„**é¦–**èŠ‚ç‚¹ `h` ã€‚
* ç¬¬ 3 è¡Œï¼šè°ƒç”¨ `#setHead(Node node)` æ–¹æ³•ï¼Œè®¾ç½® `node` ä¸º**æ–°**çš„**é¦–**èŠ‚ç‚¹ã€‚
* ç¬¬ 20 è¡Œï¼š`propagate > 0` ä»£ç å—ï¼Œè¯´æ˜åŒæ­¥çŠ¶æ€è¿˜èƒ½è¢«å…¶ä»–çº¿ç¨‹è·å–ã€‚
* ç¬¬ 20 è‡³ 21 è¡Œï¼šåˆ¤æ–­**åŸæ¥**çš„æˆ–è€…**æ–°**çš„**é¦–**èŠ‚ç‚¹ï¼Œ**ç­‰å¾…çŠ¶æ€**ä¸º `Node.PROPAGATE` æˆ–è€… `Node.SIGNAL` æ—¶ï¼Œå¯ä»¥ç»§ç»­å‘ä¸‹**å”¤é†’**ã€‚
* ç¬¬ 23 è¡Œï¼šè°ƒç”¨ `Node#isShared()` æ–¹æ³•ï¼Œåˆ¤æ–­**ä¸‹**ä¸€ä¸ªèŠ‚ç‚¹ä¸º**å…±äº«å¼**è·å–åŒæ­¥çŠ¶æ€ã€‚
* ç¬¬ 24 è¡Œï¼šè°ƒç”¨ `#doReleaseShared()` æ–¹æ³•ï¼Œå”¤é†’åç»­çš„**å…±äº«å¼**è·å–åŒæ­¥çŠ¶æ€çš„èŠ‚ç‚¹ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ2.1.2 setHeadAndPropagateã€](#) ã€‚

## 2.2 å…±äº«å¼è·å–å“åº”ä¸­æ–­

`#acquireSharedInterruptibly(int arg)` æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

```Java
public final void acquireSharedInterruptibly(int arg)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (tryAcquireShared(arg) < 0)
        doAcquireSharedInterruptibly(arg);
}

private void doAcquireSharedInterruptibly(int arg)
    throws InterruptedException {
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r >= 0) {
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

* ä¸ [ã€Œ1.2 ç‹¬å å¼è·å–å“åº”ä¸­æ–­ã€](#) ç±»ä¼¼ï¼Œå°±ä¸é‡å¤è§£æäº†ã€‚

## 2.3 å…±äº«å¼è¶…æ—¶è·å–

`#tryAcquireSharedNanos(int arg, long nanosTimeout)` æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

```Java
public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    return tryAcquireShared(arg) >= 0 ||
        doAcquireSharedNanos(arg, nanosTimeout);
}

private boolean doAcquireSharedNanos(int arg, long nanosTimeout)
        throws InterruptedException {
    if (nanosTimeout <= 0L)
        return false;
    final long deadline = System.nanoTime() + nanosTimeout;
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r >= 0) {
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    failed = false;
                    return true;
                }
            }
            nanosTimeout = deadline - System.nanoTime();
            if (nanosTimeout <= 0L)
                return false;
            if (shouldParkAfterFailedAcquire(p, node) &&
                nanosTimeout > spinForTimeoutThreshold)
                LockSupport.parkNanos(this, nanosTimeout);
            if (Thread.interrupted())
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

* ä¸ [ã€Œ1.3 ç‹¬å å¼è¶…æ—¶è·å–ã€](#) ç±»ä¼¼ï¼Œå°±ä¸é‡å¤è§£æäº†ã€‚

## 2.4 å…±äº«å¼åŒæ­¥çŠ¶æ€é‡Šæ”¾

å½“çº¿ç¨‹è·å–åŒæ­¥çŠ¶æ€åï¼Œæ‰§è¡Œå®Œç›¸åº”é€»è¾‘åï¼Œå°±éœ€è¦**é‡Šæ”¾åŒæ­¥çŠ¶æ€**ã€‚AQS æä¾›äº†`#releaseShared(int arg)`æ–¹æ³•ï¼Œé‡Šæ”¾åŒæ­¥çŠ¶æ€ã€‚ä»£ç å¦‚ä¸‹ï¼š

```Java
  1: public final boolean releaseShared(int arg) {
  2:     if (tryReleaseShared(arg)) {
  3:         doReleaseShared();
  4:         return true;
  5:     }
  6:     return false;
  7: }
```

* ç¬¬ 2 è¡Œï¼šè°ƒç”¨ `#tryReleaseShared(int arg)` æ–¹æ³•ï¼Œå»å°è¯•é‡Šæ”¾åŒæ­¥çŠ¶æ€ï¼Œé‡Šæ”¾æˆåŠŸåˆ™è®¾ç½®é”çŠ¶æ€å¹¶è¿”å› true ï¼Œå¦åˆ™è·å–å¤±è´¥ï¼Œè¿”å› false ã€‚åŒæ—¶ï¼Œå®ƒä»¬åˆ†åˆ«å¯¹åº”ã€ç¬¬ 3 è‡³ 5ã€‘å’Œã€ç¬¬ 6 è¡Œã€‘çš„é€»è¾‘ã€‚
    * `#tryReleaseShared(int arg)` æ–¹æ³•ï¼Œ**éœ€è¦**è‡ªå®šä¹‰åŒæ­¥ç»„ä»¶**è‡ªå·±å®ç°**ï¼Œè¯¥æ–¹æ³•å¿…é¡»è¦ä¿è¯**çº¿ç¨‹å®‰å…¨**çš„é‡Šæ”¾åŒæ­¥çŠ¶æ€ã€‚ä»£ç å¦‚ä¸‹ï¼š

        ```Java
        protected boolean tryReleaseShared(int arg) {
            throw new UnsupportedOperationException();
        }
        ```
        * **ç›´æ¥**æŠ›å‡º UnsupportedOperationException å¼‚å¸¸ã€‚

* ç¬¬ 3 è¡Œï¼šè°ƒç”¨ `#doReleaseShared()` æ–¹æ³•ï¼Œå”¤é†’åç»­çš„**å…±äº«å¼**è·å–åŒæ­¥çŠ¶æ€çš„èŠ‚ç‚¹ã€‚

### 2.4.1 doReleaseShared

```Java
  1: private void doReleaseShared() {
  2:     /*
  3:      * Ensure that a release propagates, even if there are other
  4:      * in-progress acquires/releases.  This proceeds in the usual
  5:      * way of trying to unparkSuccessor of head if it needs
  6:      * signal. But if it does not, status is set to PROPAGATE to
  7:      * ensure that upon release, propagation continues.
  8:      * Additionally, we must loop in case a new node is added
  9:      * while we are doing this. Also, unlike other uses of
 10:      * unparkSuccessor, we need to know if CAS to reset status
 11:      * fails, if so rechecking.
 12:      */
 13:     for (;;) {
 14:         Node h = head;
 15:         if (h != null && h != tail) {
 16:             int ws = h.waitStatus;
 17:             if (ws == Node.SIGNAL) {
 18:                 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
 19:                     continue;            // loop to recheck cases
 20:                 unparkSuccessor(h);
 21:             }
 22:             else if (ws == 0 &&
 23:                      !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
 24:                 continue;                // loop on failed CAS
 25:         }
 26:         if (h == head)                   // loop if head changed
 27:             break;
 28:     }
 29: }
```

* TODO 9003 doReleaseShared çš„è¯¦ç»†é€»è¾‘ã€‚å¯å‚è€ƒåšå®¢ï¼šhttp://zhanjindong.com/2015/03/15/java-concurrent-package-aqs-AbstractQueuedSynchronizer

# å‚è€ƒèµ„æ–™

* Doug Leaï¼šã€ŠJavaå¹¶å‘ç¼–ç¨‹å®æˆ˜ã€‹
* æ–¹è…¾é£ï¼šã€ŠJavaå¹¶å‘ç¼–ç¨‹çš„è‰ºæœ¯ã€‹çš„ [ã€Œ5.2 é˜Ÿåˆ—åŒæ­¥å™¨ã€](#) ç« èŠ‚ã€‚
* [ã€ŠJava å¹¶å‘åŒ…æºç å­¦ä¹ ä¹‹ AQS æ¡†æ¶ï¼ˆå››ï¼‰AbstractQueuedSynchronizer æºç åˆ†æã€‹](http://zhanjindong.com/2015/03/15/java-concurrent-package-aqs-AbstractQueuedSynchronizer)
* [ã€Šä¸€è¡Œä¸€è¡Œæºç åˆ†ææ¸…æ¥š AbstractQueuedSynchronizerã€‹](https://javadoop.com/post/AbstractQueuedSynchronizer#)

# 666. å½©è›‹

å¦‚æœä½ å¯¹ Java å¹¶å‘æ„Ÿå…´è¶£ï¼Œæ¬¢è¿åŠ å…¥æˆ‘çš„çŸ¥è¯†æ˜Ÿçƒä¸€èµ·äº¤æµã€‚

AQS çš„æ•´ä½“è®¾è®¡éå¸¸ç²¾å·§ï¼Œæ‰€ä»¥å¾ˆå¤šåœ°æ–¹è®¾è®¡çš„å¾ˆéš¾ç†è§£ã€‚å³ä½¿è€è‰¿è‰¿åŸºäºå°æ˜å“¥çš„åšå®¢ï¼Œå¹¶ä¸” Google äº†å¾ˆå¤šåšå®¢ï¼Œå‘ç°è‡ªå·±è¿˜æ˜¯æ— æ³•é€å½»ç†è§£ã€‚åŒæ—¶ï¼Œå¤§é‡çš„åšå®¢ï¼Œä¹Ÿæ²¡å†™æ¸…æ¥šå¾ˆå¤šç»†èŠ‚ã€‚è†œæ‹œå¤§ç¥ Doug Lea çš„åŒæ—¶ï¼Œä¸å¾—ä¸è¯´æœ‰ç‚¹è‹¦é—·ï¼Œæ— æ³•å¾ˆå¹²å‡€çš„ç†è§£å’Œæè¿° AQS çš„å®ç°ã€‚

TMD ï¼Œè®°å½•äº†å¾ˆå¤š TODO ï¼Œæœªæ¥çš„æŸä¸€å¤©ï¼Œè¿˜æ˜¯ä¼šç»§ç»­æ¥å¹²ä¸€æ¬¡è¿™å—çš„ä»£ç ã€‚

![çŸ¥è¯†æ˜Ÿçƒ](http://www.iocoder.cn/images/Architecture/2017_12_29/01.png)

