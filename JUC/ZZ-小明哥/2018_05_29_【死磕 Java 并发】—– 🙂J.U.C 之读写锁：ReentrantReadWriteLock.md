title: ã€æ­»ç£• Java å¹¶å‘ã€‘â€”â€“ J.U.C ä¹‹è¯»å†™é”ï¼šReentrantReadWriteLock
date: 2018-05-29
tag: 
categories: JUC
permalink: JUC/sike/ReentrantReadWriteLock
author: å°æ˜å“¥
from_url: http://cmsblogs.com/?p=2213
wechat_url: https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247484040&idx=1&sn=60633c2dc4814b26dc4b39bb2bb5d4dd&chksm=fa497d39cd3ef42f539cd0576c1a3575ee27307048248571e954f0ff21a5a9b1ddfab522c834#rd

-------

æ‘˜è¦: åŸåˆ›å‡ºå¤„ http://cmsblogs.com/?p=2213 ã€Œå°æ˜å“¥ã€æ¬¢è¿è½¬è½½ï¼Œä¿ç•™æ‘˜è¦ï¼Œè°¢è°¢ï¼

ä½œä¸ºã€Œå°æ˜å“¥ã€çš„å¿ å®è¯»è€…ï¼Œã€Œè€è‰¿è‰¿ã€ç•¥ä½œä¿®æ”¹ï¼Œè®°å½•åœ¨ç†è§£è¿‡ç¨‹ä¸­ï¼Œå‚è€ƒçš„èµ„æ–™ã€‚

- [1. ç®€ä»‹](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
- [2. ReadWriteLock](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
- [3. ReentrantReadWriteLock](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
  - [3.1 æ„é€ æ–¹æ³•](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
  - [3.2 getThreadId](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
  - [3.3 å…¶ä»–å®ç°æ–¹æ³•](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
- [4. è¯»é”å’Œå†™é”](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
  - [4.1 ReadLock](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
  - [4.2  WriteLock](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
- [5. Sync æŠ½è±¡ç±»](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
  - [4.1 æ„é€ æ–¹æ³•](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
  - [4.2 writerShouldBlock](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
  - [4.3 readerShouldBlock](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
  - [4.4 ã€å†™é”ã€‘tryAcquire](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
  - [4.5 ã€è¯»é”ã€‘tryAcquireShared](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
  - [4.6 ã€å†™é”ã€‘tryRelease](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
  - [4.7 ã€è¯»é”ã€‘tryReleaseShared](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
  - [4.8 tryWriteLock](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
  - [4.9 tryReadLock](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
  - [4.10 isHeldExclusively](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
  - [4.11 newCondition](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
  - [4.12 å…¶ä»–å®ç°æ–¹æ³•](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
- [5. Sync å®ç°ç±»](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
  - [5.1 NonfairSync](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
  - [5.2 FairSync](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
- [6. HoldCounter](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
- [7. é”é™çº§](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
- [å‚è€ƒèµ„æ–™](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)
- [666. å½©è›‹](http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/)

-------

![](http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg)

> ğŸ™‚ğŸ™‚ğŸ™‚å…³æ³¨**å¾®ä¿¡å…¬ä¼—å·ï¼šã€èŠ‹é“æºç ã€‘**æœ‰ç¦åˆ©ï¼š  
> 1. RocketMQ / MyCAT / Sharding-JDBC **æ‰€æœ‰**æºç åˆ†ææ–‡ç« åˆ—è¡¨  
> 2. RocketMQ / MyCAT / Sharding-JDBC **ä¸­æ–‡æ³¨é‡Šæºç  GitHub åœ°å€**  
> 3. æ‚¨å¯¹äºæºç çš„ç–‘é—®æ¯æ¡ç•™è¨€**éƒ½**å°†å¾—åˆ°**è®¤çœŸ**å›å¤ã€‚**ç”šè‡³ä¸çŸ¥é“å¦‚ä½•è¯»æºç ä¹Ÿå¯ä»¥è¯·æ•™å™¢**ã€‚  
> 4. **æ–°çš„**æºç è§£ææ–‡ç« **å®æ—¶**æ”¶åˆ°é€šçŸ¥ã€‚**æ¯å‘¨æ›´æ–°ä¸€ç¯‡å·¦å³**ã€‚  
> 5. **è®¤çœŸçš„**æºç äº¤æµå¾®ä¿¡ç¾¤ã€‚

-------

> æ­¤ç¯‡åšå®¢æ‰€æœ‰æºç å‡æ¥è‡ª JDK 1.8

# 1. ç®€ä»‹

é‡å…¥é” ReentrantLock æ˜¯æ’ä»–é”ï¼Œ**æ’ä»–é”åœ¨åŒä¸€æ—¶åˆ»ä»…æœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è¿›è¡Œè®¿é—®**ï¼Œä½†æ˜¯åœ¨å¤§å¤šæ•°åœºæ™¯ä¸‹ï¼Œå¤§éƒ¨åˆ†æ—¶é—´éƒ½æ˜¯æä¾›è¯»æœåŠ¡ï¼Œè€Œå†™æœåŠ¡å æœ‰çš„æ—¶é—´è¾ƒå°‘ã€‚ç„¶è€Œï¼Œè¯»æœåŠ¡ä¸å­˜åœ¨æ•°æ®ç«äº‰é—®é¢˜ï¼Œå¦‚æœä¸€ä¸ªçº¿ç¨‹åœ¨è¯»æ—¶ç¦æ­¢å…¶ä»–çº¿ç¨‹è¯»åŠ¿å¿…ä¼šå¯¼è‡´æ€§èƒ½é™ä½ã€‚æ‰€ä»¥å°±æä¾›äº†è¯»å†™é”ã€‚

è¯»å†™é”ç»´æŠ¤ç€**ä¸€å¯¹**é”ï¼Œä¸€ä¸ªè¯»é”å’Œä¸€ä¸ªå†™é”ã€‚é€šè¿‡åˆ†ç¦»è¯»é”å’Œå†™é”ï¼Œä½¿å¾—å¹¶å‘æ€§æ¯”ä¸€èˆ¬çš„æ’ä»–é”æœ‰äº†è¾ƒå¤§çš„æå‡ï¼š

* åœ¨åŒä¸€æ—¶é—´ï¼Œå¯ä»¥å…è®¸**å¤šä¸ª**è¯»çº¿ç¨‹åŒæ—¶è®¿é—®ã€‚
* ä½†æ˜¯ï¼Œåœ¨å†™çº¿ç¨‹è®¿é—®æ—¶ï¼Œæ‰€æœ‰è¯»çº¿ç¨‹å’Œå†™çº¿ç¨‹éƒ½ä¼šè¢«é˜»å¡ã€‚

è¯»å†™é”çš„**ä¸»è¦ç‰¹æ€§**ï¼š

1. å…¬å¹³æ€§ï¼šæ”¯æŒå…¬å¹³æ€§å’Œéå…¬å¹³æ€§ã€‚
2. é‡å…¥æ€§ï¼šæ”¯æŒé‡å…¥ã€‚è¯»å†™é”æœ€å¤šæ”¯æŒ 65535 ä¸ªé€’å½’å†™å…¥é”å’Œ 65535 ä¸ªé€’å½’è¯»å–é”ã€‚
3. é”é™çº§ï¼šéµå¾ªè·å–**å†™**é”ï¼Œå†è·å–**è¯»**é”ï¼Œæœ€åé‡Šæ”¾**å†™**é”çš„æ¬¡åºï¼Œå¦‚æ­¤å†™é”èƒ½å¤Ÿ**é™çº§**æˆä¸ºè¯»é”ã€‚

# 2. ReadWriteLock

`java.util.concurrent.locks.ReadWriteLock` ï¼Œè¯»å†™é”æ¥å£ã€‚å®šä¹‰æ–¹æ³•å¦‚ä¸‹ï¼š

```Java
Lock readLock();

Lock writeLock();
```

* ä¸€å¯¹æ–¹æ³•ï¼Œåˆ†åˆ«è·å¾—**è¯»**é”å’Œ**å†™**é” Lock å¯¹è±¡ã€‚

# 3. ReentrantReadWriteLock

`java.util.concurrent.locks.ReentrantReadWriteLock` ï¼Œå®ç° ReadWriteLock æ¥å£ï¼Œ**å¯é‡å…¥**çš„**è¯»å†™é”**å®ç°ç±»ã€‚åœ¨å®ƒå†…éƒ¨ï¼Œç»´æŠ¤äº†**ä¸€å¯¹**ç›¸å…³çš„é”ï¼Œä¸€ä¸ªç”¨äºåªè¯»æ“ä½œï¼Œå¦ä¸€ä¸ªç”¨äºå†™å…¥æ“ä½œã€‚åªè¦æ²¡æœ‰ Writer çº¿ç¨‹ï¼Œè¯»å–é”å¯ä»¥ç”±å¤šä¸ª Reader çº¿ç¨‹åŒæ—¶ä¿æŒã€‚ä¹Ÿå°±è¯´è¯´ï¼Œå†™é”æ˜¯ç‹¬å çš„ï¼Œè¯»é”æ˜¯å…±äº«çš„ã€‚

ReentrantReadWriteLock ç±»çš„**å¤§ä½“**ç»“æ„å¦‚ä¸‹ï¼š

```Java
/** å†…éƒ¨ç±»  è¯»é” */
private final ReentrantReadWriteLock.ReadLock readerLock;
/** å†…éƒ¨ç±»  å†™é” */
private final ReentrantReadWriteLock.WriteLock writerLock;

final Sync sync;

/** ä½¿ç”¨é»˜è®¤ï¼ˆéå…¬å¹³ï¼‰çš„æ’åºå±æ€§åˆ›å»ºä¸€ä¸ªæ–°çš„ ReentrantReadWriteLock */
public ReentrantReadWriteLock() {
    this(false);
}

/** ä½¿ç”¨ç»™å®šçš„å…¬å¹³ç­–ç•¥åˆ›å»ºä¸€ä¸ªæ–°çš„ ReentrantReadWriteLock */
public ReentrantReadWriteLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
    readerLock = new ReadLock(this);
    writerLock = new WriteLock(this);
}

/** è¿”å›ç”¨äºå†™å…¥æ“ä½œçš„é” */
@Override
public ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; }
/** è¿”å›ç”¨äºè¯»å–æ“ä½œçš„é” */
@Override
public ReentrantReadWriteLock.ReadLock  readLock()  { return readerLock; }

abstract static class Sync extends AbstractQueuedSynchronizer {
    /**
     * çœç•¥å…¶ä½™æºä»£ç 
     */
}
public static class WriteLock implements Lock, java.io.Serializable {
    /**
     * çœç•¥å…¶ä½™æºä»£ç 
     */
}

public static class ReadLock implements Lock, java.io.Serializable {
    /**
     * çœç•¥å…¶ä½™æºä»£ç 
     */
}
```

* ReentrantReadWriteLock ä¸ ReentrantLockä¸€æ ·ï¼Œå…¶é”ä¸»ä½“ä¹Ÿæ˜¯ Syncï¼Œå®ƒçš„è¯»é”ã€å†™é”éƒ½æ˜¯é€šè¿‡ Sync æ¥å®ç°çš„ã€‚æ‰€ä»¥ ReentrantReadWriteLock å®é™…ä¸Š**åªæœ‰ä¸€ä¸ªé”**ï¼Œåªæ˜¯åœ¨è·å–è¯»å–é”å’Œå†™å…¥é”çš„æ–¹å¼ä¸Šä¸ä¸€æ ·ã€‚
* å®ƒçš„è¯»å†™é”å¯¹åº”ä¸¤ä¸ªç±»ï¼šReadLock å’Œ WriteLock ã€‚è¿™ä¸¤ä¸ªç±»éƒ½æ˜¯ Lock çš„å­ç±»å®ç°ã€‚

-------

åœ¨ ReentrantLock ä¸­ï¼Œä½¿ç”¨ Sync ( å®é™…æ˜¯ AQS )çš„ `int` ç±»å‹çš„ `state` æ¥è¡¨ç¤ºåŒæ­¥çŠ¶æ€ï¼Œè¡¨ç¤ºé”è¢«ä¸€ä¸ªçº¿ç¨‹é‡å¤è·å–çš„æ¬¡æ•°ã€‚ä½†æ˜¯ï¼Œè¯»å†™é” ReentrantReadWriteLock å†…éƒ¨ç»´æŠ¤ç€ä¸€å¯¹è¯»å†™é”ï¼Œå¦‚æœè¦ç”¨ä¸€ä¸ªå˜é‡ç»´æŠ¤å¤šç§çŠ¶æ€ï¼Œéœ€è¦é‡‡ç”¨â€œ**æŒ‰ä½åˆ‡å‰²ä½¿ç”¨**â€çš„æ–¹å¼æ¥ç»´æŠ¤è¿™ä¸ªå˜é‡ï¼Œå°†å…¶åˆ‡åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼šé«˜16ä¸ºè¡¨ç¤ºè¯»ï¼Œä½16ä¸ºè¡¨ç¤ºå†™ã€‚

åˆ†å‰²ä¹‹åï¼Œè¯»å†™é”æ˜¯å¦‚ä½•è¿…é€Ÿç¡®å®šè¯»é”å’Œå†™é”çš„çŠ¶æ€å‘¢ï¼Ÿé€šè¿‡ä½è¿ç®—ã€‚å‡å¦‚å½“å‰åŒæ­¥çŠ¶æ€ä¸ºSï¼Œé‚£ä¹ˆï¼š

* å†™çŠ¶æ€ï¼Œç­‰äº `S & 0x0000FFFF`ï¼ˆå°†é«˜ 16 ä½å…¨éƒ¨æŠ¹å»ï¼‰
* è¯»çŠ¶æ€ï¼Œç­‰äº `S >>> 16` (æ— ç¬¦å·è¡¥ 0 å³ç§» 16 ä½)ã€‚

ä»£ç å¦‚ä¸‹ï¼š

```Java
// Sync.java

static final int SHARED_SHIFT   = 16; // ä½æ•°
static final int SHARED_UNIT    = (1 << SHARED_SHIFT);
static final int MAX_COUNT      = (1 << SHARED_SHIFT) - 1; // æ¯ä¸ªé”çš„æœ€å¤§é‡å…¥æ¬¡æ•°ï¼Œ65535
static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;

static int sharedCount(int c)    { return c >>> SHARED_SHIFT; }
static int exclusiveCount(int c) { return c & EXCLUSIVE_MASK; }
```

* `#exclusiveCount(int c)` é™æ€æ–¹æ³•ï¼Œè·å¾—æŒæœ‰å†™çŠ¶æ€çš„é”çš„æ¬¡æ•°ã€‚
* `#sharedCount(int c)` é™æ€æ–¹æ³•ï¼Œè·å¾—æŒæœ‰è¯»çŠ¶æ€çš„é”çš„**çº¿ç¨‹æ•°é‡**ã€‚ä¸åŒäºå†™é”ï¼Œè¯»é”å¯ä»¥**åŒæ—¶**è¢«**å¤šä¸ª**çº¿ç¨‹æŒæœ‰ã€‚è€Œæ¯ä¸ªçº¿ç¨‹æŒæœ‰çš„è¯»é”æ”¯æŒ**é‡å…¥**çš„ç‰¹æ€§ï¼Œæ‰€ä»¥éœ€è¦å¯¹æ¯ä¸ªçº¿ç¨‹æŒæœ‰çš„è¯»é”çš„æ•°é‡**å•ç‹¬è®¡æ•°**ï¼Œè¿™å°±éœ€è¦ç”¨åˆ° HoldCounter è®¡æ•°å™¨ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ6. HoldCounterã€](#) ã€‚

åˆ’åˆ†å¦‚ä¸‹å›¾ï¼š

> FROM ã€ŠJavaå¹¶å‘ç¼–ç¨‹çš„è‰ºæœ¯ã€‹çš„ [ã€Œ5.4 è¯»å†™é”ã€](#) ç« èŠ‚
> 
> ![åˆ’åˆ†](http://www.iocoder.cn/images/JUC/è¯»å†™é”-01.png)
 
## 3.1 æ„é€ æ–¹æ³• 
 
 åœ¨ä¸Šé¢çš„æ„é€ æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬å·²ç»çœ‹åˆ°åŸºäº `fair` å‚æ•°ï¼Œåˆ›å»º åˆ›å»º FairSync è¿˜æ˜¯ NonfairSync å¯¹è±¡ã€‚
 
## 3.2 getThreadId
 
 `#getThreadId(Thread thread)` **é™æ€**æ–¹æ³•ï¼Œè·å¾—çº¿ç¨‹ç¼–å·ã€‚ä»£ç å¦‚ä¸‹ï¼š
 
 ```Java
 /**
 * Returns the thread id for the given thread.  We must access
 * this directly rather than via method Thread.getId() because
 * getId() is not final, and has been known to be overridden in
 * ways that do not preserve unique mappings.
 */
static final long getThreadId(Thread thread) {
    return UNSAFE.getLongVolatile(thread, TID_OFFSET);
}

// Unsafe mechanics
private static final sun.misc.Unsafe UNSAFE;
private static final long TID_OFFSET;
static {
    try {
        UNSAFE = sun.misc.Unsafe.getUnsafe();
        Class<?> tk = Thread.class;
        TID_OFFSET = UNSAFE.objectFieldOffset
            (tk.getDeclaredField("tid"));
    } catch (Exception e) {
        throw new Error(e);
    }
}
 ```
 
* æŒ‰é“ç†è¯´ï¼Œç›´æ¥è°ƒç”¨**çº¿ç¨‹**å¯¹åº”çš„ `Thread#getId()` æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

    ```Java
    private long tid;
    
    public long getId() {
        return tid;
    }
    ```
    * ä½†æ˜¯å®é™…ä¸Šï¼ŒThread çš„è¿™ä¸ªæ–¹æ³•æ˜¯**é `final` ä¿®é¥°çš„**ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœæˆ‘ä»¬æœ‰å®ç° Thread çš„å­ç±»ï¼Œå®Œå…¨å¯ä»¥**è¦†å†™**è¿™ä¸ªæ–¹æ³•ï¼Œæ‰€ä»¥å¯èƒ½å¯¼è‡´æ— æ³•è·å¾— `tid` å±æ€§ã€‚å› æ­¤ä¸Šé¢çš„æ–¹æ³•ï¼Œä½¿ç”¨ **Unsafe** ç›´æ¥è·å¾— `tid` å±æ€§ã€‚ä¸æ„§æ˜¯ JDK çš„æºç ï¼Œç»†æ€ææã€‚
    * å¦å¤–ï¼Œ[JDK-6346938](https://bugs.openjdk.java.net/browse/JDK-6346938) ä¹Ÿè®¨è®ºäº† â€œjava.lang.Thread.getId() should be finalâ€ è¿™ä¸ªé—®é¢˜ï¼Œç›®å‰å·²ç»è¢« JDK è®¤ä¸ºæ˜¯ä¸€ä¸ª BUG ï¼Œä½†æ˜¯ä¸é€ ä¸ºä»€ä¹ˆä¸€ç›´æ²¡ä¿®å¤ã€‚

## 3.3 å…¶ä»–å®ç°æ–¹æ³•
 
ReentrantReadWriteLock çš„å®ç°æ–¹æ³•ï¼Œä¸»è¦æ˜¯è°ƒç”¨ Sync å¯¹åº”çš„æ–¹æ³•ï¼Œæ‰€ä»¥é‡ç‚¹è¿˜æ˜¯çœ‹ä¸‹é¢éƒ¨åˆ†çš„æ–‡ç« ã€‚

> è€è‰¿è‰¿ï¼šå¯ä»¥ç¨å¾®çœ‹ä¸‹ï¼Œç„¶åè·³è¿‡å…ˆçœ‹ä¸‹é¢éƒ¨åˆ†çš„å†…å®¹ã€‚

```Java
public final boolean isFair() {
    return sync instanceof FairSync;
}

public int getReadLockCount() {
    return sync.getReadLockCount();
}

public boolean isWriteLocked() {
    return sync.isWriteLocked();
}
public boolean isWriteLockedByCurrentThread() {
    return sync.isHeldExclusively();
}

public int getReadHoldCount() {
    return sync.getReadHoldCount();
}

protected Collection<Thread> getQueuedWriterThreads() {
    return sync.getExclusiveQueuedThreads();
}
protected Collection<Thread> getQueuedReaderThreads() {
    return sync.getSharedQueuedThreads();
}
public final boolean hasQueuedThreads() {
    return sync.hasQueuedThreads();
}
public final boolean hasQueuedThread(Thread thread) {
    return sync.isQueued(thread);
}
public final int getQueueLength() {
    return sync.getQueueLength();
}
protected Collection<Thread> getQueuedThreads() {
    return sync.getQueuedThreads();
}

public boolean hasWaiters(Condition condition) {
    if (condition == null)
        throw new NullPointerException();
    if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject))
        throw new IllegalArgumentException("not owner");
    return sync.hasWaiters((AbstractQueuedSynchronizer.ConditionObject)condition);
}
public int getWaitQueueLength(Condition condition) {
    if (condition == null)
        throw new NullPointerException();
    if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject))
        throw new IllegalArgumentException("not owner");
    return sync.getWaitQueueLength((AbstractQueuedSynchronizer.ConditionObject)condition);
}
protected Collection<Thread> getWaitingThreads(Condition condition) {
    if (condition == null)
        throw new NullPointerException();
    if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject))
        throw new IllegalArgumentException("not owner");
    return sync.getWaitingThreads((AbstractQueuedSynchronizer.ConditionObject)condition);
}
```
 
# 4. è¯»é”å’Œå†™é”

åœ¨ä¸Šæ–‡ä¸­ï¼Œæˆ‘ä»¬ä¹Ÿæåˆ°ï¼ŒReentrantReadWriteLock çš„è¯»é”å’Œå†™é”ï¼ŒåŸºäºå®ƒå†…éƒ¨çš„ Sync å®ç°ï¼Œæ‰€ä»¥å…·ä½“çš„å®ç°æ–¹æ³•ï¼Œå°±æ˜¯**å¯¹å†…éƒ¨çš„ Sync çš„æ–¹æ³•çš„è°ƒç”¨**ã€‚

## 4.1 ReadLock

ReadLock æ˜¯ ReentrantReadWriteLock çš„å†…éƒ¨é™æ€ç±»ï¼Œå®ç° `java.util.concurrent.locks.Lock` æ¥å£ï¼Œè¯»é”å®ç°ç±»ã€‚

### 4.1.1 æ„é€ æ–¹æ³•

```Java
private final Sync sync;

protected ReadLock(ReentrantReadWriteLock lock) {
    sync = lock.sync;
}
```

* `sync` å­—æ®µï¼Œé€šè¿‡ ReentrantReadWriteLock çš„æ„é€ æ–¹æ³•ï¼Œä¼ å…¥å¹¶ä½¿ç”¨å®ƒçš„ Sync å¯¹è±¡ã€‚

### 4.1.2 lock

```Java
@Override
public void lock() {
    sync.acquireShared(1);
}
```

* è°ƒç”¨ AQS çš„ `#acquireShared(int arg)` æ–¹æ³•ï¼Œ**å…±äº«å¼**è·å¾—åŒæ­¥çŠ¶æ€ã€‚æ‰€ä»¥ï¼Œè¯»é”å¯ä»¥**åŒæ—¶**è¢«**å¤šä¸ª**çº¿ç¨‹è·å–ã€‚

### 4.1.3 lockInterruptibly

```Java
@Override
public void lockInterruptibly() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
}
```

### 4.1.4 tryLock

```Java
/**
 * Acquires the read lock only if the write lock is not held by
 * another thread at the time of invocation.
 *
 * <p>Acquires the read lock if the write lock is not held by
 * another thread and returns immediately with the value
 * {@code true}. Even when this lock has been set to use a
 * fair ordering policy, a call to {@code tryLock()}
 * <em>will</em> immediately acquire the read lock if it is
 * available, whether or not other threads are currently
 * waiting for the read lock.  This &quot;barging&quot; behavior
 * can be useful in certain circumstances, even though it
 * breaks fairness. If you want to honor the fairness setting
 * for this lock, then use {@link #tryLock(long, TimeUnit)
 * tryLock(0, TimeUnit.SECONDS) } which is almost equivalent
 * (it also detects interruption).
 *
 * <p>If the write lock is held by another thread then
 * this method will return immediately with the value
 * {@code false}.
 *
 * @return {@code true} if the read lock was acquired
 */
@Override
public boolean tryLock() {
    return sync.tryReadLock();
}
```

* è¯¦ç»†çš„è¯´æ˜ï¼Œèƒ–å‹å¯ä»¥çœ‹ä¸Šé¢çš„è‹±æ–‡æ³¨é‡Šã€‚å®é™…ä¸Šï¼ŒåŸå› å’Œ [ã€Šã€æ­»ç£• Java å¹¶å‘ã€‘â€”â€“ J.U.C ä¹‹é‡å…¥é”ï¼šReentrantLockã€‹](http://www.iocoder.cn/JUC/sike/ReentrantLock?self) çš„ [ã€Œ4.4 tryLockã€](#) ç›¸åŒã€‚
* è€è‰¿è‰¿çš„ç®€å•ç†è§£æ˜¯ï¼š
    * `#tryLock()` **å®ç°**æ–¹æ³•ï¼Œåœ¨å®ç°æ—¶ï¼Œå¸Œæœ›èƒ½**å¿«é€Ÿçš„**è·å¾—æ˜¯å¦èƒ½å¤Ÿè·å¾—åˆ°é”ï¼Œå› æ­¤å³ä½¿åœ¨è®¾ç½®ä¸º `fair = true` ( ä½¿ç”¨å…¬å¹³é” )ï¼Œä¾ç„¶è°ƒç”¨ `Sync#tryReadLock()` æ–¹æ³•ã€‚
    * å¦‚æœ**çœŸçš„**å¸Œæœ› `#tryLock()` è¿˜æ˜¯æŒ‰ç…§æ˜¯å¦å…¬å¹³é”çš„æ–¹å¼æ¥ï¼Œå¯ä»¥è°ƒç”¨ `#tryLock(0, TimeUnit)` æ–¹æ³•æ¥å®ç°ã€‚

### 4.1.5 tryLock

```Java
@Override
public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {
    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
}
```

### 4.1.6 unlock

```Java
@Override
public void unlock() {
    sync.releaseShared(1);
}
```

* è°ƒç”¨ AQS çš„ `#releaseShared(int arg)` æ–¹æ³•ï¼Œ**å…±äº«å¼**é‡Šæ”¾åŒæ­¥çŠ¶æ€ã€‚

### 4.1.7 newCondition

```Java
@Override
public Condition newCondition() {
    throw new UnsupportedOperationException();
}
```

* ä¸æ”¯æŒ Condition æ¡ä»¶ã€‚

## 4.2  WriteLock
 
 > WriteLock çš„ä»£ç ï¼Œç±»ä¼¼ ReadLock çš„ä»£ç ï¼Œå·®åˆ«åœ¨äº**ç‹¬å å¼**è·å–åŒæ­¥çŠ¶æ€ã€‚
 
 WriteLock æ˜¯ ReentrantReadWriteLock çš„å†…éƒ¨é™æ€ç±»ï¼Œå®ç° `java.util.concurrent.locks.Lock` æ¥å£ï¼Œå†™é”å®ç°ç±»ã€‚

### 4.2.1 æ„é€ æ–¹æ³•

```Java
private final Sync sync;

protected ReadLock(ReentrantReadWriteLock lock) {
    sync = lock.sync;
}
```

* `sync` å­—æ®µï¼Œé€šè¿‡ ReentrantReadWriteLock çš„æ„é€ æ–¹æ³•ï¼Œä¼ å…¥å¹¶ä½¿ç”¨å®ƒçš„ Sync å¯¹è±¡ã€‚
 
### 4.2.2 lock
 
```Java
@Override
public void lock() {
    sync.acquire(1);
}
```

* è°ƒç”¨ AQS çš„ `#.acquire(int arg)` æ–¹æ³•ï¼Œ**ç‹¬å å¼**è·å¾—åŒæ­¥çŠ¶æ€ã€‚æ‰€ä»¥ï¼Œå†™é”åªèƒ½**åŒæ—¶**è¢«**ä¸€ä¸ª**çº¿ç¨‹è·å–ã€‚
 
### 4.2.3 lockInterruptibly

```Java
@Override
public void lockInterruptibly() throws InterruptedException {
    sync.acquireInterruptibly(1);
}
```
 
### 4.2.4 tryLock
 
 ```Java
 /**
 * Acquires the write lock only if it is not held by another thread
 * at the time of invocation.
 *
 * <p>Acquires the write lock if neither the read nor write lock
 * are held by another thread
 * and returns immediately with the value {@code true},
 * setting the write lock hold count to one. Even when this lock has
 * been set to use a fair ordering policy, a call to
 * {@code tryLock()} <em>will</em> immediately acquire the
 * lock if it is available, whether or not other threads are
 * currently waiting for the write lock.  This &quot;barging&quot;
 * behavior can be useful in certain circumstances, even
 * though it breaks fairness. If you want to honor the
 * fairness setting for this lock, then use {@link
 * #tryLock(long, TimeUnit) tryLock(0, TimeUnit.SECONDS) }
 * which is almost equivalent (it also detects interruption).
 *
 * <p>If the current thread already holds this lock then the
 * hold count is incremented by one and the method returns
 * {@code true}.
 *
 * <p>If the lock is held by another thread then this method
 * will return immediately with the value {@code false}.
 *
 * @return {@code true} if the lock was free and was acquired
 * by the current thread, or the write lock was already held
 * by the current thread; and {@code false} otherwise.
 */
 @Override
 public boolean tryLock( ) {
    return sync.tryWriteLock();
}
 ```
 
 * è¯¦ç»†çš„è¯´æ˜ï¼Œèƒ–å‹å¯ä»¥çœ‹ä¸Šé¢çš„è‹±æ–‡æ³¨é‡Šã€‚å®é™…ä¸Šï¼ŒåŸå› å’Œ [ã€Šã€æ­»ç£• Java å¹¶å‘ã€‘â€”â€“ J.U.C ä¹‹é‡å…¥é”ï¼šReentrantLockã€‹](http://www.iocoder.cn/JUC/sike/ReentrantLock?self) çš„ [ã€Œ4.4 tryLockã€](#) ç›¸åŒã€‚
* è€è‰¿è‰¿çš„ç®€å•ç†è§£æ˜¯ï¼š
    * `#tryLock()` **å®ç°**æ–¹æ³•ï¼Œåœ¨å®ç°æ—¶ï¼Œå¸Œæœ›èƒ½**å¿«é€Ÿçš„**è·å¾—æ˜¯å¦èƒ½å¤Ÿè·å¾—åˆ°é”ï¼Œå› æ­¤å³ä½¿åœ¨è®¾ç½®ä¸º `fair = true` ( ä½¿ç”¨å…¬å¹³é” )ï¼Œä¾ç„¶è°ƒç”¨ `Sync#tryWriteLock()` æ–¹æ³•ã€‚
    * å¦‚æœ**çœŸçš„**å¸Œæœ› `#tryLock()` è¿˜æ˜¯æŒ‰ç…§æ˜¯å¦å…¬å¹³é”çš„æ–¹å¼æ¥ï¼Œå¯ä»¥è°ƒç”¨ `#tryLock(0, TimeUnit)` æ–¹æ³•æ¥å®ç°ã€‚
 
### 4.2.5 tryLock
 
 ```Java
@Override 
public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {
    return sync.tryAcquireNanos(1, unit.toNanos(timeout));
}
 ```
 
### 4.2.6 unlock
 
```Java
@Override
public void unlock() {
    sync.release(1);
}
```

* è°ƒç”¨ AQS çš„ `#release(int arg)` æ–¹æ³•ï¼Œ**ç‹¬å å¼**é‡Šæ”¾åŒæ­¥çŠ¶æ€ã€‚
 
### 4.2.7 newCondition
 
```Java
@Override
public Condition newCondition() {
    return sync.newCondition();
}
```

* è°ƒç”¨ `Sync#newCondition()` æ–¹æ³•ï¼Œåˆ›å»º Condition å¯¹è±¡ã€‚
 
### 4.2.8 isHeldByCurrentThread

```Java
public boolean isHeldByCurrentThread() {
    return sync.isHeldExclusively();
}
```

* è°ƒç”¨ `Sync#isHeldExclusively()` æ–¹æ³•ï¼Œåˆ¤æ–­æ˜¯å¦è¢«å½“å‰çº¿ç¨‹**ç‹¬å **é”ã€‚

### 4.2.9 getHoldCount

```Java
public int getHoldCount() {
    return sync.getWriteHoldCount();
}
```

* è°ƒç”¨ `Sync#getWriteHoldCount()` æ–¹æ³•ï¼Œè¿”å›å½“å‰çº¿ç¨‹**ç‹¬å **é”çš„æŒæœ‰æ•°é‡ã€‚
 
# 5. Sync æŠ½è±¡ç±»

Sync æ˜¯ ReentrantReadWriteLock çš„å†…éƒ¨é™æ€ç±»ï¼Œå®ç° AbstractQueuedSynchronizer æŠ½è±¡ç±»ï¼ŒåŒæ­¥å™¨æŠ½è±¡ç±»ã€‚å®ƒä½¿ç”¨ AQS çš„ `state` å­—æ®µï¼Œæ¥è¡¨ç¤ºå½“å‰é”çš„æŒæœ‰æ•°é‡ï¼Œä»è€Œå®ç°**å¯é‡å…¥**å’Œ**è¯»å†™é”**çš„ç‰¹æ€§ã€‚

## 4.1 æ„é€ æ–¹æ³•

```Java
private transient ThreadLocalHoldCounter readHolds; // å½“å‰çº¿ç¨‹çš„è¯»é”æŒæœ‰æ•°é‡

private transient Thread firstReader = null; // ç¬¬ä¸€ä¸ªè·å–è¯»é”çš„çº¿ç¨‹
private transient int firstReaderHoldCount; // ç¬¬ä¸€ä¸ªè·å–è¯»é”çš„é‡å…¥æ•°

private transient HoldCounter cachedHoldCounter; // æœ€åä¸€ä¸ªè·å¾—è¯»é”çš„çº¿ç¨‹çš„ HoldCounter çš„ç¼“å­˜å¯¹è±¡

Sync() {
    readHolds = new ThreadLocalHoldCounter();
    setState(getState()); // ensures visibility of readHolds
}
```

* è¯¦ç»†è§£æï¼Œè§ [ã€Œ6. HoldCounterã€](#) ã€‚

## 4.2 writerShouldBlock

```Java
abstract boolean writerShouldBlock();
```

* è·å–**å†™é”**æ—¶ï¼Œå¦‚æœæœ‰å‰åºèŠ‚ç‚¹ä¹Ÿè·å¾—é”æ—¶ï¼Œæ˜¯å¦é˜»å¡ã€‚NonefairSync å’Œ FairSync ä¸‹æœ‰ä¸åŒçš„å®ç°ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ6. Sync å®ç°ç±»ã€](#) ã€‚

## 4.3 readerShouldBlock

```Java
abstract boolean readerShouldBlock();
```

* è·å–**è¯»é”**æ—¶ï¼Œå¦‚æœæœ‰å‰åºèŠ‚ç‚¹ä¹Ÿè·å¾—é”æ—¶ï¼Œæ˜¯å¦é˜»å¡ã€‚NonefairSync å’Œ FairSync ä¸‹æœ‰ä¸åŒçš„å®ç°ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ6. Sync å®ç°ç±»ã€](#) ã€‚

## 4.4 ã€å†™é”ã€‘tryAcquire

```Java
@Override
protected final boolean tryAcquire(int acquires) {
    Thread current = Thread.currentThread();
    //å½“å‰é”ä¸ªæ•°
    int c = getState();
    //å†™é”
    int w = exclusiveCount(c);
    if (c != 0) {
        //c != 0 && w == 0 è¡¨ç¤ºå­˜åœ¨è¯»é”
        //å½“å‰çº¿ç¨‹ä¸æ˜¯å·²ç»è·å–å†™é”çš„çº¿ç¨‹
        if (w == 0 || current != getExclusiveOwnerThread())
            return false;
        //è¶…å‡ºæœ€å¤§èŒƒå›´
        if (w + exclusiveCount(acquires) > MAX_COUNT)
            throw new Error("Maximum lock count exceeded");
        setState(c + acquires);
        return true;
    }
    // æ˜¯å¦éœ€è¦é˜»å¡
    if (writerShouldBlock() ||
            !compareAndSetState(c, c + acquires))
        return false;
    //è®¾ç½®è·å–é”çš„çº¿ç¨‹ä¸ºå½“å‰çº¿ç¨‹
    setExclusiveOwnerThread(current);
    return true;
}
```

* è¯¥æ–¹æ³•å’Œ ReentrantLock çš„ `#tryAcquire(int arg)` **å¤§è‡´ä¸€æ ·**ï¼Œå·®åˆ«åœ¨**åˆ¤æ–­é‡å…¥**æ—¶ï¼Œå¢åŠ äº†ä¸€é¡¹æ¡ä»¶ï¼šè¯»é”æ˜¯å¦å­˜åœ¨ã€‚å› ä¸ºè¦ç¡®ä¿å†™é”çš„æ“ä½œå¯¹è¯»é”æ˜¯**å¯è§çš„**ã€‚å¦‚æœåœ¨å­˜åœ¨è¯»é”çš„æƒ…å†µä¸‹å…è®¸è·å–å†™é”ï¼Œé‚£ä¹ˆé‚£äº›å·²ç»è·å–è¯»é”çš„å…¶ä»–çº¿ç¨‹å¯èƒ½å°±æ— æ³•æ„ŸçŸ¥å½“å‰å†™çº¿ç¨‹çš„æ“ä½œã€‚å› æ­¤åªæœ‰ç­‰è¯»é”å®Œå…¨é‡Šæ”¾åï¼Œå†™é”æ‰èƒ½å¤Ÿè¢«å½“å‰çº¿ç¨‹æ‰€è·å–ï¼Œä¸€æ—¦å†™é”è·å–äº†ï¼Œæ‰€æœ‰å…¶ä»–è¯»ã€å†™çº¿ç¨‹å‡ä¼šè¢«é˜»å¡ã€‚
* è°ƒç”¨ `#writerShouldBlock()` **æŠ½è±¡**æ–¹æ³•ï¼Œè‹¥è¿”å› true ï¼Œåˆ™è·å–å†™é”**å¤±è´¥**ã€‚

## 4.5 ã€è¯»é”ã€‘tryAcquireShared

`#tryAcqurireShared(int arg)` æ–¹æ³•ï¼Œå°è¯•è·å–**è¯»åŒæ­¥çŠ¶æ€**ï¼Œè·å–æˆåŠŸè¿”å› `>= 0` çš„ç»“æœï¼Œå¦åˆ™è¿”å› `< 0` çš„ç»“æœã€‚ä»£ç å¦‚ä¸‹ï¼š

```Java
protected final int tryAcquireShared(int unused) {
    //å½“å‰çº¿ç¨‹
    Thread current = Thread.currentThread();
    int c = getState();
    //exclusiveCount(c)è®¡ç®—å†™é”
    //å¦‚æœå­˜åœ¨å†™é”ï¼Œä¸”é”çš„æŒæœ‰è€…ä¸æ˜¯å½“å‰çº¿ç¨‹ï¼Œç›´æ¥è¿”å›-1
    //å­˜åœ¨é”é™çº§é—®é¢˜ï¼Œåç»­é˜è¿°
    if (exclusiveCount(c) != 0 &&
            getExclusiveOwnerThread() != current)
        return -1;
    //è¯»é”
    int r = sharedCount(c);

    /*
     * readerShouldBlock():è¯»é”æ˜¯å¦éœ€è¦ç­‰å¾…ï¼ˆå…¬å¹³é”åŸåˆ™ï¼‰
     * r < MAX_COUNTï¼šæŒæœ‰çº¿ç¨‹å°äºæœ€å¤§æ•°ï¼ˆ65535ï¼‰
     * compareAndSetState(c, c + SHARED_UNIT)ï¼šè®¾ç½®è¯»å–é”çŠ¶æ€
     */
    if (!readerShouldBlock() &&
            r < MAX_COUNT &&
            compareAndSetState(c, c + SHARED_UNIT)) { //ä¿®æ”¹é«˜16ä½çš„çŠ¶æ€ï¼Œæ‰€ä»¥è¦åŠ ä¸Š2^16
        /*
         * holdCountéƒ¨åˆ†åé¢è®²è§£
         */
        if (r == 0) {
            firstReader = current;
            firstReaderHoldCount = 1;
        } else if (firstReader == current) {
            firstReaderHoldCount++;
        } else {
            HoldCounter rh = cachedHoldCounter;
            if (rh == null || rh.tid != getThreadId(current))
                cachedHoldCounter = rh = readHolds.get();
            else if (rh.count == 0)
                readHolds.set(rh);
            rh.count++;
        }
        return 1;
    }
    return fullTryAcquireShared(current);
}
```

* è¯»é”è·å–çš„è¿‡ç¨‹ç›¸å¯¹äºç‹¬å é”è€Œè¨€ä¼šç¨å¾®å¤æ‚ä¸‹ï¼Œæ•´ä¸ªè¿‡ç¨‹å¦‚ä¸‹ï¼š
    1. å› ä¸ºå­˜åœ¨é”é™çº§æƒ…å†µï¼Œå¦‚æœå­˜åœ¨å†™é”ä¸”é”çš„æŒæœ‰è€…ä¸æ˜¯å½“å‰çº¿ç¨‹ï¼Œåˆ™ç›´æ¥è¿”å›å¤±è´¥ï¼Œå¦åˆ™ç»§ç»­ã€‚
    2. ä¾æ®å…¬å¹³æ€§åŸåˆ™ï¼Œè°ƒç”¨ `#readerShouldBlock()` æ–¹æ³•æ¥åˆ¤æ–­è¯»é”æ˜¯å¦**ä¸éœ€**è¦é˜»å¡ï¼Œè¯»é”æŒæœ‰çº¿ç¨‹æ•°å°äºæœ€å¤§å€¼ï¼ˆ65535ï¼‰ï¼Œä¸” **CAS** è®¾ç½®é”çŠ¶æ€æˆåŠŸï¼Œæ‰§è¡Œä»¥ä¸‹ä»£ç ï¼ˆå¯¹äº HoldCounter ï¼Œè§ [ã€Œ6. HoldCounterã€](#) ä¸­ï¼‰ï¼Œå¹¶è¿”å› 1 ã€‚å¦‚æœä¸æ»¡è¶³ä»»ä¸€æ¡ä»¶ï¼Œåˆ™è°ƒç”¨ `#fullTryAcquireShared(Thread thread)` æ–¹æ³•ï¼Œè¯¦ç»†è§£æï¼Œè§ [ã€Œ4.5.1 fullTryAcquireSharedã€](#) ä¸­ã€‚

### 4.5.1 fullTryAcquireShared

```Java
final int fullTryAcquireShared(Thread current) {
   HoldCounter rh = null;
   for (;;) {
       int c = getState();
       // é”é™çº§
       if (exclusiveCount(c) != 0) {
           if (getExclusiveOwnerThread() != current)
               return -1;
       }
       // è¯»é”éœ€è¦é˜»å¡ï¼Œåˆ¤æ–­æ˜¯å¦å½“å‰çº¿ç¨‹å·²ç»è·å–åˆ°è¯»é”
       else if (readerShouldBlock()) {
           //åˆ—å¤´ä¸ºå½“å‰çº¿ç¨‹
           if (firstReader == current) {
           }
           //HoldCounteråé¢è®²è§£
           else {
               if (rh == null) {
                   rh = cachedHoldCounter;
                   if (rh == null || rh.tid != getThreadId(current)) {
                       rh = readHolds.get();
                       if (rh.count == 0) // è®¡æ•°ä¸º 0 ï¼Œè¯´æ˜æ²¡å¾—åˆ°è¯»é”ï¼Œæ¸…ç©ºçº¿ç¨‹å˜é‡
                           readHolds.remove();
                   }
               }
               if (rh.count == 0) // è¯´æ˜æ²¡å¾—åˆ°è¯»é”
                   return -1;
           }
       }
       //è¯»é”è¶…å‡ºæœ€å¤§èŒƒå›´
       if (sharedCount(c) == MAX_COUNT)
           throw new Error("Maximum lock count exceeded");
       //CASè®¾ç½®è¯»é”æˆåŠŸ
       if (compareAndSetState(c, c + SHARED_UNIT)) { //ä¿®æ”¹é«˜16ä½çš„çŠ¶æ€ï¼Œæ‰€ä»¥è¦åŠ ä¸Š2^16  
           //å¦‚æœæ˜¯ç¬¬1æ¬¡è·å–â€œè¯»å–é”â€ï¼Œåˆ™æ›´æ–°firstReaderå’ŒfirstReaderHoldCount
           if (sharedCount(c) == 0) {
               firstReader = current;
               firstReaderHoldCount = 1;
           }
           //å¦‚æœæƒ³è¦è·å–é”çš„çº¿ç¨‹(current)æ˜¯ç¬¬1ä¸ªè·å–é”(firstReader)çš„çº¿ç¨‹,åˆ™å°†firstReaderHoldCount+1
           else if (firstReader == current) {
               firstReaderHoldCount++;
           } else {
               if (rh == null)
                   rh = cachedHoldCounter;
               if (rh == null || rh.tid != getThreadId(current))
                   rh = readHolds.get();
               else if (rh.count == 0)
                   readHolds.set(rh);
               //æ›´æ–°çº¿ç¨‹çš„è·å–â€œè¯»å–é”â€çš„å…±äº«è®¡æ•°
               rh.count++;
               cachedHoldCounter = rh; // cache for release
           }
           return 1;
       }
   }
}
```

* è¯¥æ–¹æ³•ä¼šæ ¹æ®â€œæ˜¯å¦éœ€è¦é˜»å¡ç­‰å¾…â€ï¼Œâ€œè¯»å–é”çš„å…±äº«è®¡æ•°æ˜¯å¦è¶…è¿‡é™åˆ¶â€ç­‰ç­‰è¿›è¡Œå¤„ç†ã€‚å¦‚æœä¸éœ€è¦é˜»å¡ç­‰å¾…ï¼Œå¹¶ä¸”é”çš„å…±äº«è®¡æ•°æ²¡æœ‰è¶…è¿‡é™åˆ¶ï¼Œåˆ™é€šè¿‡ **CAS** å°è¯•è·å–é”ï¼Œå¹¶è¿”å› 1 ã€‚æ‰€ä»¥ï¼Œ`#fullTryAcquireShared(Thread)` æ–¹æ³•ï¼Œæ˜¯ `#tryAcquireShared(int unused)` æ–¹æ³•çš„**è‡ªæ—‹é‡è¯•çš„**é€»è¾‘ã€‚

## 4.6 ã€å†™é”ã€‘tryRelease

```Java
protected final boolean tryRelease(int releases) {
    //é‡Šæ”¾çš„çº¿ç¨‹ä¸ä¸ºé”çš„æŒæœ‰è€…
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    int nextc = getState() - releases;
    //è‹¥å†™é”çš„æ–°çº¿ç¨‹æ•°ä¸º0ï¼Œåˆ™å°†é”çš„æŒæœ‰è€…è®¾ç½®ä¸ºnull
    boolean free = exclusiveCount(nextc) == 0;
    if (free)
        setExclusiveOwnerThread(null);
    setState(nextc);
    return free;
}
```

* å†™é”é‡Šæ”¾é”çš„æ•´ä¸ªè¿‡ç¨‹ï¼Œå’Œç‹¬å é” ReentrantLock **ç›¸ä¼¼**ï¼Œæ¯æ¬¡é‡Šæ”¾å‡æ˜¯å‡å°‘å†™çŠ¶æ€ï¼Œå½“å†™çŠ¶æ€ä¸º 0 æ—¶ï¼Œè¡¨ç¤ºå†™é”å·²ç»å®Œå…¨é‡Šæ”¾äº†ï¼Œä»è€Œè®©ç­‰å¾…çš„å…¶ä»–çº¿ç¨‹å¯ä»¥ç»§ç»­è®¿é—®è¯»ã€å†™é”ï¼Œè·å–åŒæ­¥çŠ¶æ€ã€‚åŒæ—¶ï¼Œæ­¤æ¬¡å†™çº¿ç¨‹çš„ä¿®æ”¹å¯¹åç»­çš„çº¿ç¨‹**å¯è§**ã€‚

## 4.7 ã€è¯»é”ã€‘tryReleaseShared

```Java
protected final boolean tryReleaseShared(int unused) {
    Thread current = Thread.currentThread();
    //å¦‚æœæƒ³è¦é‡Šæ”¾é”çš„çº¿ç¨‹ä¸ºç¬¬ä¸€ä¸ªè·å–é”çš„çº¿ç¨‹
    if (firstReader == current) {
        //ä»…è·å–äº†ä¸€æ¬¡ï¼Œåˆ™éœ€è¦å°†firstReader è®¾ç½®nullï¼Œå¦åˆ™ firstReaderHoldCount - 1
        if (firstReaderHoldCount == 1)
            firstReader = null;
        else
            firstReaderHoldCount--;
    }
    //è·å–rhå¯¹è±¡ï¼Œå¹¶æ›´æ–°â€œå½“å‰çº¿ç¨‹è·å–é”çš„ä¿¡æ¯â€
    else {
        HoldCounter rh = cachedHoldCounter;
        if (rh == null || rh.tid != getThreadId(current))
            rh = readHolds.get();
        int count = rh.count;
        if (count <= 1) {
            readHolds.remove();
            if (count <= 0)
                throw unmatchedUnlockException();
        }
        --rh.count;
    }
    //CASæ›´æ–°åŒæ­¥çŠ¶æ€
    for (;;) {
        int c = getState();
        int nextc = c - SHARED_UNIT;
        if (compareAndSetState(c, nextc))
            return nextc == 0;
    }
}
```

* `#unmatchedUnlockException()` æ–¹æ³•ï¼Œè¿”å› IllegalMonitorStateException å¼‚å¸¸ã€‚ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    private IllegalMonitorStateException unmatchedUnlockException() {
        return new IllegalMonitorStateException(
            "attempt to unlock read lock, not locked by current thread");
    }
    ```
    * å‡ºç°çš„æƒ…å†µæ˜¯ï¼Œunlock è¯»é”çš„çº¿ç¨‹ï¼Œéè·å¾—è¯»é”çš„çº¿ç¨‹ã€‚æ­£å¸¸ä½¿ç”¨çš„æƒ…å†µï¼Œä¸ä¼šå‡ºç°è¯¥æƒ…å†µã€‚

## 4.8 tryWriteLock

`#tryWriteLock()` æ–¹æ³•ï¼Œå°è¯•è·å–è¯»é”ã€‚

* è‹¥è·å–æˆåŠŸï¼Œè¿”å› true ã€‚
* è‹¥å¤±è´¥ï¼Œè¿”å› false å³å¯ï¼Œ**ä¸è¿›è¡Œç­‰å¾…æ’é˜Ÿ**ã€‚

ä»£ç å¦‚ä¸‹ï¼š

```Java
final boolean tryWriteLock(){
    Thread current = Thread.currentThread();
    int c = getState();
    if(c != 0){
        int w = exclusiveCount(c); // è·å¾—ç°åœ¨å†™é”è·å–çš„æ•°é‡
        if(w == 0 || current != getExclusiveOwnerThread()){  // åˆ¤æ–­æ˜¯å¦æ˜¯å…¶ä»–çš„çº¿ç¨‹è·å–äº†å†™é”ã€‚è‹¥æ˜¯ï¼Œè¿”å› false
            return false;
        }
        if(w == MAX_COUNT){ // è¶…è¿‡å†™é”ä¸Šé™ï¼ŒæŠ›å‡º Error é”™è¯¯
            throw new Error("Maximum lock count exceeded");
        }
    }

    if(!compareAndSetState(c, c + 1)){ //  CAS è®¾ç½®åŒæ­¥çŠ¶æ€ï¼Œå°è¯•è·å–å†™é”ã€‚è‹¥å¤±è´¥ï¼Œè¿”å› false
        return false;
    }
    setExclusiveOwnerThread(current); // è®¾ç½®æŒæœ‰å†™é”ä¸ºå½“å‰çº¿ç¨‹
    return true;
}
```

## 4.9 tryReadLock

`#tryReadLock()` æ–¹æ³•ï¼Œå°è¯•è·å–å†™é”ã€‚

* è‹¥è·å–æˆåŠŸï¼Œè¿”å› true ã€‚
* è‹¥å¤±è´¥ï¼Œè¿”å› false å³å¯ï¼Œ**ä¸è¿›è¡Œç­‰å¾…æ’é˜Ÿ**ã€‚

ä»£ç å¦‚ä¸‹ï¼š

```Java
final boolean tryReadLock() {
    Thread current = Thread.currentThread();
    for (;;) {
        int c = getState();
       //exclusiveCount(c)è®¡ç®—å†™é”
        //å¦‚æœå­˜åœ¨å†™é”ï¼Œä¸”é”çš„æŒæœ‰è€…ä¸æ˜¯å½“å‰çº¿ç¨‹ï¼Œç›´æ¥è¿”å›-1
        //å­˜åœ¨é”é™çº§é—®é¢˜ï¼Œåç»­é˜è¿°
        if (exclusiveCount(c) != 0 &&
            getExclusiveOwnerThread() != current)
            return false;
        // è¯»é”
        int r = sharedCount(c);
        /*
         * HoldCount éƒ¨åˆ†åé¢è®²è§£
         */
        if (r == MAX_COUNT)
            throw new Error("Maximum lock count exceeded");
        if (compareAndSetState(c, c + SHARED_UNIT)) {
            if (r == 0) {
                firstReader = current;
                firstReaderHoldCount = 1;
            } else if (firstReader == current) {
                firstReaderHoldCount++;
            } else {
                HoldCounter rh = cachedHoldCounter;
                if (rh == null || rh.tid != getThreadId(current))
                    cachedHoldCounter = rh = readHolds.get();
                else if (rh.count == 0)
                    readHolds.set(rh);
                rh.count++;
            }
            return true;
        }
    }
}
```

## 4.10 isHeldExclusively

```Java
protected final boolean isHeldExclusively() {
    // While we must in general read state before owner,
    // we don't need to do so to check if current thread is owner
    return getExclusiveOwnerThread() == Thread.currentThread();
}
```

## 4.11 newCondition

```Java
final ConditionObject newCondition() {
    return new ConditionObject();
}
```

## 4.12 å…¶ä»–å®ç°æ–¹æ³•

å…¶å®ƒå®ç°æ–¹æ³•ï¼Œæ¯”è¾ƒç®€å•ï¼Œèƒ–å‹è‡ªå·±æŸ¥çœ‹ã€‚

```Java
final Thread getOwner() {
    // Must read state before owner to ensure memory consistency
    return ((exclusiveCount(getState()) == 0) ?
            null :
            getExclusiveOwnerThread());
}

final int getReadLockCount() {
    return sharedCount(getState());
}

final boolean isWriteLocked() {
    return exclusiveCount(getState()) != 0;
}

final int getWriteHoldCount() {
    return isHeldExclusively() ? exclusiveCount(getState()) : 0;
}

final int getReadHoldCount() {
    if (getReadLockCount() == 0)
        return 0;

    Thread current = Thread.currentThread();
    if (firstReader == current)
        return firstReaderHoldCount;

    HoldCounter rh = cachedHoldCounter;
    if (rh != null && rh.tid == getThreadId(current))
        return rh.count;

    int count = readHolds.get().count;
    if (count == 0) readHolds.remove();
    return count;
}

/**
 * Reconstitutes the instance from a stream (that is, deserializes it).
 */
private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException {
    s.defaultReadObject();
    readHolds = new ThreadLocalHoldCounter();
    setState(0); // reset to unlocked state
}

final int getCount() { return getState(); }
```

# 5. Sync å®ç°ç±»

## 5.1 NonfairSync

NonfairSync æ˜¯ ReentrantReadWriteLock çš„å†…éƒ¨é™æ€ç±»ï¼Œå®ç° Sync æŠ½è±¡ç±»ï¼Œ**é**å…¬å¹³é”å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```Java
static final class NonfairSync extends Sync {

    @Override
    final boolean writerShouldBlock() {
        return false; // writers can always barge
    }
    
    @Override
    final boolean readerShouldBlock() {
        /* As a heuristic to avoid indefinite writer starvation,
         * block if the thread that momentarily appears to be head
         * of queue, if one exists, is a waiting writer.  This is
         * only a probabilistic effect since a new reader will not
         * block if there is a waiting writer behind other enabled
         * readers that have not yet drained from the queue.
         */
        return apparentlyFirstQueuedIsExclusive();
    }
    
}
```

* å› ä¸ºå†™é”æ˜¯**ç‹¬å æ’å®ƒ**é”ï¼Œæ‰€ä»¥åœ¨éå…¬å¹³é”çš„æƒ…å†µä¸‹ï¼Œéœ€è¦è°ƒç”¨ AQS çš„ `#apparentlyFirstQueuedIsExclusive()` æ–¹æ³•ï¼Œ**åˆ¤æ–­æ˜¯å¦å½“å‰å†™é”å·²ç»è¢«è·å–**ã€‚ä»£ç å¦‚ä¸‹ï¼š

    ```Java
    final boolean apparentlyFirstQueuedIsExclusive() {
        Node h, s;
        return (h = head) != null &&
            (s = h.next)  != null &&
            !s.isShared()         && // éå…±äº«ï¼Œå³ç‹¬å 
            s.thread != null;
    }
    ```

## 5.2 FairSync

FairSync æ˜¯ ReentrantReadWriteLock çš„å†…éƒ¨é™æ€ç±»ï¼Œå®ç° Sync æŠ½è±¡ç±»ï¼Œå…¬å¹³é”å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```Java
static final class FairSync extends Sync {

    @Override
    final boolean writerShouldBlock() {
        return hasQueuedPredecessors();
    }
    
    @Override
    final boolean readerShouldBlock() {
        return hasQueuedPredecessors();
    }
    
}
```

* è°ƒç”¨ AQS çš„ `#hasQueuedPredecessors()` æ–¹æ³•ï¼Œæ˜¯å¦æœ‰**å‰åº**èŠ‚ç‚¹ï¼Œå³è‡ªå·±ä¸æ˜¯é¦–ä¸ª**ç­‰å¾…**è·å–åŒæ­¥çŠ¶æ€çš„èŠ‚ç‚¹ã€‚

# 6. HoldCounter

åœ¨è¯»é”è·å–é”å’Œé‡Šæ”¾é”çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬ä¸€ç›´éƒ½å¯ä»¥çœ‹åˆ°ä¸€ä¸ªå˜é‡ `rh` ï¼ˆHoldCounter ï¼‰ï¼Œè¯¥å˜é‡åœ¨è¯»é”ä¸­æ‰®æ¼”ç€éå¸¸é‡è¦çš„ä½œç”¨ã€‚

æˆ‘ä»¬äº†è§£**è¯»é”çš„å†…åœ¨æœºåˆ¶å…¶å®å°±æ˜¯ä¸€ä¸ªå…±äº«é”**ï¼Œä¸ºäº†æ›´å¥½ç†è§£ HoldCounter ï¼Œæˆ‘ä»¬æš‚ä¸”è®¤ä¸ºå®ƒä¸æ˜¯ä¸€ä¸ªé”çš„æ¦‚ç‡ï¼Œè€Œç›¸å½“äºä¸€ä¸ª**è®¡æ•°å™¨**ã€‚ä¸€æ¬¡å…±äº«é”çš„æ“ä½œå°±ç›¸å½“äºåœ¨è¯¥è®¡æ•°å™¨çš„æ“ä½œã€‚è·å–å…±äº«é”ï¼Œåˆ™è¯¥è®¡æ•°å™¨ + 1ï¼Œé‡Šæ”¾å…±äº«é”ï¼Œè¯¥è®¡æ•°å™¨ - 1ã€‚åªæœ‰å½“çº¿ç¨‹è·å–å…±äº«é”åæ‰èƒ½å¯¹å…±äº«é”è¿›è¡Œé‡Šæ”¾ã€é‡å…¥æ“ä½œã€‚**æ‰€ä»¥ HoldCounter çš„ä½œç”¨å°±æ˜¯å½“å‰çº¿ç¨‹æŒæœ‰å…±äº«é”çš„æ•°é‡ï¼Œè¿™ä¸ªæ•°é‡å¿…é¡»è¦ä¸çº¿ç¨‹ç»‘å®šåœ¨ä¸€èµ·ï¼Œå¦åˆ™æ“ä½œå…¶ä»–çº¿ç¨‹é”å°±ä¼šæŠ›å‡ºå¼‚å¸¸**ã€‚

æˆ‘ä»¬å…ˆçœ‹ HoldCounter çš„ä»£ç ï¼š

> HoldCounter æ˜¯ Sync çš„å†…éƒ¨é™æ€ç±»ã€‚

```Java
static final class HoldCounter {
    int count = 0; // è®¡æ•°å™¨
    final long tid = getThreadId(Thread.currentThread()); // çº¿ç¨‹ç¼–å·
}
```

* HoldCounter å®šä¹‰éå¸¸ç®€å•ï¼Œå°±æ˜¯ä¸€ä¸ªè®¡æ•°å™¨ `count `å’Œçº¿ç¨‹ç¼–å· `tid` ä¸¤ä¸ªå˜é‡ã€‚æŒ‰ç…§è¿™ä¸ªæ„æ€æˆ‘ä»¬çœ‹åˆ° HoldCounter æ˜¯éœ€è¦å’ŒæŸç»™çº¿ç¨‹è¿›è¡Œç»‘å®šäº†ã€‚æˆ‘ä»¬çŸ¥é“å¦‚æœè¦å°†ä¸€ä¸ªå¯¹è±¡å’Œçº¿ç¨‹ç»‘å®šä»…ä»…æœ‰ `tid` æ˜¯ä¸å¤Ÿçš„ï¼Œè€Œä¸”ä»ä¸Šé¢çš„ä»£ç æˆ‘ä»¬å¯ä»¥çœ‹åˆ° HoldCounter ä»…ä»…åªæ˜¯è®°å½•äº† `tid` ï¼Œæ ¹æœ¬èµ·ä¸åˆ°ç»‘å®šçº¿ç¨‹çš„ä½œç”¨ã€‚é‚£ä¹ˆæ€ä¹ˆå®ç°å‘¢ï¼Ÿç­”æ¡ˆæ˜¯å®ç° ThreadLocal çš„  ThreadLocalHoldCounter ç±»ï¼Œä»£ç å¦‚ä¸‹ï¼š

    > ThreadLocalHoldCounter æ˜¯ Sync çš„å†…éƒ¨é™æ€ç±»ã€‚

    ```Java
    static final class ThreadLocalHoldCounter extends ThreadLocal<HoldCounter> {
        
        @Override
        public HoldCounter initialValue() {
            return new HoldCounter();
        }
        
    }
    ```

é€šè¿‡ ThreadLocalHoldCounter ç±»ï¼ŒHoldCounter å°±å¯ä»¥ä¸çº¿ç¨‹è¿›è¡Œç»‘å®šäº†ã€‚æ•…è€Œï¼ŒHoldCounter åº”è¯¥å°±æ˜¯ç»‘å®šçº¿ç¨‹ä¸Šçš„ä¸€ä¸ªè®¡æ•°å™¨ï¼Œè€Œ ThreadLocalHoldCounter åˆ™æ˜¯çº¿ç¨‹ç»‘å®šçš„ ThreadLocalã€‚ä»ä¸Šé¢æˆ‘ä»¬å¯ä»¥çœ‹åˆ° ThreadLocal å°† HoldCounter ç»‘å®šåˆ°å½“å‰çº¿ç¨‹ä¸Šï¼ŒåŒæ—¶ HoldCounter ä¹ŸæŒæœ‰çº¿ç¨‹ç¼–å·ï¼Œè¿™æ ·åœ¨é‡Šæ”¾é”çš„æ—¶å€™æ‰èƒ½çŸ¥é“ ReadWriteLock é‡Œé¢ç¼“å­˜çš„ä¸Šä¸€ä¸ªè¯»å–çº¿ç¨‹ï¼ˆ`cachedHoldCounter`ï¼‰æ˜¯å¦æ˜¯å½“å‰çº¿ç¨‹ã€‚è¿™æ ·åšçš„å¥½å¤„æ˜¯å¯ä»¥å‡å°‘`ThreadLocal.get()` æ–¹æ³•çš„æ¬¡è°ƒç”¨æ•°ï¼Œå› ä¸ºè¿™ä¹Ÿæ˜¯ä¸€ä¸ªè€—æ—¶æ“ä½œã€‚éœ€è¦è¯´æ˜çš„æ˜¯è¿™æ ·HoldCounter ç»‘å®šçº¿ç¨‹ç¼–å·è€Œä¸ç»‘å®šçº¿ç¨‹å¯¹è±¡çš„åŸå› æ˜¯ï¼Œé¿å… HoldCounter å’Œ ThreadLocal äº’ç›¸ç»‘å®šè€Œå¯¼è‡´ GC éš¾ä»¥é‡Šæ”¾å®ƒä»¬ï¼ˆå°½ç®¡ GC èƒ½å¤Ÿæ™ºèƒ½çš„å‘ç°è¿™ç§å¼•ç”¨è€Œå›æ”¶å®ƒä»¬ï¼Œä½†æ˜¯è¿™éœ€è¦ä¸€å®šçš„ä»£ä»·ï¼‰ï¼Œæ‰€ä»¥å…¶å®è¿™æ ·åšåªæ˜¯ä¸ºäº†å¸®åŠ© GC å¿«é€Ÿå›æ”¶å¯¹è±¡è€Œå·²ã€‚

çœ‹åˆ°è¿™é‡Œæˆ‘ä»¬æ˜ç™½äº† HoldCounter ä½œç”¨äº†ï¼Œæˆ‘ä»¬åœ¨çœ‹ä¸€ä¸ª**è·å–è¯»é”**çš„ä»£ç æ®µï¼š

```Java
//å¦‚æœè·å–è¯»é”çš„çº¿ç¨‹ä¸ºç¬¬ä¸€æ¬¡è·å–è¯»é”çš„çº¿ç¨‹ï¼Œåˆ™firstReaderHoldCounté‡å…¥æ•° + 1
else if (firstReader == current) {
    firstReaderHoldCount++;
} else {
    //éfirstReaderè®¡æ•°
    if (rh == null)
        rh = cachedHoldCounter;
    //rh == null æˆ–è€… rh.tid != current.getId()ï¼Œéœ€è¦è·å–rh
    if (rh == null || rh.tid != getThreadId(current))
        rh = readHolds.get();
        //åŠ å…¥åˆ°readHoldsä¸­
    else if (rh.count == 0)
        readHolds.set(rh);
    //è®¡æ•°+1
    rh.count++;
    cachedHoldCounter = rh; // cache for release
}
```

* è¿™é‡Œè§£é‡Šä¸‹ä¸ºä½•è¦å¼•å…¥ `firstReader`ã€`firstReaderHoldCount` å˜é‡ã€‚è¿™æ˜¯ä¸ºäº†ä¸€ä¸ªæ•ˆç‡é—®é¢˜ï¼Œ`firstReader` æ˜¯ä¸ä¼šæ”¾å…¥åˆ° `readHolds` ä¸­çš„ï¼Œå¦‚æœè¯»é”ä»…æœ‰ä¸€ä¸ªçš„æƒ…å†µä¸‹ï¼Œå°±ä¼šé¿å…æŸ¥æ‰¾ `readHolds` ã€‚

# 7. é”é™çº§

åœ¨æœ¬æ–‡å¼€ç¯‡ï¼ŒLZ å°±é˜è¿°äº†è¯»å†™é”æœ‰ä¸€ä¸ªç‰¹æ€§å°±æ˜¯**é”é™çº§**ã€‚é”é™çº§å°±æ„å‘³ç€å†™é”æ˜¯å¯ä»¥é™çº§ä¸ºè¯»é”çš„ï¼Œä½†æ˜¯éœ€è¦éµå¾ªå…ˆè·å–å†™é”ã€è·å–è¯»é”åœ¨é‡Šæ”¾å†™é”çš„æ¬¡åºã€‚æ³¨æ„å¦‚æœå½“å‰çº¿ç¨‹å…ˆè·å–å†™é”ï¼Œç„¶åé‡Šæ”¾å†™é”ï¼Œå†è·å–è¯»é”è¿™ä¸ªè¿‡ç¨‹ä¸èƒ½ç§°ä¹‹ä¸ºé”é™çº§ï¼Œé”é™çº§ä¸€å®šè¦éµå¾ªé‚£ä¸ªæ¬¡åºã€‚

åœ¨è·å–è¯»é”çš„æ–¹æ³• `#tryAcquireShared(int unused)` ä¸­ï¼Œæœ‰ä¸€æ®µä»£ç å°±æ˜¯æ¥åˆ¤è¯»é”é™çº§çš„ï¼š

```Java
int c = getState();
//exclusiveCount(c)è®¡ç®—å†™é”
//å¦‚æœå­˜åœ¨å†™é”ï¼Œä¸”é”çš„æŒæœ‰è€…ä¸æ˜¯å½“å‰çº¿ç¨‹ï¼Œç›´æ¥è¿”å›-1
//å­˜åœ¨é”é™çº§é—®é¢˜ï¼Œåç»­é˜è¿°
if (exclusiveCount(c) != 0 &&
        getExclusiveOwnerThread() != current)
    return -1;
//è¯»é”
int r = sharedCount(c);
```

é”é™çº§ä¸­è¯»é”çš„è·å–é‡Šæ”¾ä¸ºå¿…è¦ï¼Ÿè‚¯å®šæ˜¯å¿…è¦çš„ã€‚è¯•æƒ³ï¼Œå‡å¦‚å½“å‰çº¿ç¨‹ A ä¸è·å–è¯»é”è€Œæ˜¯ç›´æ¥é‡Šæ”¾äº†å†™é”ï¼Œè¿™ä¸ªæ—¶å€™å¦å¤–ä¸€ä¸ªçº¿ç¨‹ B è·å–äº†å†™é”ï¼Œé‚£ä¹ˆè¿™ä¸ªçº¿ç¨‹ B å¯¹æ•°æ®çš„ä¿®æ”¹æ˜¯ä¸ä¼šå¯¹å½“å‰çº¿ç¨‹ A å¯è§çš„ã€‚å¦‚æœè·å–äº†è¯»é”ï¼Œåˆ™çº¿ç¨‹Båœ¨è·å–å†™é”è¿‡ç¨‹ä¸­åˆ¤æ–­å¦‚æœæœ‰è¯»é”è¿˜æ²¡æœ‰é‡Šæ”¾åˆ™ä¼šè¢«é˜»å¡ï¼Œåªæœ‰å½“å‰çº¿ç¨‹ A é‡Šæ”¾è¯»é”åï¼Œçº¿ç¨‹ B æ‰ä¼šè·å–å†™é”æˆåŠŸã€‚

# å‚è€ƒèµ„æ–™

1. Doug Leaï¼šã€ŠJavaå¹¶å‘ç¼–ç¨‹å®æˆ˜ã€‹
2. æ–¹è…¾é£ï¼šã€ŠJavaå¹¶å‘ç¼–ç¨‹çš„è‰ºæœ¯ã€‹çš„ [ã€Œ5.4 è¯»å†™é”ã€](#) ç« èŠ‚
3. [ã€ŠJavaå¤šçº¿ç¨‹ï¼ˆåï¼‰ä¹‹ ReentrantReadWriteLock æ·±å…¥åˆ†æã€‹](https://my.oschina.net/adan1/blog/158107)

# 666. å½©è›‹

å¦‚æœä½ å¯¹ Java å¹¶å‘æ„Ÿå…´è¶£ï¼Œæ¬¢è¿åŠ å…¥æˆ‘çš„çŸ¥è¯†æ˜Ÿçƒä¸€èµ·äº¤æµã€‚

![çŸ¥è¯†æ˜Ÿçƒ](http://www.iocoder.cn/images/Architecture/2017_12_29/01.png)

