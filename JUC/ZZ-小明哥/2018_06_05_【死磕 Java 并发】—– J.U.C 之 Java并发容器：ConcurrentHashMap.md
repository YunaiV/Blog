title: ã€æ­»ç£• Java å¹¶å‘ã€‘â€”â€“ J.U.C ä¹‹ Javaå¹¶å‘å®¹å™¨ï¼šConcurrentHashMap
date: 2018-06-05
tag: 
categories: JUC
permalink: JUC/sike/ConcurrentHashMap
author: å°æ˜å“¥
from_url: http://cmsblogs.com/?p=2283
wechat_url: https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247485453&idx=2&sn=66b1b55ea67731720cfd74875d01c48c&chksm=fa4977bccd3efeaaba0fffe62c192328bb9cfad887d7025a52ed77c1cac85f7f56217026eddb&token=982309024&lang=zh_CN#rd

-------

æ‘˜è¦: åŸåˆ›å‡ºå¤„ http://cmsblogs.com/?p=2283 ã€Œå°æ˜å“¥ã€æ¬¢è¿è½¬è½½ï¼Œä¿ç•™æ‘˜è¦ï¼Œè°¢è°¢ï¼

- [ConcurrentHashMapçš„å®ç°](http://www.iocoder.cn/JUC/sike/ConcurrentHashMap/)
  - [é‡è¦æ¦‚å¿µ](http://www.iocoder.cn/JUC/sike/ConcurrentHashMap/)
  - [é‡è¦å†…éƒ¨ç±»](http://www.iocoder.cn/JUC/sike/ConcurrentHashMap/)
  - [æ„é€ å‡½æ•°](http://www.iocoder.cn/JUC/sike/ConcurrentHashMap/)
  - [åˆå§‹åŒ–ï¼š initTable()](http://www.iocoder.cn/JUC/sike/ConcurrentHashMap/)
  - [putæ“ä½œ](http://www.iocoder.cn/JUC/sike/ConcurrentHashMap/)
  - [getæ“ä½œ](http://www.iocoder.cn/JUC/sike/ConcurrentHashMap/)
  - [æ‰©å®¹æ“ä½œ](http://www.iocoder.cn/JUC/sike/ConcurrentHashMap/)
  - [è½¬æ¢çº¢é»‘æ ‘](http://www.iocoder.cn/JUC/sike/ConcurrentHashMap/)

-------

![](http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg)

> ğŸ™‚ğŸ™‚ğŸ™‚å…³æ³¨**å¾®ä¿¡å…¬ä¼—å·ï¼šã€èŠ‹é“æºç ã€‘**æœ‰ç¦åˆ©ï¼š
> 1. RocketMQ / MyCAT / Sharding-JDBC **æ‰€æœ‰**æºç åˆ†ææ–‡ç« åˆ—è¡¨
> 2. RocketMQ / MyCAT / Sharding-JDBC **ä¸­æ–‡æ³¨é‡Šæºç  GitHub åœ°å€**
> 3. æ‚¨å¯¹äºæºç çš„ç–‘é—®æ¯æ¡ç•™è¨€**éƒ½**å°†å¾—åˆ°**è®¤çœŸ**å›å¤ã€‚**ç”šè‡³ä¸çŸ¥é“å¦‚ä½•è¯»æºç ä¹Ÿå¯ä»¥è¯·æ•™å™¢**ã€‚
> 4. **æ–°çš„**æºç è§£ææ–‡ç« **å®æ—¶**æ”¶åˆ°é€šçŸ¥ã€‚**æ¯å‘¨æ›´æ–°ä¸€ç¯‡å·¦å³**ã€‚
> 5. **è®¤çœŸçš„**æºç äº¤æµå¾®ä¿¡ç¾¤ã€‚

-------

> æ­¤ç¯‡åšå®¢æ‰€æœ‰æºç å‡æ¥è‡ªJDK 1.8

HashMapæ˜¯æˆ‘ä»¬ç”¨å¾—éå¸¸é¢‘ç¹çš„ä¸€ä¸ªé›†åˆï¼Œä½†æ˜¯ç”±äºå®ƒæ˜¯éçº¿ç¨‹å®‰å…¨çš„ï¼Œåœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ï¼Œputæ“ä½œæ˜¯æœ‰å¯èƒ½äº§ç”Ÿæ­»å¾ªç¯çš„ï¼Œå¯¼è‡´CPUåˆ©ç”¨ç‡æ¥è¿‘100%ã€‚ä¸ºäº†è§£å†³è¯¥é—®é¢˜ï¼Œæä¾›äº†Hashtableå’ŒCollections.synchronizedMap(hashMap)ä¸¤ç§è§£å†³æ–¹æ¡ˆï¼Œä½†æ˜¯è¿™ä¸¤ç§æ–¹æ¡ˆéƒ½æ˜¯å¯¹è¯»å†™åŠ é”ï¼Œç‹¬å å¼ï¼Œä¸€ä¸ªçº¿ç¨‹åœ¨è¯»æ—¶å…¶ä»–çº¿ç¨‹å¿…é¡»ç­‰å¾…ï¼Œååé‡è¾ƒä½ï¼Œæ€§èƒ½è¾ƒä¸ºä½ä¸‹ã€‚æ•…è€ŒDoug Leaå¤§ç¥ç»™æˆ‘ä»¬æä¾›äº†é«˜æ€§èƒ½çš„çº¿ç¨‹å®‰å…¨HashMapï¼šConcurrentHashMapã€‚

# ConcurrentHashMapçš„å®ç°

ConcurrentHashMapä½œä¸ºConcurrentä¸€æ—ï¼Œå…¶æœ‰ç€é«˜æ•ˆåœ°å¹¶å‘æ“ä½œï¼Œç›¸æ¯”Hashtableçš„ç¬¨é‡ï¼ŒConcurrentHashMapåˆ™æ›´èƒœä¸€ç­¹äº†ã€‚

åœ¨1.8ç‰ˆæœ¬ä»¥å‰ï¼ŒConcurrentHashMapé‡‡ç”¨åˆ†æ®µé”çš„æ¦‚å¿µï¼Œä½¿é”æ›´åŠ ç»†åŒ–ï¼Œä½†æ˜¯1.8å·²ç»æ”¹å˜äº†è¿™ç§æ€è·¯ï¼Œè€Œæ˜¯åˆ©ç”¨CAS+Synchronizedæ¥ä¿è¯å¹¶å‘æ›´æ–°çš„å®‰å…¨ï¼Œå½“ç„¶åº•å±‚é‡‡ç”¨æ•°ç»„+é“¾è¡¨+çº¢é»‘æ ‘çš„å­˜å‚¨ç»“æ„ã€‚

å…³äº1.7å’Œ1.8çš„åŒºåˆ«è¯·å‚è€ƒå å°ç‹¼åšå®¢ï¼šè°ˆè°ˆConcurrentHashMap1.7å’Œ1.8çš„ä¸åŒå®ç°:<http://www.jianshu.com/p/e694f1e868ec>

æˆ‘ä»¬ä»å¦‚ä¸‹å‡ ä¸ªéƒ¨åˆ†å…¨é¢äº†è§£ConcurrentHashMapåœ¨1.8ä¸­æ˜¯å¦‚ä½•å®ç°çš„ï¼š

1. é‡è¦æ¦‚å¿µ
2. é‡è¦å†…éƒ¨ç±»
3. ConcurrentHashMapçš„åˆå§‹åŒ–
4. putæ“ä½œ
5. getæ“ä½œ
6. sizeæ“ä½œ
7. æ‰©å®¹
8. çº¢é»‘æ ‘è½¬æ¢

## é‡è¦æ¦‚å¿µ

ConcurrentHashMapå®šä¹‰äº†å¦‚ä¸‹å‡ ä¸ªå¸¸é‡ï¼š

```Java
// æœ€å¤§å®¹é‡ï¼š2^30=1073741824
private static final int MAXIMUM_CAPACITY = 1 << 30;

// é»˜è®¤åˆå§‹å€¼ï¼Œå¿…é¡»æ˜¯2çš„å¹•æ•°
private static final int DEFAULT_CAPACITY = 16;

//
static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

//
private static final int DEFAULT_CONCURRENCY_LEVEL = 16;

//
private static final float LOAD_FACTOR = 0.75f;

// é“¾è¡¨è½¬çº¢é»‘æ ‘é˜€å€¼,> 8 é“¾è¡¨è½¬æ¢ä¸ºçº¢é»‘æ ‘
static final int TREEIFY_THRESHOLD = 8;

//æ ‘è½¬é“¾è¡¨é˜€å€¼ï¼Œå°äºç­‰äº6ï¼ˆtranferæ—¶ï¼Œlcã€hc=0ä¸¤ä¸ªè®¡æ•°å™¨åˆ†åˆ«++è®°å½•åŸbinã€æ–°binTreeNodeæ•°é‡ï¼Œ<=UNTREEIFY_THRESHOLD åˆ™untreeify(lo)ï¼‰
static final int UNTREEIFY_THRESHOLD = 6;

//
static final int MIN_TREEIFY_CAPACITY = 64;

//
private static final int MIN_TRANSFER_STRIDE = 16;

//
private static int RESIZE_STAMP_BITS = 16;

// 2^15-1ï¼Œhelp resizeçš„æœ€å¤§çº¿ç¨‹æ•°
private static final int MAX_RESIZERS = (1 << (32 - RESIZE_STAMP_BITS)) - 1;

// 32-16=16ï¼ŒsizeCtlä¸­è®°å½•sizeå¤§å°çš„åç§»é‡
private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;

// forwarding nodesçš„hashå€¼
static final int MOVED     = -1;

// æ ‘æ ¹èŠ‚ç‚¹çš„hashå€¼
static final int TREEBIN   = -2;

// ReservationNodeçš„hashå€¼
static final int RESERVED  = -3;

// å¯ç”¨å¤„ç†å™¨æ•°é‡
static final int NCPU = Runtime.getRuntime().availableProcessors();
```

ä¸Šé¢æ˜¯ConcurrentHashMapå®šä¹‰çš„å¸¸é‡ï¼Œç®€å•æ˜“æ‡‚ï¼Œå°±ä¸å¤šé˜è¿°äº†ã€‚ä¸‹é¢ä»‹ç»ConcurrentHashMapå‡ ä¸ªå¾ˆé‡è¦çš„æ¦‚å¿µã€‚

1. **table**ï¼šç”¨æ¥å­˜æ”¾NodeèŠ‚ç‚¹æ•°æ®çš„ï¼Œé»˜è®¤ä¸ºnullï¼Œé»˜è®¤å¤§å°ä¸º16çš„æ•°ç»„ï¼Œæ¯æ¬¡æ‰©å®¹æ—¶å¤§å°æ€»æ˜¯2çš„å¹‚æ¬¡æ–¹ï¼›

2. **nextTable**ï¼šæ‰©å®¹æ—¶æ–°ç”Ÿæˆçš„æ•°æ®ï¼Œæ•°ç»„ä¸ºtableçš„ä¸¤å€ï¼›

3. **Node**ï¼šèŠ‚ç‚¹ï¼Œä¿å­˜key-valueçš„æ•°æ®ç»“æ„ï¼›

4. **ForwardingNode**ï¼šä¸€ä¸ªç‰¹æ®Šçš„NodeèŠ‚ç‚¹ï¼Œhashå€¼ä¸º-1ï¼Œå…¶ä¸­å­˜å‚¨nextTableçš„å¼•ç”¨ã€‚åªæœ‰tableå‘ç”Ÿæ‰©å®¹çš„æ—¶å€™ï¼ŒForwardingNodeæ‰ä¼šå‘æŒ¥ä½œç”¨ï¼Œä½œä¸ºä¸€ä¸ªå ä½ç¬¦æ”¾åœ¨tableä¸­è¡¨ç¤ºå½“å‰èŠ‚ç‚¹ä¸ºnullæˆ–åˆ™å·²ç»è¢«ç§»åŠ¨

5. sizeCtl

   ï¼šæ§åˆ¶æ ‡è¯†ç¬¦ï¼Œç”¨æ¥æ§åˆ¶tableåˆå§‹åŒ–å’Œæ‰©å®¹æ“ä½œçš„ï¼Œåœ¨ä¸åŒçš„åœ°æ–¹æœ‰ä¸åŒçš„ç”¨é€”ï¼Œå…¶å€¼ä¹Ÿä¸åŒï¼Œæ‰€ä»£è¡¨çš„å«ä¹‰ä¹Ÿä¸åŒ

   - è´Ÿæ•°ä»£è¡¨æ­£åœ¨è¿›è¡Œåˆå§‹åŒ–æˆ–æ‰©å®¹æ“ä½œ
   - -1ä»£è¡¨æ­£åœ¨åˆå§‹åŒ–
   - -N è¡¨ç¤ºæœ‰N-1ä¸ªçº¿ç¨‹æ­£åœ¨è¿›è¡Œæ‰©å®¹æ“ä½œ
   - æ­£æ•°æˆ–0ä»£è¡¨hashè¡¨è¿˜æ²¡æœ‰è¢«åˆå§‹åŒ–ï¼Œè¿™ä¸ªæ•°å€¼è¡¨ç¤ºåˆå§‹åŒ–æˆ–ä¸‹ä¸€æ¬¡è¿›è¡Œæ‰©å®¹çš„å¤§å°

## é‡è¦å†…éƒ¨ç±»

ä¸ºäº†å®ç°ConcurrentHashMapï¼ŒDoug Leaæä¾›äº†è®¸å¤šå†…éƒ¨ç±»æ¥è¿›è¡Œè¾…åŠ©å®ç°ï¼Œå¦‚Nodeï¼ŒTreeNode,TreeBinç­‰ç­‰ã€‚ä¸‹é¢æˆ‘ä»¬å°±ä¸€èµ·æ¥çœ‹çœ‹ConcurrentHashMapå‡ ä¸ªé‡è¦çš„å†…éƒ¨ç±»ã€‚

### Node

ä½œä¸ºConcurrentHashMapä¸­æœ€æ ¸å¿ƒã€æœ€é‡è¦çš„å†…éƒ¨ç±»ï¼ŒNodeæ‹…è´Ÿç€é‡è¦è§’è‰²ï¼škey-valueé”®å€¼å¯¹ã€‚æ‰€æœ‰æ’å…¥ConCurrentHashMapçš„ä¸­æ•°æ®éƒ½å°†ä¼šåŒ…è£…åœ¨Nodeä¸­ã€‚å®šä¹‰å¦‚ä¸‹ï¼š

```Java
    static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        volatile V val;             //å¸¦æœ‰volatileï¼Œä¿è¯å¯è§æ€§
        volatile Node<K,V> next;    //ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ

        Node(int hash, K key, V val, Node<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.val = val;
            this.next = next;
        }

        public final K getKey()       { return key; }
        public final V getValue()     { return val; }
        public final int hashCode()   { return key.hashCode() ^ val.hashCode(); }
        public final String toString(){ return key + "=" + val; }
        /** ä¸å…è®¸ä¿®æ”¹valueçš„å€¼ */
        public final V setValue(V value) {
            throw new UnsupportedOperationException();
        }

        public final boolean equals(Object o) {
            Object k, v, u; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    (k == key || k.equals(key)) &&
                    (v == (u = val) || v.equals(u)));
        }

        /**  èµ‹å€¼get()æ–¹æ³• */
        Node<K,V> find(int h, Object k) {
            Node<K,V> e = this;
            if (k != null) {
                do {
                    K ek;
                    if (e.hash == h &&
                            ((ek = e.key) == k || (ek != null && k.equals(ek))))
                        return e;
                } while ((e = e.next) != null);
            }
            return null;
        }
    }
```

åœ¨Nodeå†…éƒ¨ç±»ä¸­ï¼Œå…¶å±æ€§valueã€nextéƒ½æ˜¯å¸¦æœ‰volatileçš„ã€‚åŒæ—¶å…¶å¯¹valueçš„setteræ–¹æ³•è¿›è¡Œäº†ç‰¹æ®Šå¤„ç†ï¼Œä¸å…è®¸ç›´æ¥è°ƒç”¨å…¶setteræ–¹æ³•æ¥ä¿®æ”¹valueçš„å€¼ã€‚æœ€åNodeè¿˜æä¾›äº†findæ–¹æ³•æ¥èµ‹å€¼map.get()ã€‚

### TreeNode

æˆ‘ä»¬åœ¨å­¦ä¹ HashMapçš„æ—¶å€™å°±çŸ¥é“ï¼ŒHashMapçš„æ ¸å¿ƒæ•°æ®ç»“æ„å°±æ˜¯é“¾è¡¨ã€‚åœ¨ConcurrentHashMapä¸­å°±ä¸ä¸€æ ·äº†ï¼Œå¦‚æœé“¾è¡¨çš„æ•°æ®è¿‡é•¿æ˜¯ä¼šè½¬æ¢ä¸ºçº¢é»‘æ ‘æ¥å¤„ç†ã€‚å½“å®ƒå¹¶ä¸æ˜¯ç›´æ¥è½¬æ¢ï¼Œè€Œæ˜¯å°†è¿™äº›é“¾è¡¨çš„èŠ‚ç‚¹åŒ…è£…æˆTreeNodeæ”¾åœ¨TreeBinå¯¹è±¡ä¸­ï¼Œç„¶åç”±TreeBinå®Œæˆçº¢é»‘æ ‘çš„è½¬æ¢ã€‚æ‰€ä»¥TreeNodeä¹Ÿå¿…é¡»æ˜¯ConcurrentHashMapçš„ä¸€ä¸ªæ ¸å¿ƒç±»ï¼Œå…¶ä¸ºæ ‘èŠ‚ç‚¹ç±»ï¼Œå®šä¹‰å¦‚ä¸‹ï¼š

```Java
static final class TreeNode<K,V> extends Node<K,V> {
        TreeNode<K,V> parent;  // red-black tree links
        TreeNode<K,V> left;
        TreeNode<K,V> right;
        TreeNode<K,V> prev;    // needed to unlink next upon deletion
        boolean red;

        TreeNode(int hash, K key, V val, Node<K,V> next,
                 TreeNode<K,V> parent) {
            super(hash, key, val, next);
            this.parent = parent;
        }


        Node<K,V> find(int h, Object k) {
            return findTreeNode(h, k, null);
        }

        //æŸ¥æ‰¾hashä¸ºhï¼Œkeyä¸ºkçš„èŠ‚ç‚¹
        final TreeNode<K,V> findTreeNode(int h, Object k, Class<?> kc) {
            if (k != null) {
                TreeNode<K,V> p = this;
                do  {
                    int ph, dir; K pk; TreeNode<K,V> q;
                    TreeNode<K,V> pl = p.left, pr = p.right;
                    if ((ph = p.hash) > h)
                        p = pl;
                    else if (ph < h)
                        p = pr;
                    else if ((pk = p.key) == k || (pk != null && k.equals(pk)))
                        return p;
                    else if (pl == null)
                        p = pr;
                    else if (pr == null)
                        p = pl;
                    else if ((kc != null ||
                            (kc = comparableClassFor(k)) != null) &&
                            (dir = compareComparables(kc, k, pk)) != 0)
                        p = (dir < 0) ? pl : pr;
                    else if ((q = pr.findTreeNode(h, k, kc)) != null)
                        return q;
                    else
                        p = pl;
                } while (p != null);
            }
            return null;
        }
    }
```

æºç å±•ç¤ºTreeNodeç»§æ‰¿Nodeï¼Œä¸”æä¾›äº†findTreeNodeç”¨æ¥æŸ¥æ‰¾æŸ¥æ‰¾hashä¸ºhï¼Œkeyä¸ºkçš„èŠ‚ç‚¹ã€‚

### TreeBin

è¯¥ç±»å¹¶ä¸è´Ÿè´£key-valueçš„é”®å€¼å¯¹åŒ…è£…ï¼Œå®ƒç”¨äºåœ¨é“¾è¡¨è½¬æ¢ä¸ºçº¢é»‘æ ‘æ—¶åŒ…è£…TreeNodeèŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯è¯´ConcurrentHashMapçº¢é»‘æ ‘å­˜æ”¾æ˜¯TreeBinï¼Œä¸æ˜¯TreeNodeã€‚è¯¥ç±»å°è£…äº†ä¸€ç³»åˆ—çš„æ–¹æ³•ï¼ŒåŒ…æ‹¬putTreeValã€lookRootã€UNlookRootã€removeã€balanceInsetionã€balanceDeletionã€‚ç”±äºTreeBinçš„ä»£ç å¤ªé•¿æˆ‘ä»¬è¿™é‡Œåªå±•ç¤ºæ„é€ æ–¹æ³•ï¼ˆæ„é€ æ–¹æ³•å°±æ˜¯æ„é€ çº¢é»‘æ ‘çš„è¿‡ç¨‹ï¼‰ï¼š

```Java
    static final class TreeBin<K,V> extends Node<K,V> {
        TreeNode<K, V> root;
        volatile TreeNode<K, V> first;
        volatile Thread waiter;
        volatile int lockState;
        static final int WRITER = 1; // set while holding write lock
        static final int WAITER = 2; // set when waiting for write lock
        static final int READER = 4; // increment value for setting read lock

        TreeBin(TreeNode<K, V> b) {
            super(TREEBIN, null, null, null);
            this.first = b;
            TreeNode<K, V> r = null;
            for (TreeNode<K, V> x = b, next; x != null; x = next) {
                next = (TreeNode<K, V>) x.next;
                x.left = x.right = null;
                if (r == null) {
                    x.parent = null;
                    x.red = false;
                    r = x;
                } else {
                    K k = x.key;
                    int h = x.hash;
                    Class<?> kc = null;
                    for (TreeNode<K, V> p = r; ; ) {
                        int dir, ph;
                        K pk = p.key;
                        if ((ph = p.hash) > h)
                            dir = -1;
                        else if (ph < h)
                            dir = 1;
                        else if ((kc == null &&
                                (kc = comparableClassFor(k)) == null) ||
                                (dir = compareComparables(kc, k, pk)) == 0)
                            dir = tieBreakOrder(k, pk);
                        TreeNode<K, V> xp = p;
                        if ((p = (dir <= 0) ? p.left : p.right) == null) {
                            x.parent = xp;
                            if (dir <= 0)
                                xp.left = x;
                            else
                                xp.right = x;
                            r = balanceInsertion(r, x);
                            break;
                        }
                    }
                }
            }
            this.root = r;
            assert checkInvariants(root);
        }

        /** çœç•¥å¾ˆå¤šä»£ç  */
    }
```

é€šè¿‡æ„é€ æ–¹æ³•æ˜¯ä¸æ˜¯å‘ç°äº†éƒ¨åˆ†ç«¯å€ªï¼Œæ„é€ æ–¹æ³•å°±æ˜¯åœ¨æ„é€ ä¸€ä¸ªçº¢é»‘æ ‘çš„è¿‡ç¨‹ã€‚

### ForwardingNode

è¿™æ˜¯ä¸€ä¸ªçœŸæ­£çš„è¾…åŠ©ç±»ï¼Œè¯¥ç±»ä»…ä»…åªå­˜æ´»åœ¨ConcurrentHashMapæ‰©å®¹æ“ä½œæ—¶ã€‚åªæ˜¯ä¸€ä¸ªæ ‡å¿—èŠ‚ç‚¹ï¼Œå¹¶ä¸”æŒ‡å‘nextTableï¼Œå®ƒæä¾›findæ–¹æ³•è€Œå·²ã€‚è¯¥ç±»ä¹Ÿæ˜¯é›†æˆNodeèŠ‚ç‚¹ï¼Œå…¶hashä¸º-1ï¼Œkeyã€valueã€nextå‡ä¸ºnullã€‚å¦‚ä¸‹ï¼š

```Java
 static final class ForwardingNode<K,V> extends Node<K,V> {
        final Node<K,V>[] nextTable;
        ForwardingNode(Node<K,V>[] tab) {
            super(MOVED, null, null, null);
            this.nextTable = tab;
        }

        Node<K,V> find(int h, Object k) {
            // loop to avoid arbitrarily deep recursion on forwarding nodes
            outer: for (Node<K,V>[] tab = nextTable;;) {
                Node<K,V> e; int n;
                if (k == null || tab == null || (n = tab.length) == 0 ||
                        (e = tabAt(tab, (n - 1) & h)) == null)
                    return null;
                for (;;) {
                    int eh; K ek;
                    if ((eh = e.hash) == h &&
                            ((ek = e.key) == k || (ek != null && k.equals(ek))))
                        return e;
                    if (eh < 0) {
                        if (e instanceof ForwardingNode) {
                            tab = ((ForwardingNode<K,V>)e).nextTable;
                            continue outer;
                        }
                        else
                            return e.find(h, k);
                    }
                    if ((e = e.next) == null)
                        return null;
                }
            }
        }
    }
```

## æ„é€ å‡½æ•°

ConcurrentHashMapæä¾›äº†ä¸€ç³»åˆ—çš„æ„é€ å‡½æ•°ç”¨äºåˆ›å»ºConcurrentHashMapå¯¹è±¡ï¼š

```Java
    public ConcurrentHashMap() {
    }

    public ConcurrentHashMap(int initialCapacity) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException();
        int cap = ((initialCapacity >= (MAXIMUM_CAPACITY >>> 1)) ?
                   MAXIMUM_CAPACITY :
                   tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));
        this.sizeCtl = cap;
    }

    public ConcurrentHashMap(Map<? extends K, ? extends V> m) {
        this.sizeCtl = DEFAULT_CAPACITY;
        putAll(m);
    }

    public ConcurrentHashMap(int initialCapacity, float loadFactor) {
        this(initialCapacity, loadFactor, 1);
    }

    public ConcurrentHashMap(int initialCapacity,
                             float loadFactor, int concurrencyLevel) {
        if (!(loadFactor > 0.0f) || initialCapacity < 0 || concurrencyLevel <= 0)
            throw new IllegalArgumentException();
        if (initialCapacity < concurrencyLevel)   // Use at least as many bins
            initialCapacity = concurrencyLevel;   // as estimated threads
        long size = (long)(1.0 + (long)initialCapacity / loadFactor);
        int cap = (size >= (long)MAXIMUM_CAPACITY) ?
            MAXIMUM_CAPACITY : tableSizeFor((int)size);
        this.sizeCtl = cap;
    }
```

## åˆå§‹åŒ–ï¼š initTable()

ConcurrentHashMapçš„åˆå§‹åŒ–ä¸»è¦ç”±initTable()æ–¹æ³•å®ç°ï¼Œåœ¨ä¸Šé¢çš„æ„é€ å‡½æ•°ä¸­æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œå…¶å®ConcurrentHashMapåœ¨æ„é€ å‡½æ•°ä¸­å¹¶æ²¡æœ‰åšä»€ä¹ˆäº‹ï¼Œä»…ä»…åªæ˜¯è®¾ç½®äº†ä¸€äº›å‚æ•°è€Œå·²ã€‚å…¶çœŸæ­£çš„åˆå§‹åŒ–æ˜¯å‘ç”Ÿåœ¨æ’å…¥çš„æ—¶å€™ï¼Œä¾‹å¦‚putã€mergeã€computeã€computeIfAbsentã€computeIfPresentæ“ä½œæ—¶ã€‚å…¶æ–¹æ³•å®šä¹‰å¦‚ä¸‹ï¼š

```Java
    private final Node<K,V>[] initTable() {
        Node<K,V>[] tab; int sc;
        while ((tab = table) == null || tab.length == 0) {
            //sizeCtl < 0 è¡¨ç¤ºæœ‰å…¶ä»–çº¿ç¨‹åœ¨åˆå§‹åŒ–ï¼Œè¯¥çº¿ç¨‹å¿…é¡»æŒ‚èµ·
            if ((sc = sizeCtl) < 0)
                Thread.yield();
            // å¦‚æœè¯¥çº¿ç¨‹è·å–äº†åˆå§‹åŒ–çš„æƒåˆ©ï¼Œåˆ™ç”¨CASå°†sizeCtlè®¾ç½®ä¸º-1ï¼Œè¡¨ç¤ºæœ¬çº¿ç¨‹æ­£åœ¨åˆå§‹åŒ–
            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
                    // è¿›è¡Œåˆå§‹åŒ–
                try {
                    if ((tab = table) == null || tab.length == 0) {
                        int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                        @SuppressWarnings("unchecked")
                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                        table = tab = nt;
                        // ä¸‹æ¬¡æ‰©å®¹çš„å¤§å°
                        sc = n - (n >>> 2); ///ç›¸å½“äº0.75*n è®¾ç½®ä¸€ä¸ªæ‰©å®¹çš„é˜ˆå€¼
                    }
                } finally {
                    sizeCtl = sc;
                }
                break;
            }
        }
        return tab;
    }
```

åˆå§‹åŒ–æ–¹æ³•initTable()çš„å…³é”®å°±åœ¨äºsizeCtlï¼Œè¯¥å€¼é»˜è®¤ä¸º0ï¼Œå¦‚æœåœ¨æ„é€ å‡½æ•°æ—¶æœ‰å‚æ•°ä¼ å…¥è¯¥å€¼åˆ™ä¸º2çš„å¹‚æ¬¡æ–¹ã€‚è¯¥å€¼å¦‚æœ < 0ï¼Œè¡¨ç¤ºæœ‰å…¶ä»–çº¿ç¨‹æ­£åœ¨åˆå§‹åŒ–ï¼Œåˆ™å¿…é¡»æš‚åœè¯¥çº¿ç¨‹ã€‚å¦‚æœçº¿ç¨‹è·å¾—äº†åˆå§‹åŒ–çš„æƒé™åˆ™å…ˆå°†sizeCtlè®¾ç½®ä¸º-1ï¼Œé˜²æ­¢æœ‰å…¶ä»–çº¿ç¨‹è¿›å…¥ï¼Œæœ€åå°†sizeCtlè®¾ç½®0.75 * nï¼Œè¡¨ç¤ºæ‰©å®¹çš„é˜ˆå€¼ã€‚

## putæ“ä½œ

ConcurrentHashMapæœ€å¸¸ç”¨çš„putã€getæ“ä½œï¼ŒConcurrentHashMapçš„putæ“ä½œä¸HashMapå¹¶æ²¡æœ‰å¤šå¤§åŒºåˆ«ï¼Œå…¶æ ¸å¿ƒæ€æƒ³ä¾ç„¶æ˜¯æ ¹æ®hashå€¼è®¡ç®—èŠ‚ç‚¹æ’å…¥åœ¨tableçš„ä½ç½®ï¼Œå¦‚æœè¯¥ä½ç½®ä¸ºç©ºï¼Œåˆ™ç›´æ¥æ’å…¥ï¼Œå¦åˆ™æ’å…¥åˆ°é“¾è¡¨æˆ–è€…æ ‘ä¸­ã€‚ä½†æ˜¯ConcurrentHashMapä¼šæ¶‰åŠåˆ°å¤šçº¿ç¨‹æƒ…å†µå°±ä¼šå¤æ‚å¾ˆå¤šã€‚æˆ‘ä»¬å…ˆçœ‹æºä»£ç ï¼Œç„¶åæ ¹æ®æºä»£ç ä¸€æ­¥ä¸€æ­¥åˆ†æï¼š

```Java
public V put(K key, V value) {
        return putVal(key, value, false);
    }

    final V putVal(K key, V value, boolean onlyIfAbsent) {
        //keyã€valueå‡ä¸èƒ½ä¸ºnull
        if (key == null || value == null) throw new NullPointerException();
        //è®¡ç®—hashå€¼
        int hash = spread(key.hashCode());
        int binCount = 0;
        for (Node<K,V>[] tab = table;;) {
            Node<K,V> f; int n, i, fh;
            // tableä¸ºnullï¼Œè¿›è¡Œåˆå§‹åŒ–å·¥ä½œ
            if (tab == null || (n = tab.length) == 0)
                tab = initTable();
            //å¦‚æœiä½ç½®æ²¡æœ‰èŠ‚ç‚¹ï¼Œåˆ™ç›´æ¥æ’å…¥ï¼Œä¸éœ€è¦åŠ é”
            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
                if (casTabAt(tab, i, null,
                        new Node<K,V>(hash, key, value, null)))
                    break;                   // no lock when adding to empty bin
            }
            // æœ‰çº¿ç¨‹æ­£åœ¨è¿›è¡Œæ‰©å®¹æ“ä½œï¼Œåˆ™å…ˆå¸®åŠ©æ‰©å®¹
            else if ((fh = f.hash) == MOVED)
                tab = helpTransfer(tab, f);
            else {
                V oldVal = null;
                //å¯¹è¯¥èŠ‚ç‚¹è¿›è¡ŒåŠ é”å¤„ç†ï¼ˆhashå€¼ç›¸åŒçš„é“¾è¡¨çš„å¤´èŠ‚ç‚¹ï¼‰ï¼Œå¯¹æ€§èƒ½æœ‰ç‚¹å„¿å½±å“
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        //fh > 0 è¡¨ç¤ºä¸ºé“¾è¡¨ï¼Œå°†è¯¥èŠ‚ç‚¹æ’å…¥åˆ°é“¾è¡¨å°¾éƒ¨
                        if (fh >= 0) {
                            binCount = 1;
                            for (Node<K,V> e = f;; ++binCount) {
                                K ek;
                                //hash å’Œ key éƒ½ä¸€æ ·ï¼Œæ›¿æ¢value
                                if (e.hash == hash &&
                                        ((ek = e.key) == key ||
                                                (ek != null && key.equals(ek)))) {
                                    oldVal = e.val;
                                    //putIfAbsent()
                                    if (!onlyIfAbsent)
                                        e.val = value;
                                    break;
                                }
                                Node<K,V> pred = e;
                                //é“¾è¡¨å°¾éƒ¨  ç›´æ¥æ’å…¥
                                if ((e = e.next) == null) {
                                    pred.next = new Node<K,V>(hash, key,
                                            value, null);
                                    break;
                                }
                            }
                        }
                        //æ ‘èŠ‚ç‚¹ï¼ŒæŒ‰ç…§æ ‘çš„æ’å…¥æ“ä½œè¿›è¡Œæ’å…¥
                        else if (f instanceof TreeBin) {
                            Node<K,V> p;
                            binCount = 2;
                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                    value)) != null) {
                                oldVal = p.val;
                                if (!onlyIfAbsent)
                                    p.val = value;
                            }
                        }
                    }
                }
                if (binCount != 0) {
                    // å¦‚æœé“¾è¡¨é•¿åº¦å·²ç»è¾¾åˆ°ä¸´ç•Œå€¼8 å°±éœ€è¦æŠŠé“¾è¡¨è½¬æ¢ä¸ºæ ‘ç»“æ„
                    if (binCount >= TREEIFY_THRESHOLD)
                        treeifyBin(tab, i);
                    if (oldVal != null)
                        return oldVal;
                    break;
                }
            }
        }

        //size + 1
        addCount(1L, binCount);
        return null;
    }
```

æŒ‰ç…§ä¸Šé¢çš„æºç ï¼Œæˆ‘ä»¬å¯ä»¥ç¡®å®šputæ•´ä¸ªæµç¨‹å¦‚ä¸‹ï¼š

- åˆ¤ç©ºï¼›ConcurrentHashMapçš„keyã€valueéƒ½ä¸å…è®¸ä¸ºnull

- è®¡ç®—hashã€‚åˆ©ç”¨æ–¹æ³•è®¡ç®—hashå€¼ã€‚

  ```Java
      static final int spread(int h) {
          return (h ^ (h >>> 16)) & HASH_BITS;
      }
  ```

- éå†tableï¼Œè¿›è¡ŒèŠ‚ç‚¹æ’å…¥æ“ä½œï¼Œè¿‡ç¨‹å¦‚ä¸‹ï¼š

  - å¦‚æœtableä¸ºç©ºï¼Œåˆ™è¡¨ç¤ºConcurrentHashMapè¿˜æ²¡æœ‰åˆå§‹åŒ–ï¼Œåˆ™è¿›è¡Œåˆå§‹åŒ–æ“ä½œï¼šinitTable()
  - æ ¹æ®hashå€¼è·å–èŠ‚ç‚¹çš„ä½ç½®iï¼Œè‹¥è¯¥ä½ç½®ä¸ºç©ºï¼Œåˆ™ç›´æ¥æ’å…¥ï¼Œè¿™ä¸ªè¿‡ç¨‹æ˜¯ä¸éœ€è¦åŠ é”çš„ã€‚è®¡ç®—fä½ç½®ï¼ši=(n - 1) & hash
  - å¦‚æœæ£€æµ‹åˆ°fh = f.hash == -1ï¼Œåˆ™fæ˜¯ForwardingNodeèŠ‚ç‚¹ï¼Œè¡¨ç¤ºæœ‰å…¶ä»–çº¿ç¨‹æ­£åœ¨è¿›è¡Œæ‰©å®¹æ“ä½œï¼Œåˆ™å¸®åŠ©çº¿ç¨‹ä¸€èµ·è¿›è¡Œæ‰©å®¹æ“ä½œ
  - å¦‚æœf.hash >= 0 è¡¨ç¤ºæ˜¯é“¾è¡¨ç»“æ„ï¼Œåˆ™éå†é“¾è¡¨ï¼Œå¦‚æœå­˜åœ¨å½“å‰keyèŠ‚ç‚¹åˆ™æ›¿æ¢valueï¼Œå¦åˆ™æ’å…¥åˆ°é“¾è¡¨å°¾éƒ¨ã€‚å¦‚æœfæ˜¯TreeBinç±»å‹èŠ‚ç‚¹ï¼Œåˆ™æŒ‰ç…§çº¢é»‘æ ‘çš„æ–¹æ³•æ›´æ–°æˆ–è€…å¢åŠ èŠ‚ç‚¹
  - è‹¥é“¾è¡¨é•¿åº¦ > TREEIFY_THRESHOLD(é»˜è®¤æ˜¯8)ï¼Œåˆ™å°†é“¾è¡¨è½¬æ¢ä¸ºçº¢é»‘æ ‘ç»“æ„

- è°ƒç”¨addCountæ–¹æ³•ï¼ŒConcurrentHashMapçš„size + 1

è¿™é‡Œæ•´ä¸ªputæ“ä½œå·²ç»å®Œæˆã€‚

## getæ“ä½œ

ConcurrentHashMapçš„getæ“ä½œè¿˜æ˜¯æŒºç®€å•çš„ï¼Œæ— éå°±æ˜¯é€šè¿‡hashæ¥æ‰¾keyç›¸åŒçš„èŠ‚ç‚¹è€Œå·²ï¼Œå½“ç„¶éœ€è¦åŒºåˆ†é“¾è¡¨å’Œæ ‘å½¢ä¸¤ç§æƒ…å†µã€‚

```Java
    public V get(Object key) {
        Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;
        // è®¡ç®—hash
        int h = spread(key.hashCode());
        if ((tab = table) != null && (n = tab.length) > 0 &&
                (e = tabAt(tab, (n - 1) & h)) != null) {
            // æœç´¢åˆ°çš„èŠ‚ç‚¹keyä¸ä¼ å…¥çš„keyç›¸åŒä¸”ä¸ä¸ºnull,ç›´æ¥è¿”å›è¿™ä¸ªèŠ‚ç‚¹
            if ((eh = e.hash) == h) {
                if ((ek = e.key) == key || (ek != null && key.equals(ek)))
                    return e.val;
            }
            // æ ‘
            else if (eh < 0)
                return (p = e.find(h, key)) != null ? p.val : null;
            // é“¾è¡¨ï¼Œéå†
            while ((e = e.next) != null) {
                if (e.hash == h &&
                        ((ek = e.key) == key || (ek != null && key.equals(ek))))
                    return e.val;
            }
        }
        return null;
    }
```

getæ“ä½œçš„æ•´ä¸ªé€»è¾‘éå¸¸æ¸…æ¥šï¼š

- è®¡ç®—hashå€¼
- åˆ¤æ–­tableæ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœä¸ºç©ºï¼Œç›´æ¥è¿”å›null
- æ ¹æ®hashå€¼è·å–tableä¸­çš„NodeèŠ‚ç‚¹ï¼ˆtabAt(tab, (n - 1) & h)ï¼‰ï¼Œç„¶åæ ¹æ®é“¾è¡¨æˆ–è€…æ ‘å½¢æ–¹å¼æ‰¾åˆ°ç›¸å¯¹åº”çš„èŠ‚ç‚¹ï¼Œè¿”å›å…¶valueå€¼ã€‚

#### size æ“ä½œ

ConcurrentHashMapçš„size()æ–¹æ³•æˆ‘ä»¬è™½ç„¶ç”¨å¾—ä¸æ˜¯å¾ˆå¤šï¼Œä½†æ˜¯æˆ‘ä»¬è¿˜æ˜¯å¾ˆæœ‰å¿…è¦å»äº†è§£çš„ã€‚ConcurrentHashMapçš„size()æ–¹æ³•è¿”å›çš„æ˜¯ä¸€ä¸ªä¸ç²¾ç¡®çš„å€¼ï¼Œå› ä¸ºåœ¨è¿›è¡Œç»Ÿè®¡çš„æ—¶å€™æœ‰å…¶ä»–çº¿ç¨‹æ­£åœ¨è¿›è¡Œæ’å…¥å’Œåˆ é™¤æ“ä½œã€‚å½“ç„¶ä¸ºäº†è¿™ä¸ªä¸ç²¾ç¡®çš„å€¼ï¼ŒConcurrentHashMapä¹Ÿæ˜¯æ“ç¢äº†å¿ƒã€‚

ä¸ºäº†æ›´å¥½åœ°ç»Ÿè®¡sizeï¼ŒConcurrentHashMapæä¾›äº†baseCountã€counterCellsä¸¤ä¸ªè¾…åŠ©å˜é‡å’Œä¸€ä¸ªCounterCellè¾…åŠ©å†…éƒ¨ç±»ã€‚

```Java
    @sun.misc.Contended static final class CounterCell {
        volatile long value;
        CounterCell(long x) { value = x; }
    }

	//ConcurrentHashMapä¸­å…ƒç´ ä¸ªæ•°,ä½†è¿”å›çš„ä¸ä¸€å®šæ˜¯å½“å‰Mapçš„çœŸå®å…ƒç´ ä¸ªæ•°ã€‚åŸºäºCASæ— é”æ›´æ–°
    private transient volatile long baseCount;

    private transient volatile CounterCell[] counterCells;
```

è¿™é‡Œæˆ‘ä»¬éœ€è¦æ¸…æ¥šCounterCell çš„å®šä¹‰

size()æ–¹æ³•å®šä¹‰å¦‚ä¸‹ï¼š

```Java
    public int size() {
        long n = sumCount();
        return ((n < 0L) ? 0 :
                (n > (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :
                (int)n);
    }
```

å†…éƒ¨è°ƒç”¨sunmCount()ï¼š

```Java
    final long sumCount() {
        CounterCell[] as = counterCells; CounterCell a;
        long sum = baseCount;
        if (as != null) {
            for (int i = 0; i < as.length; ++i) {
                //éå†ï¼Œæ‰€æœ‰counteræ±‚å’Œ
                if ((a = as[i]) != null)
                    sum += a.value;
            }
        }
        return sum;
    }
```

sumCount()å°±æ˜¯è¿­ä»£counterCellsæ¥ç»Ÿè®¡sumçš„è¿‡ç¨‹ã€‚æˆ‘ä»¬çŸ¥é“putæ“ä½œæ—¶ï¼Œè‚¯å®šä¼šå½±å“size()ï¼Œæˆ‘ä»¬å°±æ¥çœ‹çœ‹CouncurrentHashMapæ˜¯å¦‚ä½•ä¸ºäº†è¿™ä¸ªä¸å’Œè°çš„size()æ“ç¢äº†å¿ƒã€‚

åœ¨put()æ–¹æ³•æœ€åä¼šè°ƒç”¨addCount()æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä¸»è¦åšä¸¤ä»¶äº‹ï¼Œä¸€ä»¶æ›´æ–°baseCountçš„å€¼ï¼Œç¬¬äºŒä»¶æ£€æµ‹æ˜¯å¦è¿›è¡Œæ‰©å®¹ï¼Œæˆ‘ä»¬åªçœ‹æ›´æ–°baseCountéƒ¨åˆ†ï¼š

```Java
    private final void addCount(long x, int check) {
        CounterCell[] as; long b, s;
        // s = b + xï¼Œå®ŒæˆbaseCount++æ“ä½œï¼›
        if ((as = counterCells) != null ||
            !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {
            CounterCell a; long v; int m;
            boolean uncontended = true;
            if (as == null || (m = as.length - 1) < 0 ||
                (a = as[ThreadLocalRandom.getProbe() & m]) == null ||
                !(uncontended =
                  U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {
                //  å¤šçº¿ç¨‹CASå‘ç”Ÿå¤±è´¥æ—¶æ‰§è¡Œ
                fullAddCount(x, uncontended);
                return;
            }
            if (check <= 1)
                return;
            s = sumCount();
        }

		// æ£€æŸ¥æ˜¯å¦è¿›è¡Œæ‰©å®¹
    }
```

x == 1ï¼Œå¦‚æœcounterCells == nullï¼Œåˆ™U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)ï¼Œå¦‚æœå¹¶å‘ç«äº‰æ¯”è¾ƒå¤§å¯èƒ½ä¼šå¯¼è‡´æ”¹è¿‡ç¨‹å¤±è´¥ï¼Œå¦‚æœå¤±è´¥åˆ™æœ€ç»ˆä¼šè°ƒç”¨fullAddCount()æ–¹æ³•ã€‚å…¶å®ä¸ºäº†æé«˜é«˜å¹¶å‘çš„æ—¶å€™baseCountå¯è§æ€§çš„å¤±è´¥é—®é¢˜ï¼Œåˆé¿å…ä¸€ç›´é‡è¯•ï¼ŒJDK 8 å¼•å…¥äº†ç±»Striped64,å…¶ä¸­LongAdderå’ŒDoubleAdderéƒ½æ˜¯åŸºäºè¯¥ç±»å®ç°çš„ï¼Œè€ŒCounterCellä¹Ÿæ˜¯åŸºäºStriped64å®ç°çš„ã€‚å¦‚æœcounterCells ï¼= nullï¼Œä¸”uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x)ä¹Ÿå¤±è´¥äº†ï¼ŒåŒæ ·ä¼šè°ƒç”¨fullAddCount()æ–¹æ³•ï¼Œæœ€åè°ƒç”¨sumCount()è®¡ç®—sã€‚

å…¶å®åœ¨1.8ä¸­ï¼Œå®ƒä¸æ¨èsize()æ–¹æ³•ï¼Œè€Œæ˜¯æ¨å´‡mappingCount()æ–¹æ³•ï¼Œè¯¥æ–¹æ³•çš„å®šä¹‰å’Œsize()æ–¹æ³•åŸºæœ¬ä¸€è‡´ï¼š

```Java
    public long mappingCount() {
        long n = sumCount();
        return (n < 0L) ? 0L : n; // ignore transient negative values
    }
```

## æ‰©å®¹æ“ä½œ

å½“ConcurrentHashMapä¸­tableå…ƒç´ ä¸ªæ•°è¾¾åˆ°äº†å®¹é‡é˜ˆå€¼ï¼ˆsizeCtlï¼‰æ—¶ï¼Œåˆ™éœ€è¦è¿›è¡Œæ‰©å®¹æ“ä½œã€‚åœ¨putæ“ä½œæ—¶æœ€åä¸€ä¸ªä¼šè°ƒç”¨addCount(long x, int check)ï¼Œè¯¥æ–¹æ³•ä¸»è¦åšä¸¤ä¸ªå·¥ä½œï¼š1.æ›´æ–°baseCountï¼›2.æ£€æµ‹æ˜¯å¦éœ€è¦æ‰©å®¹æ“ä½œã€‚å¦‚ä¸‹ï¼š

```Java
    private final void addCount(long x, int check) {
        CounterCell[] as; long b, s;
        // æ›´æ–°baseCount

        //check >= 0 :åˆ™éœ€è¦è¿›è¡Œæ‰©å®¹æ“ä½œ
        if (check >= 0) {
            Node<K,V>[] tab, nt; int n, sc;
            while (s >= (long)(sc = sizeCtl) && (tab = table) != null &&
                    (n = tab.length) < MAXIMUM_CAPACITY) {
                int rs = resizeStamp(n);
                if (sc < 0) {
                    if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                            sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                            transferIndex <= 0)
                        break;
                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                        transfer(tab, nt);
                }

                //å½“å‰çº¿ç¨‹æ˜¯å”¯ä¸€çš„æˆ–æ˜¯ç¬¬ä¸€ä¸ªå‘èµ·æ‰©å®¹çš„çº¿ç¨‹  æ­¤æ—¶nextTable=null
                else if (U.compareAndSwapInt(this, SIZECTL, sc,
                        (rs << RESIZE_STAMP_SHIFT) + 2))
                    transfer(tab, null);
                s = sumCount();
            }
        }
    }
```

transfer()æ–¹æ³•ä¸ºConcurrentHashMapæ‰©å®¹æ“ä½œçš„æ ¸å¿ƒæ–¹æ³•ã€‚ç”±äºConcurrentHashMapæ”¯æŒå¤šçº¿ç¨‹æ‰©å®¹ï¼Œè€Œä¸”ä¹Ÿæ²¡æœ‰è¿›è¡ŒåŠ é”ï¼Œæ‰€ä»¥å®ç°ä¼šå˜å¾—æœ‰ç‚¹å„¿å¤æ‚ã€‚æ•´ä¸ªæ‰©å®¹æ“ä½œåˆ†ä¸ºä¸¤æ­¥ï¼š

1. æ„å»ºä¸€ä¸ªnextTableï¼Œå…¶å¤§å°ä¸ºåŸæ¥å¤§å°çš„ä¸¤å€ï¼Œè¿™ä¸ªæ­¥éª¤æ˜¯åœ¨å•çº¿ç¨‹ç¯å¢ƒä¸‹å®Œæˆçš„
2. å°†åŸæ¥tableé‡Œé¢çš„å†…å®¹å¤åˆ¶åˆ°nextTableä¸­ï¼Œè¿™ä¸ªæ­¥éª¤æ˜¯å…è®¸å¤šçº¿ç¨‹æ“ä½œçš„ï¼Œæ‰€ä»¥æ€§èƒ½å¾—åˆ°æå‡ï¼Œå‡å°‘äº†æ‰©å®¹çš„æ—¶é—´æ¶ˆè€—

æˆ‘ä»¬å…ˆæ¥çœ‹çœ‹æºä»£ç ï¼Œç„¶åå†ä¸€æ­¥ä¸€æ­¥åˆ†æï¼š

```Java
  private final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {
        int n = tab.length, stride;
        // æ¯æ ¸å¤„ç†çš„é‡å°äº16ï¼Œåˆ™å¼ºåˆ¶èµ‹å€¼16
        if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)
            stride = MIN_TRANSFER_STRIDE; // subdivide range
        if (nextTab == null) {            // initiating
            try {
                @SuppressWarnings("unchecked")
                Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1];        //æ„å»ºä¸€ä¸ªnextTableå¯¹è±¡ï¼Œå…¶å®¹é‡ä¸ºåŸæ¥å®¹é‡çš„ä¸¤å€
                nextTab = nt;
            } catch (Throwable ex) {      // try to cope with OOME
                sizeCtl = Integer.MAX_VALUE;
                return;
            }
            nextTable = nextTab;
            transferIndex = n;
        }
        int nextn = nextTab.length;
        // è¿æ¥ç‚¹æŒ‡é’ˆï¼Œç”¨äºæ ‡å¿—ä½ï¼ˆfwdçš„hashå€¼ä¸º-1ï¼Œfwd.nextTable=nextTabï¼‰
        ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab);
        // å½“advance == trueæ—¶ï¼Œè¡¨æ˜è¯¥èŠ‚ç‚¹å·²ç»å¤„ç†è¿‡äº†
        boolean advance = true;
        boolean finishing = false; // to ensure sweep before committing nextTab
        for (int i = 0, bound = 0;;) {
            Node<K,V> f; int fh;
            // æ§åˆ¶ --i ,éå†åŸhashè¡¨ä¸­çš„èŠ‚ç‚¹
            while (advance) {
                int nextIndex, nextBound;
                if (--i >= bound || finishing)
                    advance = false;
                else if ((nextIndex = transferIndex) <= 0) {
                    i = -1;
                    advance = false;
                }
                // ç”¨CASè®¡ç®—å¾—åˆ°çš„transferIndex
                else if (U.compareAndSwapInt
                        (this, TRANSFERINDEX, nextIndex,
                                nextBound = (nextIndex > stride ?
                                        nextIndex - stride : 0))) {
                    bound = nextBound;
                    i = nextIndex - 1;
                    advance = false;
                }
            }
            if (i < 0 || i >= n || i + n >= nextn) {
                int sc;
                // å·²ç»å®Œæˆæ‰€æœ‰èŠ‚ç‚¹å¤åˆ¶äº†
                if (finishing) {
                    nextTable = null;
                    table = nextTab;        // table æŒ‡å‘nextTable
                    sizeCtl = (n << 1) - (n >>> 1);     // sizeCtlé˜ˆå€¼ä¸ºåŸæ¥çš„1.5å€
                    return;     // è·³å‡ºæ­»å¾ªç¯ï¼Œ
                }
                // CAS æ›´æ‰©å®¹é˜ˆå€¼ï¼Œåœ¨è¿™é‡Œé¢sizectlå€¼å‡ä¸€ï¼Œè¯´æ˜æ–°åŠ å…¥ä¸€ä¸ªçº¿ç¨‹å‚ä¸åˆ°æ‰©å®¹æ“ä½œ
                if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {
                    if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT)
                        return;
                    finishing = advance = true;
                    i = n; // recheck before commit
                }
            }
            // éå†çš„èŠ‚ç‚¹ä¸ºnullï¼Œåˆ™æ”¾å…¥åˆ°ForwardingNode æŒ‡é’ˆèŠ‚ç‚¹
            else if ((f = tabAt(tab, i)) == null)
                advance = casTabAt(tab, i, null, fwd);
            // f.hash == -1 è¡¨ç¤ºéå†åˆ°äº†ForwardingNodeèŠ‚ç‚¹ï¼Œæ„å‘³ç€è¯¥èŠ‚ç‚¹å·²ç»å¤„ç†è¿‡äº†
            // è¿™é‡Œæ˜¯æ§åˆ¶å¹¶å‘æ‰©å®¹çš„æ ¸å¿ƒ
            else if ((fh = f.hash) == MOVED)
                advance = true; // already processed
            else {
                // èŠ‚ç‚¹åŠ é”
                synchronized (f) {
                    // èŠ‚ç‚¹å¤åˆ¶å·¥ä½œ
                    if (tabAt(tab, i) == f) {
                        Node<K,V> ln, hn;
                        // fh >= 0 ,è¡¨ç¤ºä¸ºé“¾è¡¨èŠ‚ç‚¹
                        if (fh >= 0) {
                            // æ„é€ ä¸¤ä¸ªé“¾è¡¨  ä¸€ä¸ªæ˜¯åŸé“¾è¡¨  å¦ä¸€ä¸ªæ˜¯åŸé“¾è¡¨çš„ååºæ’åˆ—
                            int runBit = fh & n;
                            Node<K,V> lastRun = f;
                            for (Node<K,V> p = f.next; p != null; p = p.next) {
                                int b = p.hash & n;
                                if (b != runBit) {
                                    runBit = b;
                                    lastRun = p;
                                }
                            }
                            if (runBit == 0) {
                                ln = lastRun;
                                hn = null;
                            }
                            else {
                                hn = lastRun;
                                ln = null;
                            }
                            for (Node<K,V> p = f; p != lastRun; p = p.next) {
                                int ph = p.hash; K pk = p.key; V pv = p.val;
                                if ((ph & n) == 0)
                                    ln = new Node<K,V>(ph, pk, pv, ln);
                                else
                                    hn = new Node<K,V>(ph, pk, pv, hn);
                            }
                            // åœ¨nextTable i ä½ç½®å¤„æ’ä¸Šé“¾è¡¨
                            setTabAt(nextTab, i, ln);
                            // åœ¨nextTable i + n ä½ç½®å¤„æ’ä¸Šé“¾è¡¨
                            setTabAt(nextTab, i + n, hn);
                            // åœ¨table i ä½ç½®å¤„æ’ä¸ŠForwardingNode è¡¨ç¤ºè¯¥èŠ‚ç‚¹å·²ç»å¤„ç†è¿‡äº†
                            setTabAt(tab, i, fwd);
                            // advance = true å¯ä»¥æ‰§è¡Œ--iåŠ¨ä½œï¼Œéå†èŠ‚ç‚¹
                            advance = true;
                        }
                        // å¦‚æœæ˜¯TreeBinï¼Œåˆ™æŒ‰ç…§çº¢é»‘æ ‘è¿›è¡Œå¤„ç†ï¼Œå¤„ç†é€»è¾‘ä¸ä¸Šé¢ä¸€è‡´
                        else if (f instanceof TreeBin) {
                            TreeBin<K,V> t = (TreeBin<K,V>)f;
                            TreeNode<K,V> lo = null, loTail = null;
                            TreeNode<K,V> hi = null, hiTail = null;
                            int lc = 0, hc = 0;
                            for (Node<K,V> e = t.first; e != null; e = e.next) {
                                int h = e.hash;
                                TreeNode<K,V> p = new TreeNode<K,V>
                                        (h, e.key, e.val, null, null);
                                if ((h & n) == 0) {
                                    if ((p.prev = loTail) == null)
                                        lo = p;
                                    else
                                        loTail.next = p;
                                    loTail = p;
                                    ++lc;
                                }
                                else {
                                    if ((p.prev = hiTail) == null)
                                        hi = p;
                                    else
                                        hiTail.next = p;
                                    hiTail = p;
                                    ++hc;
                                }
                            }

                            // æ‰©å®¹åæ ‘èŠ‚ç‚¹ä¸ªæ•°è‹¥<=6ï¼Œå°†æ ‘è½¬é“¾è¡¨
                            ln = (lc <= UNTREEIFY_THRESHOLD) ? untreeify(lo) :
                                    (hc != 0) ? new TreeBin<K,V>(lo) : t;
                            hn = (hc <= UNTREEIFY_THRESHOLD) ? untreeify(hi) :
                                    (lc != 0) ? new TreeBin<K,V>(hi) : t;
                            setTabAt(nextTab, i, ln);
                            setTabAt(nextTab, i + n, hn);
                            setTabAt(tab, i, fwd);
                            advance = true;
                        }
                    }
                }
            }
        }
    }
```

ä¸Šé¢çš„æºç æœ‰ç‚¹å„¿é•¿ï¼Œç¨å¾®å¤æ‚äº†ä¸€äº›ï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬æŠ›å¼ƒå®ƒå¤šçº¿ç¨‹ç¯å¢ƒï¼Œæˆ‘ä»¬ä»å•çº¿ç¨‹è§’åº¦æ¥çœ‹ï¼š

1. ä¸ºæ¯ä¸ªå†…æ ¸åˆ†ä»»åŠ¡ï¼Œå¹¶ä¿è¯å…¶ä¸å°äº16
2. æ£€æŸ¥nextTableæ˜¯å¦ä¸ºnullï¼Œå¦‚æœæ˜¯ï¼Œåˆ™åˆå§‹åŒ–nextTableï¼Œä½¿å…¶å®¹é‡ä¸ºtableçš„ä¸¤å€
3. æ­»å¾ªç¯éå†èŠ‚ç‚¹ï¼ŒçŸ¥é“finishedï¼šèŠ‚ç‚¹ä»tableå¤åˆ¶åˆ°nextTableä¸­ï¼Œæ”¯æŒå¹¶å‘ï¼Œè¯·æ€è·¯å¦‚ä¸‹ï¼š
   - å¦‚æœèŠ‚ç‚¹ f ä¸ºnullï¼Œåˆ™æ’å…¥ForwardingNodeï¼ˆé‡‡ç”¨Unsafe.compareAndSwapObjectfæ–¹æ³•å®ç°ï¼‰ï¼Œè¿™ä¸ªæ˜¯è§¦å‘å¹¶å‘æ‰©å®¹çš„å…³é”®
   - å¦‚æœfä¸ºé“¾è¡¨çš„å¤´èŠ‚ç‚¹ï¼ˆfh >= 0ï¼‰,åˆ™å…ˆæ„é€ ä¸€ä¸ªååºé“¾è¡¨ï¼Œç„¶åæŠŠä»–ä»¬åˆ†åˆ«æ”¾åœ¨nextTableçš„iå’Œi + nä½ç½®ï¼Œå¹¶å°†ForwardingNode æ’å…¥åŸèŠ‚ç‚¹ä½ç½®ï¼Œä»£è¡¨å·²ç»å¤„ç†è¿‡äº†
   - å¦‚æœfä¸ºTreeBinèŠ‚ç‚¹ï¼ŒåŒæ ·ä¹Ÿæ˜¯æ„é€ ä¸€ä¸ªååº ï¼ŒåŒæ—¶éœ€è¦åˆ¤æ–­æ˜¯å¦éœ€è¦è¿›è¡ŒunTreeify()æ“ä½œï¼Œå¹¶æŠŠå¤„ç†çš„ç»“æœåˆ†åˆ«æ’å…¥åˆ°nextTableçš„i å’Œi+nwä½ç½®ï¼Œå¹¶æ’å…¥ForwardingNode èŠ‚ç‚¹
4. æ‰€æœ‰èŠ‚ç‚¹å¤åˆ¶å®Œæˆåï¼Œåˆ™å°†tableæŒ‡å‘nextTableï¼ŒåŒæ—¶æ›´æ–°sizeCtl = nextTableçš„0.75å€ï¼Œå®Œæˆæ‰©å®¹è¿‡ç¨‹

åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ï¼ŒConcurrentHashMapç”¨ä¸¤ç‚¹æ¥ä¿è¯æ­£ç¡®æ€§ï¼šForwardingNodeå’Œsynchronizedã€‚å½“ä¸€ä¸ªçº¿ç¨‹éå†åˆ°çš„èŠ‚ç‚¹å¦‚æœæ˜¯ForwardingNodeï¼Œåˆ™ç»§ç»­å¾€åéå†ï¼Œå¦‚æœä¸æ˜¯ï¼Œåˆ™å°†è¯¥èŠ‚ç‚¹åŠ é”ï¼Œé˜²æ­¢å…¶ä»–çº¿ç¨‹è¿›å…¥ï¼Œå®Œæˆåè®¾ç½®ForwardingNodeèŠ‚ç‚¹ï¼Œä»¥ä¾¿è¦å…¶ä»–çº¿ç¨‹å¯ä»¥çœ‹åˆ°è¯¥èŠ‚ç‚¹å·²ç»å¤„ç†è¿‡äº†ï¼Œå¦‚æ­¤äº¤å‰è¿›è¡Œï¼Œé«˜æ•ˆè€Œåˆå®‰å…¨ã€‚

ä¸‹å›¾æ˜¯æ‰©å®¹çš„è¿‡ç¨‹ï¼ˆæ¥è‡ªï¼š<http://blog.csdn.net/u010723709/article/details/48007881>ï¼‰ï¼š

[![201703050001_2[4\]](https://gitee.com/chenssy/blog-home/raw/master/image/sijava/2018120821001.png)](https://gitee.com/chenssy/blog-home/raw/master/image/sijava/2018120821001.png)

åœ¨putæ“ä½œæ—¶å¦‚æœå‘ç°fh.hash = -1ï¼Œåˆ™è¡¨ç¤ºæ­£åœ¨è¿›è¡Œæ‰©å®¹æ“ä½œï¼Œåˆ™å½“å‰çº¿ç¨‹ä¼šååŠ©è¿›è¡Œæ‰©å®¹æ“ä½œã€‚

```Java
            else if ((fh = f.hash) == MOVED)
                tab = helpTransfer(tab, f);
```

helpTransfer()æ–¹æ³•ä¸ºååŠ©æ‰©å®¹æ–¹æ³•ï¼Œå½“è°ƒç”¨è¯¥æ–¹æ³•çš„æ—¶å€™ï¼ŒnextTableä¸€å®šå·²ç»åˆ›å»ºäº†ï¼Œæ‰€ä»¥è¯¥æ–¹æ³•ä¸»è¦åˆ™æ˜¯è¿›è¡Œå¤åˆ¶å·¥ä½œã€‚å¦‚ä¸‹ï¼š

```Java
    final Node<K,V>[] helpTransfer(Node<K,V>[] tab, Node<K,V> f) {
        Node<K,V>[] nextTab; int sc;
        if (tab != null && (f instanceof ForwardingNode) &&
                (nextTab = ((ForwardingNode<K,V>)f).nextTable) != null) {
            int rs = resizeStamp(tab.length);
            while (nextTab == nextTable && table == tab &&
                    (sc = sizeCtl) < 0) {
                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                        sc == rs + MAX_RESIZERS || transferIndex <= 0)
                    break;
                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) {
                    transfer(tab, nextTab);
                    break;
                }
            }
            return nextTab;
        }
        return table;
    }
```

## è½¬æ¢çº¢é»‘æ ‘

åœ¨putæ“ä½œæ˜¯ï¼Œå¦‚æœå‘ç°é“¾è¡¨ç»“æ„ä¸­çš„å…ƒç´ è¶…è¿‡äº†TREEIFY_THRESHOLDï¼ˆé»˜è®¤ä¸º8ï¼‰ï¼Œåˆ™ä¼šæŠŠé“¾è¡¨è½¬æ¢ä¸ºçº¢é»‘æ ‘ï¼Œå·²ä¾¿äºæé«˜æŸ¥è¯¢æ•ˆç‡ã€‚å¦‚ä¸‹ï¼š

```Java
if (binCount >= TREEIFY_THRESHOLD)
    treeifyBin(tab, i);
```

è°ƒç”¨treeifyBinæ–¹æ³•ç”¨ä¸å°†é“¾è¡¨è½¬æ¢ä¸ºçº¢é»‘æ ‘ã€‚

```Java
private final void treeifyBin(Node<K,V>[] tab, int index) {
        Node<K,V> b; int n, sc;
        if (tab != null) {
            if ((n = tab.length) < MIN_TREEIFY_CAPACITY)//å¦‚æœtable.length<64 å°±æ‰©å¤§ä¸€å€ è¿”å›
                tryPresize(n << 1);
            else if ((b = tabAt(tab, index)) != null && b.hash >= 0) {
                synchronized (b) {
                    if (tabAt(tab, index) == b) {
                        TreeNode<K,V> hd = null, tl = null;
                        //æ„é€ äº†ä¸€ä¸ªTreeBinå¯¹è±¡ æŠŠæ‰€æœ‰NodeèŠ‚ç‚¹åŒ…è£…æˆTreeNodeæ”¾è¿›å»
                        for (Node<K,V> e = b; e != null; e = e.next) {
                            TreeNode<K,V> p =
                                new TreeNode<K,V>(e.hash, e.key, e.val,
                                                  null, null);//è¿™é‡Œåªæ˜¯åˆ©ç”¨äº†TreeNodeå°è£… è€Œæ²¡æœ‰åˆ©ç”¨TreeNodeçš„nextåŸŸå’ŒparentåŸŸ
                            if ((p.prev = tl) == null)
                                hd = p;
                            else
                                tl.next = p;
                            tl = p;
                        }
                        //åœ¨åŸæ¥indexçš„ä½ç½® ç”¨TreeBinæ›¿æ¢æ‰åŸæ¥çš„Nodeå¯¹è±¡
                        setTabAt(tab, index, new TreeBin<K,V>(hd));
                    }
                }
            }
        }
    }
```

ä»ä¸Šé¢æºç å¯ä»¥çœ‹å‡ºï¼Œæ„å»ºçº¢é»‘æ ‘çš„è¿‡ç¨‹æ˜¯åŒæ­¥çš„ï¼Œè¿›å…¥åŒæ­¥åè¿‡ç¨‹å¦‚ä¸‹ï¼š

1. æ ¹æ®tableä¸­indexä½ç½®Nodeé“¾è¡¨ï¼Œé‡æ–°ç”Ÿæˆä¸€ä¸ªhdä¸ºå¤´ç»“ç‚¹çš„TreeNode
2. æ ¹æ®hdå¤´ç»“ç‚¹ï¼Œç”ŸæˆTreeBinæ ‘ç»“æ„ï¼Œå¹¶ç”¨TreeBinæ›¿æ¢æ‰åŸæ¥çš„Nodeå¯¹è±¡ã€‚

æ•´ä¸ªçº¢é»‘æ ‘çš„æ„å»ºè¿‡ç¨‹æœ‰ç‚¹å„¿å¤æ‚ï¼Œå…³äºConcurrentHashMap çº¢é»‘æ ‘çš„æ„å»ºè¿‡ç¨‹ï¼Œæˆ‘ä»¬åç»­åˆ†æã€‚

**ã€æ³¨ã€‘ï¼šConcurrentHashMapçš„æ‰©å®¹å’Œé“¾è¡¨è½¬çº¢é»‘æ ‘ç¨å¾®å¤æ‚ç‚¹ï¼Œåç»­å¦èµ·åšæ–‡åˆ†æ**

# 666. å½©è›‹

å¦‚æœä½ å¯¹ Java å¹¶å‘æ„Ÿå…´è¶£ï¼Œæ¬¢è¿åŠ å…¥æˆ‘çš„çŸ¥è¯†æ˜Ÿçƒä¸€èµ·äº¤æµã€‚

![çŸ¥è¯†æ˜Ÿçƒ](http://www.iocoder.cn/images/Architecture/2017_12_29/01.png)