title: Hystrix æºç è§£æ â€”â€” å‘½ä»¤æ‰§è¡Œï¼ˆä¸‰ï¼‰ä¹‹æ‰§è¡Œè¶…æ—¶
date: 2018-10-28
tags:
categories: Hystrix
permalink: Hystrix/command-execute-third-timeout

-------

æ‘˜è¦: åŸåˆ›å‡ºå¤„ http://www.iocoder.cn/Hystrix/command-execute-third-timeout/ ã€ŒèŠ‹é“æºç ã€æ¬¢è¿è½¬è½½ï¼Œä¿ç•™æ‘˜è¦ï¼Œè°¢è°¢ï¼

**æœ¬æ–‡ä¸»è¦åŸºäº Hystrix 1.5.X ç‰ˆæœ¬**  

- [1. æ¦‚è¿°](http://www.iocoder.cn/Hystrix/command-execute-third-timeout/)
- [2. HystrixObservableTimeoutOperator](http://www.iocoder.cn/Hystrix/command-execute-third-timeout/)
- [3. HystrixTimer](http://www.iocoder.cn/Hystrix/command-execute-third-timeout/)
  - [3.1 ScheduledExecutor](http://www.iocoder.cn/Hystrix/command-execute-third-timeout/)
  - [3.2 TimerListener](http://www.iocoder.cn/Hystrix/command-execute-third-timeout/)
  - [3.3 TimerReference](http://www.iocoder.cn/Hystrix/command-execute-third-timeout/)
- [666. å½©è›‹](http://www.iocoder.cn/Hystrix/command-execute-third-timeout/)

-------

![](http://www.iocoder.cn/images/common/wechat_mp_2018_05_18.jpg)

> ğŸ™‚ğŸ™‚ğŸ™‚å…³æ³¨**å¾®ä¿¡å…¬ä¼—å·ï¼šã€èŠ‹é“æºç ã€‘**æœ‰ç¦åˆ©ï¼š  
> 1. RocketMQ / MyCAT / Sharding-JDBC **æ‰€æœ‰**æºç åˆ†ææ–‡ç« åˆ—è¡¨  
> 2. RocketMQ / MyCAT / Sharding-JDBC **ä¸­æ–‡æ³¨é‡Šæºç  GitHub åœ°å€**  
> 3. æ‚¨å¯¹äºæºç çš„ç–‘é—®æ¯æ¡ç•™è¨€**éƒ½**å°†å¾—åˆ°**è®¤çœŸ**å›å¤ã€‚**ç”šè‡³ä¸çŸ¥é“å¦‚ä½•è¯»æºç ä¹Ÿå¯ä»¥è¯·æ•™å™¢**ã€‚  
> 4. **æ–°çš„**æºç è§£ææ–‡ç« **å®æ—¶**æ”¶åˆ°é€šçŸ¥ã€‚**æ¯å‘¨æ›´æ–°ä¸€ç¯‡å·¦å³**ã€‚  
> 5. **è®¤çœŸçš„**æºç äº¤æµå¾®ä¿¡ç¾¤ã€‚

-------

# 1. æ¦‚è¿°

æœ¬æ–‡ä¸»è¦åˆ†äº« **Hystrix å‘½ä»¤æ‰§è¡Œï¼ˆä¸‰ï¼‰ä¹‹æ‰§è¡Œè¶…æ—¶**ã€‚

å»ºè®® ï¼šå¯¹ RxJava å·²ç»æœ‰ä¸€å®šçš„äº†è§£çš„åŸºç¡€ä¸Šé˜…è¯»æœ¬æ–‡ã€‚

å¼€å¯**æ‰§è¡Œè¶…æ—¶**åŠŸèƒ½ï¼Œéœ€è¦é…ç½® ï¼š

* `HystrixCommandProperties.executionTimeoutEnabled` ï¼šæ‰§è¡Œå‘½ä»¤è¶…æ—¶åŠŸèƒ½å¼€å…³ã€‚
    * å€¼ ï¼šBoolean
    * é»˜è®¤å€¼ ï¼š`true` 
* `HystrixCommandProperties.executionTimeoutInMilliseconds` ï¼šæ‰§è¡Œå‘½ä»¤è¶…æ—¶æ—¶é•¿ã€‚
    * å€¼ ï¼šInteger
    * å•ä½ ï¼šæ¯«ç§’
    * é»˜è®¤å€¼ ï¼š1000 æ¯«ç§’

åœ¨ [ã€ŠHystrix æºç è§£æ â€”â€” å‘½ä»¤æ‰§è¡Œï¼ˆä¸€ï¼‰ä¹‹æ­£å¸¸æ‰§è¡Œé€»è¾‘ã€‹ã€Œ4. #executeCommandAndObserve(â€¦)ã€](http://www.iocoder.cn/Hystrix/command-execute-first-run/?self) ä¸­ï¼Œ`#executeCommandAndObserve(...)` æ–¹æ³•çš„**ç¬¬ 75 è¡Œ** `lift(new HystrixObservableTimeoutOperator<R>(_cmd))` ï¼Œå®ç°äº†å¯¹æ‰§è¡Œå‘½ä»¤è¶…æ—¶çš„ç›‘æ§ã€‚

* å¯¹ `Observable#lift(Operator)` æ–¹æ³•ä¸ç†Ÿæ‚‰çš„åŒå­¦ï¼Œåœ¨ [ã€ŠRxJava æºç è§£æ â€”â€” Observable#lift(Operator)ã€‹](http://www.iocoder.cn/RxJava/observable-lift-operator/?self) æœ‰è¯¦ç»†è§£æã€‚

-------

**æ¨è Spring Cloud ä¹¦ç±**ï¼š

* è¯·æ”¯æŒæ­£ç‰ˆã€‚ä¸‹è½½ç›—ç‰ˆï¼Œ**ç­‰äºä¸»åŠ¨ç¼–å†™ä½çº§ BUG** ã€‚
* ç¨‹åºçŒ¿DD â€”â€” [ã€ŠSpring Cloudå¾®æœåŠ¡å®æˆ˜ã€‹](https://union-click.jd.com/jdc?d=505Twi)
* å‘¨ç«‹ â€”â€” [ã€ŠSpring Cloudä¸Dockerå¾®æœåŠ¡æ¶æ„å®æˆ˜ã€‹](https://union-click.jd.com/jdc?d=k3sAaK)
* ä¸¤ä¹¦é½ä¹°ï¼Œäº¬ä¸œåŒ…é‚®ã€‚



# 2. HystrixObservableTimeoutOperator

HystrixObservableTimeoutOperator ç±»ï¼Œä»£ç å¦‚ä¸‹ ï¼š

```Java
  1: private static class HystrixObservableTimeoutOperator<R> implements Operator<R, R> {
  2: 
  3:     final AbstractCommand<R> originalCommand;
  4: 
  5:     public HystrixObservableTimeoutOperator(final AbstractCommand<R> originalCommand) {
  6:         this.originalCommand = originalCommand;
  7:     }
  8: 
  9:     @Override
 10:     public Subscriber<? super R> call(final Subscriber<? super R> child) {
 11:         // åˆ›å»º è®¢é˜…
 12:         final CompositeSubscription s = new CompositeSubscription();
 13:         // æ·»åŠ  è®¢é˜…
 14:         // if the child unsubscribes we unsubscribe our parent as well
 15:         child.add(s);
 16: 
 17:         //capture the HystrixRequestContext upfront so that we can use it in the timeout thread later
 18:         final HystrixRequestContext hystrixRequestContext = HystrixRequestContext.getContextForCurrentThread();
 19: 
 20:         TimerListener listener = new TimerListener() {
 21: 
 22:             @Override
 23:             public void tick() {
 24:                 // if we can go from NOT_EXECUTED to TIMED_OUT then we do the timeout codepath
 25:                 // otherwise it means we lost a race and the run() execution completed or did not start
 26:                 if (originalCommand.isCommandTimedOut.compareAndSet(TimedOutStatus.NOT_EXECUTED, TimedOutStatus.TIMED_OUT)) {
 27:                     // report timeout failure
 28:                     originalCommand.eventNotifier.markEvent(HystrixEventType.TIMEOUT, originalCommand.commandKey);
 29: 
 30:                     // shut down the original request
 31:                     s.unsubscribe();
 32: 
 33:                     final HystrixContextRunnable timeoutRunnable = new HystrixContextRunnable(originalCommand.concurrencyStrategy, hystrixRequestContext, new Runnable() {
 34: 
 35:                         @Override
 36:                         public void run() {
 37:                             child.onError(new HystrixTimeoutException());
 38:                         }
 39:                     });
 40: 
 41:                     timeoutRunnable.run();
 42:                     //if it did not start, then we need to mark a command start for concurrency metrics, and then issue the timeout
 43:                 }
 44:             }
 45: 
 46:             @Override
 47:             public int getIntervalTimeInMilliseconds() {
 48:                 return originalCommand.properties.executionTimeoutInMilliseconds().get();
 49:             }
 50:         };
 51: 
 52:         final Reference<TimerListener> tl = HystrixTimer.getInstance().addTimerListener(listener);
 53: 
 54:         // set externally so execute/queue can see this
 55:         originalCommand.timeoutTimer.set(tl);
 56: 
 57:         /**
 58:          * If this subscriber receives values it means the parent succeeded/completed
 59:          */
 60:         Subscriber<R> parent = new Subscriber<R>() {
 61: 
 62:             @Override
 63:             public void onCompleted() {
 64:                 if (isNotTimedOut()) {
 65:                     // stop timer and pass notification through
 66:                     tl.clear();
 67:                     // å®Œæˆ
 68:                     child.onCompleted();
 69:                 } else {
 70:                     System.out.println("timeout: " + "onCompleted"); // ç¬”è€…è°ƒè¯•ç”¨
 71:                 } 
 72:             }
 73: 
 74:             @Override
 75:             public void onError(Throwable e) {
 76:                 if (isNotTimedOut()) {
 77:                     // stop timer and pass notification through
 78:                     tl.clear();
 79:                     // å¼‚å¸¸
 80:                     child.onError(e);
 81:                 } else {
 82:                     System.out.println("timeout: " + "onError"); // ç¬”è€…è°ƒè¯•ç”¨
 83:                 } 
 84:             }
 85: 
 86:             @Override
 87:             public void onNext(R v) {
 88:                 if (isNotTimedOut()) {
 89:                     // ç»§ç»­æ‰§è¡Œ
 90:                     child.onNext(v);
 91:                 } else {
 92:                     System.out.println("timeout: " + "onNext"); // ç¬”è€…è°ƒè¯•ç”¨
 93:                 }
 94:             }
 95: 
 96:             /**
 97:              * é€šè¿‡ CAS åˆ¤æ–­æ˜¯å¦è¶…æ—¶
 98:              *
 99:              * @return æ˜¯å¦è¶…æ—¶
100:              */
101:             private boolean isNotTimedOut() {
102:                 // if already marked COMPLETED (by onNext) or succeeds in setting to COMPLETED
103:                 return originalCommand.isCommandTimedOut.get() == TimedOutStatus.COMPLETED ||
104:                         originalCommand.isCommandTimedOut.compareAndSet(TimedOutStatus.NOT_EXECUTED, TimedOutStatus.COMPLETED);
105:             }
106: 
107:         };
108: 
109:         // æ·»åŠ  è®¢é˜…
110:         // if s is unsubscribed we want to unsubscribe the parent
111:         s.add(parent);
112: 
113:         return parent;
114:     }
115: 
116: }
```
* ç¬¬ 12 è¡Œ ï¼šåˆ›å»ºè®¢é˜… `s` ã€‚
* ç¬¬ 15 è¡Œ ï¼šæ·»åŠ è®¢é˜… `s` åˆ° `child` çš„è®¢é˜…ã€‚
* ç¬¬ 18 è¡Œ ï¼šè·å¾— HystrixRequestContext ã€‚å› ä¸ºä¸‹é¢ `listener` çš„æ‰§è¡Œä¸åœ¨å½“å‰çº¿ç¨‹ï¼ŒHystrixRequestContext åŸºäº ThreadLocal å®ç°ã€‚
* ç¬¬ 20 è‡³ 50 è¡Œ ï¼šåˆ›å»ºæ‰§è¡Œå‘½ä»¤è¶…æ—¶**ç›‘å¬å™¨** `listener` ( TimerListener ) ã€‚å½“è¶…è¿‡æ‰§è¡Œå‘½ä»¤çš„æ—¶é•¿( `TimerListener#getIntervalTimeInMilliseconds()` )æ—¶ï¼Œ`TimerListener#tick()` æ–¹æ³•**è§¦å‘**è°ƒç”¨ã€‚
    * ç¬¬ 26 è¡Œ ï¼šé€šè¿‡ `AbstractCommand.isCommandTimedOut` å˜é‡ CAS æ“ä½œï¼Œä¿è¯å’Œä¸‹é¢**ç¬¬ 60 è¡Œ**çš„ `parent` æœ‰ä¸”åªæœ‰ä¸€æ–¹æ“ä½œæˆåŠŸã€‚TimedOutStatus çŠ¶æ€å˜è¿å¦‚ä¸‹å›¾ ï¼š![](http://www.iocoder.cn/images/Hystrix/2018_10_28/01.png)
    * ç¬¬ 28 è¡Œ ï¼šTODO ã€2011ã€‘ã€Hystrix äº‹ä»¶æœºåˆ¶ã€‘
    * ç¬¬ 31 è¡Œ ï¼šå–æ¶ˆè®¢é˜… `s` ã€‚**æ³¨æ„ ï¼šä¸åŒæ‰§è¡Œéš”ç¦»ç­–ç•¥æ­¤å¤„çš„è¡¨ç°ä¸åŒ**ã€‚
        * `ExecutionIsolationStrategy.THREAD` ï¼šè¯¥ç­–ç•¥ä¸‹æä¾›å–æ¶ˆè®¢é˜…( `#unsubscribe()` )ï¼Œå¹¶ä¸”å‘½ä»¤æ‰§è¡Œè¶…æ—¶ï¼Œ**å¼ºåˆ¶**å–æ¶ˆå‘½ä»¤çš„æ‰§è¡Œã€‚åœ¨ [ã€ŠHystrix æºç è§£æ â€”â€” å‘½ä»¤æ‰§è¡Œï¼ˆäºŒï¼‰ä¹‹æ‰§è¡Œéš”ç¦»ç­–ç•¥ã€‹ã€Œ6.5 FutureCompleterWithConfigurableInterruptã€](http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/?self) æœ‰è¯¦ç»†è§£æã€‚
        * `ExecutionIsolationStrategy.SEMAPHORE` ï¼šè¯¥ç­–ç•¥ä¸‹**æœª**æä¾›å–æ¶ˆè®¢é˜…( `#unsubscribe()` )æ—¶ï¼Œå¯¹è¶…æ—¶æ‰§è¡Œå‘½ä»¤çš„å–æ¶ˆã€‚**æ‰€ä»¥ï¼Œåœ¨é€‰æ‹©æ‰§è¡Œéš”ç¦»ç­–ç•¥ï¼Œè¦æ³¨æ„è¿™å—**ã€‚
    * ç¬¬ 34 è‡³ 41 è¡Œ ï¼šæ‰§è¡Œ `child#onError(e) ã€Subscriber#onError(Throwable)ã€‘` æ–¹æ³•ï¼Œå¤„ç† HystrixTimeoutException å¼‚å¸¸ã€‚è¯¥å¼‚å¸¸ä¼šè¢« `handleFallback` å¤„ç†ï¼Œç‚¹å‡» [é“¾æ¥](https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L602) æŸ¥çœ‹ï¼Œåœ¨ [ã€ŠHystrix æºç è§£æ â€”â€” è¯·æ±‚æ‰§è¡Œï¼ˆå››ï¼‰ä¹‹å¤±è´¥å›é€€é€»è¾‘ã€‹](http://www.iocoder.cn/Hystrix/command-execute-fourth-fallback/?self) è¯¦ç»†è§£æã€‚
        * HystrixContextRunnable ï¼Œè®¾ç½®**ç¬¬ 18 è¡Œ**è·å¾—çš„ HystrixRequestContext åˆ° `Callable#run()` æ‰€åœ¨çº¿ç¨‹çš„ HystrixRequestContext ï¼Œå¹¶ç»§ç»­æ‰§è¡Œã€‚ç‚¹å‡» [é“¾æ¥](https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextRunnable.java#L27) æŸ¥çœ‹ã€‚å¦å¤–ï¼ŒHystrixContextRunnable åªæœ‰æ­¤å¤„ä½¿ç”¨ï¼Œç‹¬ç«‹æˆç±»çš„åŸå› æ˜¯æµ‹è¯•ç”¨ä¾‹ä½¿ç”¨åˆ°ã€‚
* ç¬¬ 52 è¡Œ ï¼šä½¿ç”¨ TimerListener åˆ°å®šæ—¶å™¨ï¼Œç›‘å¬å‘½ä»¤çš„è¶…æ—¶æ‰§è¡Œã€‚
* ç¬¬ 55 è¡Œ ï¼šè®¾ç½® TimerListener åˆ° `AbstractCommand.timeoutTimer` å±æ€§ã€‚ç”¨äºæ‰§è¡Œè¶…æ—¶ç­‰ç­‰åœºæ™¯ä¸‹çš„ TimerListener çš„æ¸…ç†( `tl#clear()` )ã€‚å¦‚ä¸‹æ–¹æ³•æœ‰é€šè¿‡è¯¥å±æ€§å¯¹ TimerListener çš„æ¸…ç† ï¼š
    * [`AbstractCommand#handleCommandEnd()`](https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L947)
    * [`AbstractCommand#cleanUpAfterResponseFromCache()`](https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L930)

* ç¬¬ 60 è‡³ 107 è¡Œ ï¼šåˆ›å»º**æ–°**çš„ Subscriber ( `parent` )ã€‚åœ¨ä¼ å‚çš„ `child` çš„åŸºç¡€ä¸Šï¼Œå¢åŠ äº†å¯¹æ˜¯å¦æ‰§è¡Œè¶…æ—¶çš„åˆ¤æ–­( `#isNotTimedOut()` )å’ŒTimerListenerçš„æ¸…ç†ã€‚
* ç¬¬ 111 è¡Œ ï¼šæ·»åŠ æ·»åŠ è®¢é˜… `parent` åˆ° `s` çš„è®¢é˜…ã€‚æ•´ä½“è®¢é˜…å…³ç³»å¦‚ä¸‹ ï¼š![](http://www.iocoder.cn/images/Hystrix/2018_10_28/02.png)
    * è¿™é‡Œçœ‹èµ·æ¥ `s` æœ‰äº›â€œå¤šä½™â€ ï¼Ÿå› ä¸º `parent` å’Œ `listener` å­˜åœ¨äº’ç›¸å¼•ç”¨çš„æƒ…å†µï¼Œé€šè¿‡ `s` è§£å†³ã€‚
* ç¬¬ 113 è¡Œ ï¼šè¿”å› `parent` ã€‚**æ³¨æ„**ã€‚å¦‚æœä¸èƒ½ç†è§£ï¼Œå»ºè®®é˜…è¯»ä¸‹ [ã€ŠRxJava æºç è§£æ â€”â€” Observable#lift(Operator)ã€‹](http://www.iocoder.cn/RxJava/observable-lift-operator/?self) ã€‚


# 3. HystrixTimer

`com.netflix.hystrix.util.HystrixTimer` ï¼ŒHystrix å®šæ—¶å™¨ã€‚

ç›®å‰æœ‰å¦‚ä¸‹åœºæ™¯ä½¿ç”¨ ï¼š

* æ‰§è¡Œå‘½ä»¤è¶…æ—¶ä»»åŠ¡ï¼Œæœ¬æ–‡è¯¦ç»†è§£æã€‚
* å‘½ä»¤æ‰¹é‡æ‰§è¡Œï¼Œåœ¨ [ã€ŠHystrix æºç è§£æ â€”â€” å‘½ä»¤åˆå¹¶æ‰§è¡Œã€‹ã€Œ5. CollapsedTaskã€](http://www.iocoder.cn/Hystrix/command-collapser-execute?self) è¯¦ç»†è§£æã€‚

HystrixTimer **æ„é€ æ–¹æ³•**ï¼Œä»£ç å¦‚ä¸‹ ï¼š

```Java
public class HystrixTimer {

    /**
     * å•ä¾‹
     */
    private static HystrixTimer INSTANCE = new HystrixTimer();

    /* package */ AtomicReference<ScheduledExecutor> executor = new AtomicReference<ScheduledExecutor>();

    private HystrixTimer() {
        // private to prevent public instantiation
    }

    public static HystrixTimer getInstance() {
        return INSTANCE;
    }

}
```

* `INSTANCE` **é™æ€**å±æ€§ï¼Œå•ä¾‹ã€‚
* `executor` å±æ€§ï¼Œå®šæ—¶ä»»åŠ¡**æ‰§è¡Œå™¨**( ScheduledExecutor )ã€‚

-------

è°ƒç”¨ `HystrixTimer#addTimerListener(TimerListener)` æ–¹æ³•ï¼Œæäº¤å®šæ—¶**ç›‘å¬å™¨**ï¼Œç”Ÿæˆå®šæ—¶**ä»»åŠ¡**ï¼Œä»£ç å¦‚ä¸‹ ï¼š

```Java
  1: public Reference<TimerListener> addTimerListener(final TimerListener listener) {
  2:     startThreadIfNeeded();
  3:     // add the listener
  4: 
  5:     Runnable r = new Runnable() {
  6: 
  7:         @Override
  8:         public void run() {
  9:             try {
 10:                 listener.tick();
 11:             } catch (Exception e) {
 12:                 logger.error("Failed while ticking TimerListener", e);
 13:             }
 14:         }
 15:     };
 16: 
 17:     ScheduledFuture<?> f = executor.get().getThreadPool().scheduleAtFixedRate(r, listener.getIntervalTimeInMilliseconds(), listener.getIntervalTimeInMilliseconds(), TimeUnit.MILLISECONDS);
 18:     return new TimerReference(listener, f);
 19: }
```

* ç¬¬ 2 è¡Œ ï¼šè°ƒç”¨ `#startThreadIfNeeded()` æ–¹æ³•ï¼Œä¿è¯ `executor` **å»¶è¿Ÿ**åˆå§‹åŒ–å·²å®Œæˆã€‚
    * `#startThreadIfNeeded()` æ–¹æ³• ï¼Œæ¯”è¾ƒç®€å•ï¼Œç‚¹å‡» [é“¾æ¥](https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/util/HystrixTimer.java#L133) æŸ¥çœ‹ã€‚
    * ScheduledExecutor åœ¨ [ã€Œ3.1 ScheduledExecutorã€](#) è¯¦ç»†è§£æã€‚
* ç¬¬ 5 è‡³ 15 è¡Œ ï¼šåˆ›å»ºå®šæ—¶ä»»åŠ¡ Runnable ã€‚åœ¨ `Runnable#run()` æ–¹æ³•é‡Œï¼Œè°ƒç”¨ `TimerListener#tick()` æ–¹æ³•ã€‚åœ¨ [ã€Œ3.2 TimerListenerã€](#) è¯¦ç»†è§£æã€‚
* ç¬¬ 17 è¡Œ ï¼šæäº¤å®šæ—¶**ç›‘å¬å™¨**ï¼Œç”Ÿæˆå®šæ—¶**ä»»åŠ¡** `f` ( ScheduledFuture )ã€‚
* ç¬¬ 18 è¡Œ ï¼šä½¿ç”¨ `listener` + `f` åˆ›å»º TimerReference è¿”å›ã€‚åœ¨ [ã€Œ3.3 TimerReferenceã€](#) è¯¦ç»†è§£æã€‚


## 3.1 ScheduledExecutor

`com.netflix.hystrix.util.HystrixTimer.ScheduledExecutor` ï¼ŒHystrix å®šæ—¶ä»»åŠ¡**æ‰§è¡Œå™¨**ã€‚ä»£ç å¦‚ä¸‹ ï¼š

```Java
/* package */ static class ScheduledExecutor {
    /**
    * å®šæ—¶ä»»åŠ¡çº¿ç¨‹æ± æ‰§è¡Œå™¨
    */
    /* package */ volatile ScheduledThreadPoolExecutor executor;
    /**
     * æ˜¯å¦åˆå§‹åŒ–
     */
    private volatile boolean initialized;

    /**
     * We want this only done once when created in compareAndSet so use an initialize method
     */
    public void initialize() {
        // coreSize
        HystrixPropertiesStrategy propertiesStrategy = HystrixPlugins.getInstance().getPropertiesStrategy();
        int coreSize = propertiesStrategy.getTimerThreadPoolProperties().getCorePoolSize().get();

        // åˆ›å»º ThreadFactory
        ThreadFactory threadFactory = null;
        if (!PlatformSpecific.isAppEngineStandardEnvironment()) {
            threadFactory = new ThreadFactory() {
                final AtomicInteger counter = new AtomicInteger();

                @Override
                public Thread newThread(Runnable r) {
                    Thread thread = new Thread(r, "HystrixTimer-" + counter.incrementAndGet());
                    thread.setDaemon(true);
                    return thread;
                }

            };
        } else {
            threadFactory = PlatformSpecific.getAppEngineThreadFactory();
        }

        // åˆ›å»º ScheduledThreadPoolExecutor
        executor = new ScheduledThreadPoolExecutor(coreSize, threadFactory);

        // å·²åˆå§‹åŒ–
        initialized = true;
   }

   public ScheduledThreadPoolExecutor getThreadPool() {
       return executor;
   }

   public boolean isInitialized() {
       return initialized;
   }
}
```

* çº¿ç¨‹æ± å¤§å°( `coreSize` )ï¼Œé€šè¿‡ `HystrixTimerThreadPoolProperties.corePoolSize` é…ç½®ã€‚

## 3.2 TimerListener

`com.netflix.hystrix.util.HystrixTimer.TimerListener` ï¼ŒHystrix å®šæ—¶ä»»åŠ¡**ç›‘å¬å™¨****æ¥å£**ã€‚ä»£ç å¦‚ä¸‹ ï¼š

```Java
public static interface TimerListener {

   /**
    * The 'tick' is called each time the interval occurs.
    * <p>
    * This method should NOT block or do any work but instead fire its work asynchronously to perform on another thread otherwise it will prevent the Timer from functioning.
    * <p>
    * This contract is used to keep this implementation single-threaded and simplistic.
    * <p>
    * If you need a ThreadLocal set, you can store the state in the TimerListener, then when tick() is called, set the ThreadLocal to your desired value.
    */
   void tick();

   /**
    * How often this TimerListener should 'tick' defined in milliseconds.
    */
   int getIntervalTimeInMilliseconds();
}
```

* `#tick()` æ–¹æ³• ï¼šæ—¶é—´åˆ°è¾¾( **è¶…æ—¶** )æ‰§è¡Œçš„é€»è¾‘ã€‚
* `#getIntervalTimeInMilliseconds()` æ–¹æ³• ï¼šè¿”å›åˆ°è¾¾( **è¶…æ—¶** )æ—¶é—´æ—¶é•¿ã€‚

## 3.3 TimerReference

`com.netflix.hystrix.util.HystrixTimer.TimerReference` ï¼ŒHystrix å®šæ—¶ä»»åŠ¡**å¼•ç”¨**ã€‚ä»£ç å¦‚ä¸‹ ï¼š

```Java
private static class TimerReference extends SoftReference<TimerListener> {

    private final ScheduledFuture<?> f;

    TimerReference(TimerListener referent, ScheduledFuture<?> f) {
        super(referent);
        this.f = f;
    }

    @Override
    public void clear() {
        super.clear();
        // stop this ScheduledFuture from any further executions
        f.cancel(false); // éå¼ºåˆ¶
    }

}
```
* é€šè¿‡ `#clear()` æ–¹æ³•ï¼Œå¯ä»¥å–æ¶ˆå®šæ—¶ä»»åŠ¡çš„æ‰§è¡Œã€‚

# 666. å½©è›‹

![çŸ¥è¯†æ˜Ÿçƒ](http://www.iocoder.cn/images/Architecture/2017_12_29/01.png)

é¡ºç•…~åˆšå¼€å§‹çœ‹ Hystrix æ‰§è¡Œå‘½ä»¤è¶…æ—¶é€»è¾‘ï¼Œä¸€ç›´æƒ³ä¸é€šã€‚ç°åœ¨æ•´ç†å¹²å‡€äº†ã€‚

å–µäº†ä¸ªå’ª~

èƒ–å‹ï¼Œåˆ†äº«ä¸€æ³¢æœ‹å‹åœˆå¯å¥½ï¼


