title: Hystrix æºç è§£æ â€”â€” å‘½ä»¤æ‰§è¡Œï¼ˆä¸€ï¼‰ä¹‹æ­£å¸¸æ‰§è¡Œé€»è¾‘
date: 2018-10-22
tags:
categories: Hystrix
permalink: Hystrix/command-execute-first-run

-------

æ‘˜è¦: åŸåˆ›å‡ºå¤„ http://www.iocoder.cn/Hystrix/command-execute-first-run/ ã€ŒèŠ‹é“æºç ã€æ¬¢è¿è½¬è½½ï¼Œä¿ç•™æ‘˜è¦ï¼Œè°¢è°¢ï¼

**æœ¬æ–‡ä¸»è¦åŸºäº Hystrix 1.5.X ç‰ˆæœ¬**  

- [1. æ¦‚è¿°](http://www.iocoder.cn/Hystrix/command-execute-first-run/)
- [2. #applyHystrixSemantics(...)](http://www.iocoder.cn/Hystrix/command-execute-first-run/)
- [3. TryableSemaphore](http://www.iocoder.cn/Hystrix/command-execute-first-run/)
- [4. #executeCommandAndObserve(...)](http://www.iocoder.cn/Hystrix/command-execute-first-run/)
- [5. #executeCommandWithSpecifiedIsolation(...)](http://www.iocoder.cn/Hystrix/command-execute-first-run/)
- [6. #getUserExecutionObservable(...)](http://www.iocoder.cn/Hystrix/command-execute-first-run/)
- [7. #getExecutionObservable()](http://www.iocoder.cn/Hystrix/command-execute-first-run/)
- [8. CommandState](http://www.iocoder.cn/Hystrix/command-execute-first-run/)
- [9. ThreadState](http://www.iocoder.cn/Hystrix/command-execute-first-run/)
- [666. å½©è›‹](http://www.iocoder.cn/Hystrix/command-execute-first-run/)

-------

![](http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg)

> ğŸ™‚ğŸ™‚ğŸ™‚å…³æ³¨**å¾®ä¿¡å…¬ä¼—å·ï¼šã€èŠ‹é“æºç ã€‘**æœ‰ç¦åˆ©ï¼š  
> 1. RocketMQ / MyCAT / Sharding-JDBC **æ‰€æœ‰**æºç åˆ†ææ–‡ç« åˆ—è¡¨  
> 2. RocketMQ / MyCAT / Sharding-JDBC **ä¸­æ–‡æ³¨é‡Šæºç  GitHub åœ°å€**  
> 3. æ‚¨å¯¹äºæºç çš„ç–‘é—®æ¯æ¡ç•™è¨€**éƒ½**å°†å¾—åˆ°**è®¤çœŸ**å›å¤ã€‚**ç”šè‡³ä¸çŸ¥é“å¦‚ä½•è¯»æºç ä¹Ÿå¯ä»¥è¯·æ•™å™¢**ã€‚  
> 4. **æ–°çš„**æºç è§£ææ–‡ç« **å®æ—¶**æ”¶åˆ°é€šçŸ¥ã€‚**æ¯å‘¨æ›´æ–°ä¸€ç¯‡å·¦å³**ã€‚  
> 5. **è®¤çœŸçš„**æºç äº¤æµå¾®ä¿¡ç¾¤ã€‚

-------

# 1. æ¦‚è¿°

æœ¬æ–‡ä¸»è¦åˆ†äº« **Hystrix å‘½ä»¤æ‰§è¡Œï¼ˆä¸€ï¼‰ä¹‹æ­£å¸¸æ‰§è¡Œé€»è¾‘**ã€‚

å»ºè®® ï¼šå¯¹ RxJava å·²ç»æœ‰ä¸€å®šçš„äº†è§£çš„åŸºç¡€ä¸Šé˜…è¯»æœ¬æ–‡ã€‚

Hystrix æ‰§è¡Œå‘½ä»¤æ•´ä½“æµç¨‹å¦‚ä¸‹å›¾ï¼š

> FROM [ã€Šã€ç¿»è¯‘ã€‘Hystrixæ–‡æ¡£-å®ç°åŸç†ã€‹ã€Œæµç¨‹å›¾ã€](http://youdang.github.io/2016/02/05/translate-hystrix-wiki-how-it-works/#æµç¨‹å›¾)  
> ![](http://www.iocoder.cn/images/Hystrix/2018_10_22/01.jpeg)

* **çº¢**æ¡† ï¼šHystrix å‘½ä»¤æ‰§è¡Œçš„è¿‡ç¨‹ã€‚
* **è“**åœˆ ï¼šæœ¬æ–‡åˆ†äº«çš„éƒ¨åˆ† â€”â€” æ­£å¸¸æ‰§è¡Œé€»è¾‘ã€‚

-------

**æ¨è Spring Cloud ä¹¦ç±**ï¼š

* è¯·æ”¯æŒæ­£ç‰ˆã€‚ä¸‹è½½ç›—ç‰ˆï¼Œ**ç­‰äºä¸»åŠ¨ç¼–å†™ä½çº§ BUG** ã€‚
* ç¨‹åºçŒ¿DD â€”â€” [ã€ŠSpring Cloudå¾®æœåŠ¡å®æˆ˜ã€‹](https://union-click.jd.com/jdc?d=505Twi)
* å‘¨ç«‹ â€”â€” [ã€ŠSpring Cloudä¸Dockerå¾®æœåŠ¡æ¶æ„å®æˆ˜ã€‹](https://union-click.jd.com/jdc?d=k3sAaK)
* ä¸¤ä¹¦é½ä¹°ï¼Œäº¬ä¸œåŒ…é‚®ã€‚

# 2. #applyHystrixSemantics(...)

åœ¨ [ã€ŠHystrix æºç è§£æ â€”â€” æ‰§è¡Œç»“æœç¼“å­˜ã€‹](http://www.iocoder.cn/Hystrix/command-execute-result-cache/?self) é‡Œï¼Œæˆ‘ä»¬çœ‹åˆ° `#toObservable()` æ–¹æ³•é‡Œçš„**ç¬¬ 11 è‡³ 19 è¡Œ**ï¼Œå½“ç¼“å­˜ç‰¹æ€§**æœªå¼€å¯**ï¼Œæˆ–è€…ç¼“å­˜**æœªå‘½ä¸­**æ—¶ï¼Œä½¿ç”¨ `applyHystrixSemantics` ä¼ å…¥ `Observable#defer(...)` æ–¹æ³•ï¼Œå£°æ˜**æ‰§è¡Œå‘½ä»¤**çš„ Observableã€‚

åˆ›å»º `applyHystrixSemantics` å˜é‡ï¼Œä»£ç å¦‚ä¸‹ ï¼š

```Java
// `AbstractCommand#toObservable()` æ–¹æ³•
  1: final Func0<Observable<R>> applyHystrixSemantics = new Func0<Observable<R>>() {
  2:     @Override
  3:     public Observable<R> call() {
  4:         // commandState å¤„äº UNSUBSCRIBED æ—¶ï¼Œä¸æ‰§è¡Œå‘½ä»¤
  5:         if (commandState.get().equals(CommandState.UNSUBSCRIBED)) {
  6:             return Observable.never();
  7:         }
  8:         // è·å¾— æ‰§è¡ŒObservable
  9:         return applyHystrixSemantics(_cmd);
 10:     }
 11: };
```
* ç¬¬ 5 è‡³ 7 è¡Œ ï¼šå½“ `commandState` å¤„äº `UNSUBSCRIBED` æ—¶ï¼Œä¸æ‰§è¡Œå‘½ä»¤ã€‚
* ç¬¬ 9 è¡Œ ï¼šè°ƒç”¨ `#applyHystrixSemantics(...)` æ–¹æ³•ï¼Œè·å¾—æ‰§è¡Œ Observable ã€‚

-------

`#applyHystrixSemantics(...)` æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ ï¼š

```Java
  1: private Observable<R> applyHystrixSemantics(final AbstractCommand<R> _cmd) {
  2:     // TODO ã€2003ã€‘ã€HOOKã€‘
  3:     // mark that we're starting execution on the ExecutionHook
  4:     // if this hook throws an exception, then a fast-fail occurs with no fallback.  No state is left inconsistent
  5:     executionHook.onStart(_cmd);
  6: 
  7:     /* determine if we're allowed to execute */
  8:     if (circuitBreaker.attemptExecution()) {
  9:         // è·å¾— ä¿¡å·é‡
 10:         final TryableSemaphore executionSemaphore = getExecutionSemaphore();
 11: 
 12:         // ä¿¡å·é‡é‡Šæ”¾Action
 13:         final AtomicBoolean semaphoreHasBeenReleased = new AtomicBoolean(false);
 14:         final Action0 singleSemaphoreRelease = new Action0() {
 15:             @Override
 16:             public void call() {
 17:                 if (semaphoreHasBeenReleased.compareAndSet(false, true)) {
 18:                     executionSemaphore.release();
 19:                 }
 20:             }
 21:         };
 22: 
 23:         // TODO ã€2011ã€‘ã€Hystrix äº‹ä»¶æœºåˆ¶ã€‘
 24:         final Action1<Throwable> markExceptionThrown = new Action1<Throwable>() {
 25:             @Override
 26:             public void call(Throwable t) {
 27:                 eventNotifier.markEvent(HystrixEventType.EXCEPTION_THROWN, commandKey);
 28:             }
 29:         };
 30: 
 31:         // ä¿¡å·é‡ è·å¾—
 32:         if (executionSemaphore.tryAcquire()) {
 33:             try {
 34:                 // æ ‡è®° executionResult è°ƒç”¨å¼€å§‹æ—¶é—´
 35:                 /* used to track userThreadExecutionTime */
 36:                 executionResult = executionResult.setInvocationStartTime(System.currentTimeMillis());
 37: 
 38:                 // è·å¾— æ‰§è¡ŒObservable
 39:                 return executeCommandAndObserve(_cmd)
 40:                         .doOnError(markExceptionThrown)
 41:                         .doOnTerminate(singleSemaphoreRelease)
 42:                         .doOnUnsubscribe(singleSemaphoreRelease);
 43:             } catch (RuntimeException e) {
 44:                 return Observable.error(e);
 45:             }
 46:         } else {
 47:             return handleSemaphoreRejectionViaFallback();
 48:         }
 49:     } else {
 50:         return handleShortCircuitViaFallback();
 51:     }
 52: }
```

* ç¬¬ 5 è¡Œ ï¼šTODO ã€2003ã€‘ã€HOOKã€‘
* ç¬¬ 8 è¡Œ ï¼šTODO ã€2012ã€‘ã€é“¾è·¯å¥åº·åº¦ã€‘
* ç¬¬ 10 è¡Œ ï¼šè°ƒç”¨ `#getExecutionSemaphore()` æ–¹æ³•ï¼Œè·å¾—**ä¿¡å·é‡**( TryableSemaphore )å¯¹è±¡ï¼Œåœ¨ [ã€Œ3. TryableSemaphoreã€](#) è¯¦ç»†è§£æã€‚
* ç¬¬ 13 è‡³ 21 è¡Œ ï¼šä¿¡å·é‡é‡Šæ”¾ Action ï¼Œç”¨äºä¸‹é¢ã€æ‰§è¡Œå‘½ä»¤ Observableã€‘çš„ `#doOnTerminate(Action)` å’Œ `#doOnUnsubscribe(Action)` æ–¹æ³•( è§ç¬¬ 41 è‡³ 42 è¡Œ )ã€‚
* ç¬¬ 24 è‡³ 29 è¡Œ ï¼šTODO ã€2011ã€‘ã€Hystrix äº‹ä»¶æœºåˆ¶ã€‘
* ç¬¬ 32 è¡Œ ï¼šè°ƒç”¨ `TryableSemaphore#tryAcquire()` æ–¹æ³•ï¼Œ**ä¿¡å·é‡**( TryableSemaphore )ä½¿ç”¨æˆåŠŸï¼Œåœ¨ [ã€Œ3. TryableSemaphoreã€](#) è¯¦ç»†è§£æã€‚
* ç¬¬ 36 è¡Œ ï¼šæ ‡è®° `executionResult` çš„**è°ƒç”¨**å¼€å§‹æ—¶é—´ã€‚
* ç¬¬ 39 è¡Œ ï¼šè°ƒç”¨ `#executeCommandAndObserve()` æ–¹æ³•ï¼Œè·å¾—ã€æ‰§è¡Œå‘½ä»¤ Observableã€‘ã€‚åœ¨ [ã€Œ4. #executeCommandAndObserve(...)ã€](#) è¯¦ç»†è§£æã€‚
* ç¬¬ 43 è‡³ 45 è¡Œ ï¼šè‹¥å‘ç”Ÿå¼‚å¸¸ï¼Œè°ƒç”¨ `Observable#error(Exception)` æ–¹æ³•è¿”å› Observable ã€‚
* ç¬¬ 46 è‡³ 48 è¡Œ ï¼š**ä¿¡å·é‡**( TryableSemaphore )ä½¿ç”¨å¤±è´¥ï¼Œè°ƒç”¨ `#handleSemaphoreRejectionViaFallback()` æ–¹æ³•ï¼Œå¤„ç†ä¿¡å·é‡æ‹’ç»çš„å¤±è´¥å›é€€é€»è¾‘ï¼Œåœ¨ [ã€ŠHystrix æºç è§£æ â€”â€” å‘½ä»¤æ‰§è¡Œï¼ˆå››ï¼‰ä¹‹å¤±è´¥å›é€€é€»è¾‘ã€‹](TODO ã€2004ã€‘ã€æ‰§è¡Œä¸fallbakã€‘) è¯¦ç»†è§£æã€‚
* ç¬¬ 49 è‡³ 51 è¡Œ ï¼šé“¾è·¯å¤„äº**ç†”æ–­**çŠ¶æ€ï¼Œè°ƒç”¨ `#handleShortCircuitViaFallback()` æ–¹æ³•ï¼Œå¤„ç†é“¾è·¯ç†”æ–­çš„å¤±è´¥å›é€€é€»è¾‘ï¼Œåœ¨ [ã€ŠHystrix æºç è§£æ â€”â€” å‘½ä»¤æ‰§è¡Œï¼ˆå››ï¼‰ä¹‹å¤±è´¥å›é€€é€»è¾‘ã€‹](TODO ã€2004ã€‘ã€æ‰§è¡Œä¸fallbakã€‘) è¯¦ç»†è§£æã€‚

# 3. TryableSemaphore

`com.netflix.hystrix.AbstractCommand.TryableSemaphore` ï¼ŒHystrix å®šä¹‰çš„ä¿¡å·é‡**æ¥å£**ã€‚ä»£ç å¦‚ä¸‹ ï¼š

```Java
interface TryableSemaphore {
    
    boolean tryAcquire();
    
    void release();
    
    int getNumberOfPermitsUsed();
}
```

* ä» API ä¸Šï¼ŒJava è‡ªå¸¦çš„ `java.util.concurrent.Semaphore` éƒ½èƒ½æ»¡è¶³ï¼Œä¸ºä»€ä¹ˆä¸ä½¿ç”¨å®ƒå‘¢ï¼Ÿç»§ç»­ä¸€èµ·å¾€ä¸‹çœ‹ã€‚

TryableSemaphore å…±æœ‰ä¸¤ä¸ªå­ç±»å®ç° ï¼š

* TryableSemaphoreNoOp
* TryableSemaphoreActual

## 3.1 TryableSemaphoreNoOp

`com.netflix.hystrix.AbstractCommand.TryableSemaphoreNoOp` ï¼Œ**æ— æ“ä½œ**çš„ä¿¡å·é‡ã€‚ä»£ç å¦‚ä¸‹ ï¼š

```Java
/* package */static class TryableSemaphoreNoOp implements TryableSemaphore {

    public static final TryableSemaphore DEFAULT = new TryableSemaphoreNoOp();

    @Override
    public boolean tryAcquire() {
        return true;
    }

    @Override
    public void release() {
 
    }

    @Override
    public int getNumberOfPermitsUsed() {
        return 0;
    }

}
```

* ä»å®ç°ä¸Šçœ‹ï¼Œ`#tryAcquire()` æ–¹æ³•ï¼Œæ¯æ¬¡éƒ½è¿”å›çš„æ˜¯ `true` ï¼›`#release()` æ–¹æ³•ï¼Œæ— ä»»ä½•æ“ä½œã€‚è¿™ä¸ªæ˜¯**ä¸ºä»€ä¹ˆ**ï¼Ÿåœ¨ Hystrix é‡Œæä¾›äº†ä¸¤ç§**æ‰§è¡Œéš”ç¦»ç­–ç•¥**  ï¼š
    * `Thread` ï¼Œè¯¥æ–¹å¼ä¸ä½¿ç”¨ä¿¡å·é‡ï¼Œå› æ­¤ä½¿ç”¨ TryableSemaphoreNoOp ï¼Œè¿™æ ·æ¯æ¬¡è°ƒç”¨ `#tryAcquire()` éƒ½èƒ½è¿”å› `true` ã€‚åœ¨ [ã€ŠTODO ã€2004ã€‘ã€æ‰§è¡Œä¸fallbakã€‘ã€‹](TODO ã€2004ã€‘ã€æ‰§è¡Œä¸fallbakã€‘) è¯¦ç»†è§£æè¯¥æ–¹å¼ã€‚
    * `Semaphore` ï¼Œè¯¥æ–¹å¼ä½¿ç”¨ä¿¡å·é‡ï¼Œå› æ­¤ä½¿ç”¨ TryableSemaphoreActual ï¼Œè¿™æ ·æ¯æ¬¡è°ƒç”¨ `#tryAcquire()` æ ¹æ®æƒ…å†µè¿”å› `true / false` ã€‚åœ¨ [ã€Œ3.2 TryableSemaphoreActualã€](#) è¯¦ç»†è§£æã€‚

## 3.2 TryableSemaphoreActual

`com.netflix.hystrix.AbstractCommand.TryableSemaphoreActual` ï¼Œ**çœŸæ­£çš„**çš„ä¿¡å·é‡å®ç°ã€‚ä¸è¿‡å®é™…ä¸Šï¼ŒTryableSemaphoreActual æ›´åŠ åƒä¸€ä¸ª**è®¡æ•°å™¨**ã€‚ä»£ç å¦‚ä¸‹ ï¼š

```Java
/* package */static class TryableSemaphoreActual implements TryableSemaphore {
    protected final HystrixProperty<Integer> numberOfPermits;
    private final AtomicInteger count = new AtomicInteger(0);

    public TryableSemaphoreActual(HystrixProperty<Integer> numberOfPermits) {
        this.numberOfPermits = numberOfPermits;
    }

    @Override
    public boolean tryAcquire() {
        int currentCount = count.incrementAndGet();
        if (currentCount > numberOfPermits.get()) {
            count.decrementAndGet();
            return false;
        } else {
            return true;
        }
    }

    @Override
    public void release() {
        count.decrementAndGet();
    }

    @Override
    public int getNumberOfPermitsUsed() {
        return count.get();
    }

}
```

* `numberOfPermits` å±æ€§ï¼Œä¿¡å·é‡**ä¸Šé™**ã€‚`com.netflix.hystrix.strategy.properties.HystrixProperty` æ˜¯ä¸€ä¸ªæ¥å£ï¼Œå½“å…¶ä½¿ç”¨ç±»ä¼¼ `com.netflix.hystrix.strategy.properties.archaius.IntegerDynamicProperty` **åŠ¨æ€**å±æ€§çš„å®ç°æ—¶ï¼Œå¯ä»¥å®ç°åŠ¨æ€è°ƒæ•´ä¿¡å·é‡çš„**ä¸Šé™**ï¼Œè¿™å°±æ˜¯ä¸Šæ–‡æåˆ°çš„ä¸ºä»€ä¹ˆä¸ä½¿ç”¨ `java.util.concurrent.Semaphore` çš„åŸå› ä¹‹ä¸€ã€‚
* `count` å±æ€§ï¼Œä¿¡å·é‡ä½¿ç”¨æ•°é‡ã€‚ğŸ™‚ï¼Œè¿™æ˜¯ä¸ºä»€ä¹ˆè¯´ TryableSemaphoreActual æ›´åŠ åƒä¸€ä¸ª**è®¡æ•°å™¨** çš„åŸå› ã€‚
* å¦ä¸€ä¸ªä¸ä½¿ç”¨ `java.util.concurrent.Semaphore` çš„åŸå› ï¼ŒTryableSemaphoreActual æ— **é˜»å¡**è·å–ä¿¡å·é‡çš„éœ€æ±‚ï¼Œä½¿ç”¨ AtomicInteger å¯ä»¥è¾¾åˆ°æ›´è½»é‡çº§çš„å®ç°ã€‚

## 3.3 #getExecutionSemaphore()

è°ƒç”¨ `#getExecutionSemaphore()` æ–¹æ³•ï¼Œè·å¾—ä¿¡å·é‡å¯¹è±¡ï¼Œä»£ç å¦‚ä¸‹ ï¼š

```Java
/**
* æ‰§è¡Œå‘½ä»¤ï¼ˆæ­£å¸¸æ‰§è¡Œï¼‰ä¿¡å·é‡æ˜ å°„
* KEY ï¼šå‘½ä»¤å {@link #commandKey}
*/
/* each circuit has a semaphore to restrict concurrent fallback execution */
protected static final ConcurrentHashMap<String, TryableSemaphore> executionSemaphorePerCircuit = new ConcurrentHashMap<String, TryableSemaphore>();
    
protected TryableSemaphore getExecutionSemaphore() {
    if (properties.executionIsolationStrategy().get() == ExecutionIsolationStrategy.SEMAPHORE) {
        if (executionSemaphoreOverride == null) {
            TryableSemaphore _s = executionSemaphorePerCircuit.get(commandKey.name());
            if (_s == null) { // ä¸å­˜åœ¨æ—¶ï¼Œåˆ›å»º TryableSemaphoreActual
                // we didn't find one cache so setup
               executionSemaphorePerCircuit.putIfAbsent(commandKey.name(), new TryableSemaphoreActual(properties.executionIsolationSemaphoreMaxConcurrentRequests()));
                // assign whatever got set (this or another thread)
                return executionSemaphorePerCircuit.get(commandKey.name());
            } else {
                return _s;
            }
        } else {
            return executionSemaphoreOverride;
        }
    } else {
        // return NoOp implementation since we're not using SEMAPHORE isolation
        return TryableSemaphoreNoOp.DEFAULT;
   }
}
```

* æ ¹æ®**æ‰§è¡Œéš”ç¦»ç­–ç•¥**ä¸åŒè·å–ä¸åŒçš„ä¿¡å·é‡å®ç° ï¼š
    * `Thread` ï¼Œè¯¥æ–¹å¼ä¸ä½¿ç”¨ä¿¡å·é‡ï¼Œå› æ­¤ä½¿ç”¨ TryableSemaphoreNoOp ã€‚
    * `Semaphore` ï¼Œè¯¥æ–¹å¼ä½¿ç”¨ä¿¡å·é‡ï¼Œå› æ­¤ä½¿ç”¨ TryableSemaphoreActual ã€‚
        * ç›¸åŒçš„ `commandKey` ï¼Œä½¿ç”¨ç›¸åŒçš„ TryableSemaphoreActual ã€‚

# 4. #executeCommandAndObserve(...)

è°ƒç”¨ `#executeCommandAndObserve(...)` æ–¹æ³•ï¼Œè·å¾—ã€æ‰§è¡Œå‘½ä»¤ Observableã€‘ã€‚ä»£ç å¦‚ä¸‹ ï¼š

```Java
  1: private Observable<R> executeCommandAndObserve(final AbstractCommand<R> _cmd) {
  2:     // TODO ã€ã€‘
  3:     final HystrixRequestContext currentRequestContext = HystrixRequestContext.getContextForCurrentThread();
  4: 
  5:     // TODO ã€2007ã€‘ã€executionResultã€‘ç”¨é€”
  6:     final Action1<R> markEmits = new Action1<R>() {
  7:         @Override
  8:         public void call(R r) {
  9:             if (shouldOutputOnNextEvents()) {
 10:                 executionResult = executionResult.addEvent(HystrixEventType.EMIT);
 11:                 eventNotifier.markEvent(HystrixEventType.EMIT, commandKey);
 12:             }
 13:             if (commandIsScalar()) {
 14:                 long latency = System.currentTimeMillis() - executionResult.getStartTimestamp();
 15:                 eventNotifier.markEvent(HystrixEventType.SUCCESS, commandKey);
 16:                 executionResult = executionResult.addEvent((int) latency, HystrixEventType.SUCCESS);
 17:                 eventNotifier.markCommandExecution(getCommandKey(), properties.executionIsolationStrategy().get(), (int) latency, executionResult.getOrderedList());
 18:                 circuitBreaker.markSuccess();
 19:             }
 20:         }
 21:     };
 22: 
 23:     // TODO ã€2007ã€‘ã€executionResultã€‘ç”¨é€”
 24:     final Action0 markOnCompleted = new Action0() {
 25:         @Override
 26:         public void call() {
 27:             if (!commandIsScalar()) {
 28:                 long latency = System.currentTimeMillis() - executionResult.getStartTimestamp();
 29:                 eventNotifier.markEvent(HystrixEventType.SUCCESS, commandKey);
 30:                 executionResult = executionResult.addEvent((int) latency, HystrixEventType.SUCCESS);
 31:                 eventNotifier.markCommandExecution(getCommandKey(), properties.executionIsolationStrategy().get(), (int) latency, executionResult.getOrderedList());
 32:                 circuitBreaker.markSuccess();
 33:             }
 34:         }
 35:     };
 36: 
 37:     // TODO ã€2004ã€‘ã€æ‰§è¡Œä¸fallbakã€‘
 38:     final Func1<Throwable, Observable<R>> handleFallback = new Func1<Throwable, Observable<R>>() {
 39:         @Override
 40:         public Observable<R> call(Throwable t) {
 41:             circuitBreaker.markNonSuccess();
 42:             Exception e = getExceptionFromThrowable(t);
 43:             executionResult = executionResult.setExecutionException(e);
 44:             if (e instanceof RejectedExecutionException) {
 45:                 return handleThreadPoolRejectionViaFallback(e);
 46:             } else if (t instanceof HystrixTimeoutException) {
 47:                 return handleTimeoutViaFallback();
 48:             } else if (t instanceof HystrixBadRequestException) {
 49:                 return handleBadRequestByEmittingError(e);
 50:             } else {
 51:                 /*
 52:                  * Treat HystrixBadRequestException from ExecutionHook like a plain HystrixBadRequestException.
 53:                  */
 54:                 if (e instanceof HystrixBadRequestException) {
 55:                     eventNotifier.markEvent(HystrixEventType.BAD_REQUEST, commandKey);
 56:                     return Observable.error(e);
 57:                 }
 58: 
 59:                 return handleFailureViaFallback(e);
 60:             }
 61:         }
 62:     };
 63: 
 64:     // TODO ã€2008ã€‘ã€è¯·æ±‚ç¼“å­˜ã€‘
 65:     final Action1<Notification<? super R>> setRequestContext = new Action1<Notification<? super R>>() {
 66:         @Override
 67:         public void call(Notification<? super R> rNotification) {
 68:             setRequestContextIfNeeded(currentRequestContext);
 69:         }
 70:     };
 71: 
 72:     Observable<R> execution;
 73:     if (properties.executionTimeoutEnabled().get()) {
 74:         execution = executeCommandWithSpecifiedIsolation(_cmd)
 75:                 .lift(new HystrixObservableTimeoutOperator<R>(_cmd)); // TODO ã€2009ã€‘ã€æ‰§è¡Œè¶…æ—¶ã€‘
 76:     } else {
 77:         execution = executeCommandWithSpecifiedIsolation(_cmd);
 78:     }
 79: 
 80:     return execution.doOnNext(markEmits)
 81:             .doOnCompleted(markOnCompleted)
 82:             .onErrorResumeNext(handleFallback)
 83:             .doOnEach(setRequestContext);
 84: }
```
* ç¬¬ 3 è¡Œ ï¼šTODO ã€2012ã€‘ã€è¯·æ±‚ä¸Šä¸‹æ–‡ã€‘
* ç¬¬ 6 è‡³ 21 è¡Œ ï¼šTODO ã€2007ã€‘ã€executionResultã€‘ç”¨é€”
* ç¬¬ 24 è‡³ 35 è¡Œ ï¼šTODO ã€2007ã€‘ã€executionResultã€‘ç”¨é€”
* ç¬¬ 38 è‡³ 62 è¡Œ ï¼šTODO ã€2004ã€‘ã€æ‰§è¡Œä¸fallbakã€‘
* ç¬¬ 65 è‡³ 70 è¡Œ ï¼šTODO ã€2012ã€‘ã€è¯·æ±‚ä¸Šä¸‹æ–‡ã€‘
* ç¬¬ 72 è‡³ 78 è¡Œ ï¼šè°ƒç”¨ `#executeCommandWithSpecifiedIsolation(...)` æ–¹æ³•ï¼Œè·å¾—ã€æ‰§è¡Œå‘½ä»¤ Observableã€‘ï¼Œåœ¨ [ã€Œ5. #executeCommandWithSpecifiedIsolation(...)ã€](#) è¯¦ç»†è§£æã€‚
    * è‹¥æ‰§è¡Œå‘½ä»¤è¶…æ—¶ç‰¹æ€§**å¼€å¯**ï¼Œè°ƒç”¨ `Observable#lift(HystrixObservableTimeoutOperator)` æ–¹æ³•ï¼Œå®ç°æ‰§è¡Œå‘½ä»¤è¶…æ—¶åŠŸèƒ½ã€‚åœ¨ [TODO ã€2009ã€‘ã€æ‰§è¡Œè¶…æ—¶ã€‘](#) è¯¦ç»†è§£æã€‚
* ç¬¬ 80 è‡³ 83 è¡Œ ï¼šè¿”å›ã€æ‰§è¡Œå‘½ä»¤ Observableã€‘ã€‚
     
# 5. #executeCommandWithSpecifiedIsolation(...)

è°ƒç”¨ `#executeCommandWithSpecifiedIsolation(...)` æ–¹æ³•ï¼Œè·å¾—ã€æ‰§è¡Œå‘½ä»¤ Observableã€‘ã€‚ä»£ç å¦‚ä¸‹ ï¼š

```Java
  1: private Observable<R> executeCommandWithSpecifiedIsolation(final AbstractCommand<R> _cmd) {
  2:     if (properties.executionIsolationStrategy().get() == ExecutionIsolationStrategy.THREAD) {
  3:         // mark that we are executing in a thread (even if we end up being rejected we still were a THREAD execution and not SEMAPHORE)
  4:         return Observable.defer(new Func0<Observable<R>>() {
  5:             @Override
  6:             public Observable<R> call() {
  7: 
  8:                 // æ ‡è®° executionResult æ‰§è¡Œå·²å‘ç”Ÿ
  9:                 executionResult = executionResult.setExecutionOccurred();
 10: 
 11:                 // è®¾ç½® commandState ä¸º USER_CODE_EXECUTED
 12:                 if (!commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.USER_CODE_EXECUTED)) {
 13:                     return Observable.error(new IllegalStateException("execution attempted while in state : " + commandState.get().name()));
 14:                 }
 15: 
 16:                 // TODO ã€2002ã€‘ã€metricsã€‘
 17:                 metrics.markCommandStart(commandKey, threadPoolKey, ExecutionIsolationStrategy.THREAD);
 18: 
 19:                 // TODO ã€2009ã€‘ã€æ‰§è¡Œè¶…æ—¶ã€‘
 20:                 if (isCommandTimedOut.get() == TimedOutStatus.TIMED_OUT) {
 21:                     // the command timed out in the wrapping thread so we will return immediately
 22:                     // and not increment any of the counters below or other such logic
 23:                     return Observable.error(new RuntimeException("timed out before executing run()"));
 24:                 }
 25: 
 26:                 // è®¾ç½® çº¿ç¨‹çŠ¶æ€ ä¸º ThreadState.STARTED
 27:                 if (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.STARTED)) {
 28:                     // TODO ã€2002ã€‘ã€metricsã€‘
 29:                     //we have not been unsubscribed, so should proceed
 30:                     HystrixCounters.incrementGlobalConcurrentThreads();
 31:                     threadPool.markThreadExecution();
 32: 
 33:                     // TODO ã€2010ã€‘ã€endCurrentThreadExecutingCommandã€‘
 34:                     // store the command that is being run
 35:                     endCurrentThreadExecutingCommand = Hystrix.startCurrentThreadExecutingCommand(getCommandKey());
 36: 
 37:                     // æ ‡è®° executionResult ä½¿ç”¨çº¿ç¨‹æ‰§è¡Œ
 38:                     executionResult = executionResult.setExecutedInThread();
 39:                     /**
 40:                      * If any of these hooks throw an exception, then it appears as if the actual execution threw an error
 41:                      */
 42:                     try {
 43:                         // TODO ã€2003ã€‘ã€HOOKã€‘
 44:                         executionHook.onThreadStart(_cmd);
 45:                         executionHook.onRunStart(_cmd);
 46:                         executionHook.onExecutionStart(_cmd);
 47: 
 48:                         // è·å¾— æ‰§è¡ŒObservable
 49:                         return getUserExecutionObservable(_cmd);
 50:                     } catch (Throwable ex) {
 51:                         return Observable.error(ex);
 52:                     }
 53:                 } else {
 54:                     //command has already been unsubscribed, so return immediately
 55:                     return Observable.empty();
 56:                 }
 57:             }
 58:         }).doOnTerminate(new Action0() {
 59:             @Override
 60:             public void call() {
 61:                 if (threadState.compareAndSet(ThreadState.STARTED, ThreadState.TERMINAL)) {
 62:                     handleThreadEnd(_cmd);
 63:                 }
 64:                 if (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.TERMINAL)) {
 65:                     //if it was never started and received terminal, then no need to clean up (I don't think this is possible)
 66:                 }
 67:                 //if it was unsubscribed, then other cleanup handled it
 68:             }
 69:         }).doOnUnsubscribe(new Action0() {
 70:             @Override
 71:             public void call() {
 72:                 if (threadState.compareAndSet(ThreadState.STARTED, ThreadState.UNSUBSCRIBED)) {
 73:                     handleThreadEnd(_cmd);
 74:                 }
 75:                 if (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.UNSUBSCRIBED)) {
 76:                     //if it was never started and was cancelled, then no need to clean up
 77:                 }
 78:                 //if it was terminal, then other cleanup handled it
 79:             }
 80:         }).subscribeOn(threadPool.getScheduler(new Func0<Boolean>() { // TODO èŠ‹è‰¿ï¼šScheduler
 81:             @Override
 82:             public Boolean call() {
 83:                 return properties.executionIsolationThreadInterruptOnTimeout().get() && _cmd.isCommandTimedOut.get() == TimedOutStatus.TIMED_OUT;
 84:             }
 85:         }));
 86:     } else {
 87:         return Observable.defer(new Func0<Observable<R>>() {
 88:             @Override
 89:             public Observable<R> call() {
 90:                 // æ ‡è®° executionResult æ‰§è¡Œå·²å‘ç”Ÿ
 91:                 executionResult = executionResult.setExecutionOccurred();
 92: 
 93:                 // è®¾ç½® commandState ä¸º USER_CODE_EXECUTED
 94:                 if (!commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.USER_CODE_EXECUTED)) {
 95:                     return Observable.error(new IllegalStateException("execution attempted while in state : " + commandState.get().name()));
 96:                 }
 97: 
 98:                 // TODO ã€2002ã€‘ã€metricsã€‘
 99:                 metrics.markCommandStart(commandKey, threadPoolKey, ExecutionIsolationStrategy.SEMAPHORE);
100: 
101:                 // TODO ã€2010ã€‘ã€endCurrentThreadExecutingCommandã€‘
102:                 // semaphore isolated
103:                 // store the command that is being run
104:                 endCurrentThreadExecutingCommand = Hystrix.startCurrentThreadExecutingCommand(getCommandKey());
105:                 try {
106:                     // TODO ã€2003ã€‘ã€HOOKã€‘
107:                     executionHook.onRunStart(_cmd);
108:                     executionHook.onExecutionStart(_cmd);
109: 
110:                     // è·å¾— æ‰§è¡ŒObservable
111:                     return getUserExecutionObservable(_cmd);  //the getUserExecutionObservable method already wraps sync exceptions, so this shouldn't throw
112:                 } catch (Throwable ex) {
113:                     //If the above hooks throw, then use that as the result of the run method
114:                     return Observable.error(ex);
115:                 }
116:             }
117:         });
118:     }
119: }
```

* æ ¹æ®**æ‰§è¡Œéš”ç¦»ç­–ç•¥**ä¸åŒï¼Œåˆ›å»º**ä¸åŒ**çš„ã€æ‰§è¡Œå‘½ä»¤ Observableã€‘ã€‚ä»”ç»†å¯¹æ¯”ä¸‹ï¼Œå¤§ä½“é€»è¾‘éƒ½æ˜¯ç›¸åŒçš„ï¼Œå·®åˆ«åœ¨äº**æ‰§è¡Œéš”ç¦»ç­–ç•¥**ä¸º `Thread` æ—¶ï¼Œä½¿ç”¨ RxJava Scheduler ä»¥åŠå¯¹**çº¿ç¨‹**çš„å¤„ç†ã€‚
* ç¬¬ 2 è‡³ 85 è¡Œ ï¼š**æ‰§è¡Œéš”ç¦»ç­–ç•¥**ä¸º `Thread` ï¼š
    * ç¬¬ 9 è¡Œ ï¼šæ ‡è®° `executionResult` æ‰§è¡Œå·²å‘ç”Ÿã€‚
    * ç¬¬ 12 è‡³ 14 è¡Œ ï¼šè®¾ç½® `commandState` ä¸º `USER_CODE_EXECUTED` ã€‚è‹¥è®¾ç½®å¤±è´¥ï¼Œè°ƒç”¨ `Observable#error(Exception)` æ–¹æ³•è¿”å› Observable ã€‚ 
    * ç¬¬ 17 è¡Œ ï¼šTODO ã€2002ã€‘ã€metricsã€‘
    * ç¬¬ 20 è‡³ 24 è¡Œ ï¼šTODO ã€2009ã€‘ã€æ‰§è¡Œè¶…æ—¶ã€‘
    * ç¬¬ 27 è¡Œ ï¼šè®¾ç½® `threadState` ä¸º `ThreadState.STARTED` æˆåŠŸã€‚
        * ç¬¬ 30 è‡³ 31 è¡Œ ï¼šTODO ã€2002ã€‘ã€metricsã€‘
        * ç¬¬ 35 è¡Œ ï¼šTODO ã€2010ã€‘ã€endCurrentThreadExecutingCommandã€‘
        * ç¬¬ 38 è¡Œ ï¼šæ ‡è®° `executionResult` ä½¿ç”¨**çº¿ç¨‹**æ‰§è¡Œã€‚
        * ç¬¬ 44 è‡³ 46 è¡Œ ï¼šTODO ã€2003ã€‘ã€HOOKã€‘
        * ç¬¬ 49 è¡Œ ï¼šè°ƒç”¨ `#getUserExecutionObservable(...)` æ–¹æ³•ï¼Œ**åˆ›å»º**ã€æ‰§è¡Œå‘½ä»¤ Observableã€‘ã€‚
        * ç¬¬ 50 è‡³ 52 è¡Œ ï¼šè‹¥å‘ç”Ÿå¼‚å¸¸ï¼Œè°ƒç”¨ `Observable#error(Exception)` æ–¹æ³•è¿”å› Observable ã€‚
    * ç¬¬ 53 è‡³ 56 è¡Œ ï¼šè®¾ç½® `threadState` ä¸º `ThreadState.STARTED` å¤±è´¥ï¼Œæ‰§è¡Œå‘½ä»¤æ­¤æ—¶å·²ç»è¢«**å–æ¶ˆ**ï¼Œè°ƒç”¨ `Observable#empty()` æ–¹æ³•è¿”å› Observable ã€‚
    * ç¬¬ 58 è‡³ 68 è¡Œ ï¼šè°ƒç”¨ `Observable#doOnTerminate(...)` æ–¹æ³•ï¼Œæ·»åŠ  Action0 ã€‚`#handleThreadEnd(...)` æ–¹æ³•ï¼Œç‚¹å‡» [é“¾æ¥](https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L1103) æŸ¥çœ‹ã€‚
    * ç¬¬ 69 è‡³ 79 è¡Œ ï¼šè°ƒç”¨ `Observable#doOnUnsubscribe(...)` æ–¹æ³•ï¼Œæ·»åŠ  Action0 ã€‚
    * ç¬¬ 80 è‡³ 85 è¡Œ ï¼šè°ƒç”¨ `Observable#subscribeOn(Scheduler)` æ–¹æ³•ï¼ŒæŒ‡å®š Observable **è‡ªèº«**åœ¨å“ªä¸ªè°ƒåº¦å™¨ä¸Šæ‰§è¡Œã€‚
        * RxJava Scheduler ï¼Œåœ¨ [ã€ŠRxJava æºç è§£æ â€”â€” Schedulerã€‹](http://www.iocoder.cn/RxJava/observable-subscribe-on-scheduler/?self) æœ‰è¯¦ç»†è§£æã€‚ 
        * `Observable#subscribeOn(Scheduler)` ï¼Œåœ¨ [ã€ŠRxJava æºç è§£æ â€”â€” Observable#subscribeOn(Scheduler)ã€‹](http://www.iocoder.cn/RxJava/observable-subscribe-on-scheduler/?self) æœ‰è¯¦ç»†è§£æã€‚
        * è°ƒç”¨ `ThreadPool#getScheduler(Func0<Boolean>)` æ–¹æ³•ï¼Œè·å¾— Hystrix è‡ªå®šä¹‰å®ç°çš„ RxJava Scheduler ï¼Œåœ¨ [TODO ã€2004ã€‘ã€æ‰§è¡Œä¸fallbakã€‘](#) è¯¦ç»†è§£æã€‚

* ç¬¬ 86 è‡³ 118 è¡Œ ï¼š**æ‰§è¡Œéš”ç¦»ç­–ç•¥**ä¸º `SEMAPHORE` ï¼š
    * ç¬¬ 91 è¡Œ ï¼š[ ä¸ç¬¬ 9 è¡Œ**ç›¸åŒ** ]ã€‚
    * ç¬¬ 94 è‡³ 96 è¡Œ ï¼š[ ä¸ç¬¬ 12 è‡³ 14è¡Œ**ç›¸åŒ** ]ã€‚
    * ç¬¬ 99 è¡Œ ï¼š[ ä¸ç¬¬ 17 è¡Œ**ç±»ä¼¼** ]ã€‚
    * ç¬¬ 104 è¡Œ ï¼š[ ä¸ç¬¬ 35 è¡Œ**ç›¸åŒ** ]ã€‚
    * ç¬¬ 107 è‡³ 108 è¡Œ ï¼š[ ä¸ç¬¬ 45 è‡³ 46 è¡Œ**ç›¸åŒ** ]ã€‚
    * ç¬¬ 111 è¡Œ ï¼š[ ä¸ç¬¬ 49 è¡Œ**ç›¸åŒ** ]ã€‚
    * ç¬¬ 112 è‡³ 115 è¡Œ ï¼š[ ä¸ç¬¬ 50 è‡³ 52 è¡Œ**ç›¸åŒ** ]ã€‚
    
# 6. #getUserExecutionObservable(...)

è°ƒç”¨ `#getUserExecutionObservable(...)` æ–¹æ³•ï¼Œåˆ›å»ºã€æ‰§è¡Œå‘½ä»¤ Observableã€‘ã€‚ä»£ç å¦‚ä¸‹ ï¼š

```Java
  1: private Observable<R> getUserExecutionObservable(final AbstractCommand<R> _cmd) {
  2:     Observable<R> userObservable;
  3: 
  4:     try {
  5:         userObservable = getExecutionObservable();
  6:     } catch (Throwable ex) {
  7:         // the run() method is a user provided implementation so can throw instead of using Observable.onError
  8:         // so we catch it here and turn it into Observable.error
  9:         userObservable = Observable.error(ex);
 10:     }
 11: 
 12:     return userObservable
 13:             .lift(new ExecutionHookApplication(_cmd)) // TODO ã€2003ã€‘ã€HOOKã€‘
 14:             .lift(new DeprecatedOnRunHookApplication(_cmd)); // å·²åºŸå¼ƒ
 15: }
```

* ç¬¬ 5 è¡Œ ï¼šè°ƒç”¨ `#getExecutionObservable()` æ–¹æ³•ï¼Œåˆ›å»ºã€æ‰§è¡Œå‘½ä»¤ Observableã€‘ã€‚`#getExecutionObservable()` æ˜¯ä¸ª**æŠ½è±¡**æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ ï¼š

    ```Java
    protected abstract Observable<R> getExecutionObservable();
    ```
    * HystrixCommand å®ç°äº†è¯¥æ–¹æ³•ï¼Œåœ¨ [ã€Œ7. #getExecutionObservableã€](#) è¯¦ç»†è§£æã€‚

* ç¬¬ 6 è‡³ 10 è¡Œ ï¼šè‹¥å‘ç”Ÿå¼‚å¸¸ï¼Œè°ƒç”¨ `Observable#error(Exception)` æ–¹æ³•è¿”å› Observable ã€‚
* ç¬¬ 12 è‡³ 14 è¡Œ ï¼šè¿”å›ã€æ‰§è¡Œå‘½ä»¤ Observableã€‘ã€‚
    * ç¬¬ 13 è¡Œ ï¼šTODO ã€2003ã€‘ã€HOOKã€‘

# 7. #getExecutionObservable()

è°ƒç”¨ `HystrixCommand#getExecutionObservable()` æ–¹æ³•ï¼Œåˆ›å»ºã€æ‰§è¡Œå‘½ä»¤ Observableã€‘ã€‚ä»£ç å¦‚ä¸‹ ï¼š

```Java
  1: @Override
  2: final protected Observable<R> getExecutionObservable() {
  3:     return Observable.defer(new Func0<Observable<R>>() {
  4:         @Override
  5:         public Observable<R> call() {
  6:             try {
  7:                 return Observable.just(run());
  8:             } catch (Throwable ex) {
  9:                 return Observable.error(ex);
 10:             }
 11:         }
 12:     }).doOnSubscribe(new Action0() {
 13:         @Override
 14:         public void call() {
 15:             // è®°å½• æ‰§è¡Œçº¿ç¨‹
 16:             // Save thread on which we get subscribed so that we can interrupt it later if needed
 17:             executionThread.set(Thread.currentThread());
 18:         }
 19:     });
 20: }
 21: 
 22: protected abstract R run() throws Exception;
```

* ç¬¬ 3 è‡³ 11 è¡Œ ï¼šè°ƒç”¨ `Observable#defer(Func0<Observable<R>)` æ–¹æ³•ï¼Œåˆ›å»ºã€æ‰§è¡Œå‘½ä»¤ Observableã€‘ã€‚
    * ç¬¬ 7 è¡Œ ï¼šè°ƒç”¨ `#run()` æ–¹æ³•ï¼Œ**è¿è¡Œæ­£å¸¸æ‰§é€»è¾‘**ã€‚é€šè¿‡ `Observable#just(...)` æ–¹æ³•ï¼Œè¿”å›åˆ›å»ºã€æ‰§è¡Œå‘½ä»¤ Observableã€‘ã€‚
* ç¬¬ 12 è‡³ 19 è¡Œ ï¼šè°ƒç”¨ `#doOnSubscribe(...)` æ–¹æ³•ï¼Œæ·»åŠ  Action ã€‚è¯¥æ“ä½œè®°å½•æ‰§è¡Œçº¿ç¨‹( `executionThread` ) ã€‚`executionThread` ç”¨äº `HystrixCommand#queue()` æ–¹æ³•ï¼Œè¿”å›çš„ Future ç»“æœï¼Œå¯ä»¥è°ƒç”¨ `Future#cancel(Boolean)` æ–¹æ³•ï¼Œç‚¹å‡» [é“¾æ¥](https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java#L380) æŸ¥çœ‹è¯¥æ–¹æ³•ã€‚
* ç¬¬ 22 è¡Œ ï¼š`#run()` **æŠ½è±¡**æ–¹æ³•ï¼Œå®ç°è¯¥æ–¹æ³•ï¼Œ**è¿è¡Œæ­£å¸¸æ‰§é€»è¾‘**ã€‚

# 8. CommandState

`com.netflix.hystrix.AbstractCommand.CommandState` ï¼Œå‘½ä»¤çŠ¶æ€ï¼Œä»£ç å¦‚ä¸‹ ï¼š

```Java
protected enum CommandState {
    NOT_STARTED, OBSERVABLE_CHAIN_CREATED, USER_CODE_EXECUTED, UNSUBSCRIBED, TERMINAL
}
```

çŠ¶æ€å˜è¿å¦‚ä¸‹å›¾ ï¼š

![](http://www.iocoder.cn/images/Hystrix/2018_10_22/02.png)

# 9. ThreadState

`com.netflix.hystrix.AbstractCommand.ThreadState` ï¼Œçº¿ç¨‹çŠ¶æ€ï¼Œä»£ç å¦‚ä¸‹ ï¼š

```Java
protected enum ThreadState {
   NOT_USING_THREAD, STARTED, UNSUBSCRIBED, TERMINAL
}
```

çŠ¶æ€å˜è¿å¦‚ä¸‹å›¾ ï¼š

![](http://www.iocoder.cn/images/Hystrix/2018_10_22/03.png)

# 666. å½©è›‹

å¯¹ Hystrix å’Œ RxJava æ…¢æ…¢æ›´æœ‰æ„Ÿè§‰äº†ã€‚

æŸ³æš—èŠ±æ˜åˆä¸€æ‘ã€‚

ç»§ç»­åŠ æ²¹ï¼

èƒ–å‹ï¼Œåˆ†äº«ä¸€æ³¢æœ‹å‹åœˆå¯å¥½ï¼


