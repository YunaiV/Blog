title: Hystrix æºç è§£æ â€”â€” å‘½ä»¤åˆå¹¶æ‰§è¡Œ
date: 2018-11-04
tags:
categories: Hystrix
permalink: Hystrix/command-collapser-execute

-------

æ‘˜è¦: åŸåˆ›å‡ºå¤„ http://www.iocoder.cn/Hystrix/command-collapser-execute/ ã€ŒèŠ‹é“æºç ã€æ¬¢è¿è½¬è½½ï¼Œä¿ç•™æ‘˜è¦ï¼Œè°¢è°¢ï¼

**æœ¬æ–‡ä¸»è¦åŸºäº Hystrix 1.5.X ç‰ˆæœ¬**  

- [1. æ¦‚è¿°](http://www.iocoder.cn/Hystrix/command-collapser-execute/)
- [2. HystrixCollapser](http://www.iocoder.cn/Hystrix/command-collapser-execute/)
  - [2.1 æ„é€ æ–¹æ³•](http://www.iocoder.cn/Hystrix/command-collapser-execute/)
  - [2.2 æ‰§è¡Œå‘½ä»¤æ–¹å¼](http://www.iocoder.cn/Hystrix/command-collapser-execute/)
  - [2.3 æ ¸å¿ƒæ–¹æ³•](http://www.iocoder.cn/Hystrix/command-collapser-execute/)
- [3. RequestCollapserFactory](http://www.iocoder.cn/Hystrix/command-collapser-execute/)
- [4. RequestCollapser](http://www.iocoder.cn/Hystrix/command-collapser-execute/)
  - [4.1 æ„é€ æ–¹æ³•](http://www.iocoder.cn/Hystrix/command-collapser-execute/)
  - [4.2 RequestBatch](http://www.iocoder.cn/Hystrix/command-collapser-execute/)
  - [4.3 #submitRequest(arg)](http://www.iocoder.cn/Hystrix/command-collapser-execute/)
  - [4.4 #createNewBatchAndExecutePreviousIfNeeded(previousBatch)](http://www.iocoder.cn/Hystrix/command-collapser-execute/)
- [5. CollapserTimer](http://www.iocoder.cn/Hystrix/command-collapser-execute/)
  - [5.1 RealCollapserTimer](http://www.iocoder.cn/Hystrix/command-collapser-execute/)
  - [5.2 CollapsedTask](http://www.iocoder.cn/Hystrix/command-collapser-execute/)
- [666. å½©è›‹](http://www.iocoder.cn/Hystrix/command-collapser-execute/)

-------

![](http://www.iocoder.cn/images/common/wechat_mp_2018_05_18.jpg)

> ğŸ™‚ğŸ™‚ğŸ™‚å…³æ³¨**å¾®ä¿¡å…¬ä¼—å·ï¼šã€èŠ‹é“æºç ã€‘**æœ‰ç¦åˆ©ï¼š  
> 1. RocketMQ / MyCAT / Sharding-JDBC **æ‰€æœ‰**æºç åˆ†ææ–‡ç« åˆ—è¡¨  
> 2. RocketMQ / MyCAT / Sharding-JDBC **ä¸­æ–‡æ³¨é‡Šæºç  GitHub åœ°å€**  
> 3. æ‚¨å¯¹äºæºç çš„ç–‘é—®æ¯æ¡ç•™è¨€**éƒ½**å°†å¾—åˆ°**è®¤çœŸ**å›å¤ã€‚**ç”šè‡³ä¸çŸ¥é“å¦‚ä½•è¯»æºç ä¹Ÿå¯ä»¥è¯·æ•™å™¢**ã€‚  
> 4. **æ–°çš„**æºç è§£ææ–‡ç« **å®æ—¶**æ”¶åˆ°é€šçŸ¥ã€‚**æ¯å‘¨æ›´æ–°ä¸€ç¯‡å·¦å³**ã€‚  
> 5. **è®¤çœŸçš„**æºç äº¤æµå¾®ä¿¡ç¾¤ã€‚

-------

# 1. æ¦‚è¿°

æœ¬æ–‡ä¸»è¦åˆ†äº« **Hystrix å‘½ä»¤åˆå¹¶æ‰§è¡Œ**ã€‚

åœ¨ [ã€Šã€ç¿»è¯‘ã€‘Hystrixæ–‡æ¡£-å®ç°åŸç†ã€‹ã€Œè¯·æ±‚åˆå¹¶ã€](http://youdang.github.io/2016/02/05/translate-hystrix-wiki-how-it-works/#è¯·æ±‚åˆå¹¶) ä¸­ï¼Œå¯¹ Hystrix å‘½ä»¤åˆå¹¶æ‰§è¡Œçš„**æ¦‚å¿µ**ã€**åŸç†**ã€**ä½¿ç”¨åœºæ™¯**ã€**ä¼˜ç¼ºç‚¹**å·²ç»åšäº†éå¸¸è¯¦ç»†é€å½»çš„åˆ†äº«ï¼Œæ‰€ä»¥èƒ–å‹å¯ä»¥å…ˆè®¤çœŸé˜…è¯»å­¦ä¹ ä¸‹ã€‚

å‘½ä»¤åˆå¹¶æ‰§è¡Œæ•´ä½“æµç¨‹å¦‚ä¸‹å›¾ ï¼š

> FROM [ã€Šã€ç¿»è¯‘ã€‘Hystrixæ–‡æ¡£-å®ç°åŸç†ã€‹ã€Œè¯·æ±‚åˆå¹¶ã€](http://youdang.github.io/2016/02/05/translate-hystrix-wiki-how-it-works/#è¯·æ±‚åˆå¹¶)  
> ![](http://www.iocoder.cn/images/Hystrix/2018_11_04/01.jpeg)

* ç¬¬ä¸€æ­¥ï¼Œæäº¤**å•ä¸ª**å‘½ä»¤è¯·æ±‚åˆ°è¯·æ±‚é˜Ÿåˆ—( RequestQueue )
* ç¬¬äºŒéƒ¨ï¼Œå®šæ—¶ä»»åŠ¡( TimerTask ) **å›ºå®šå‘¨æœŸ**ä»è¯·æ±‚é˜Ÿåˆ—è·å–**å¤šä¸ª**å‘½ä»¤æ‰§è¡Œï¼Œåˆå¹¶æ‰§è¡Œã€‚

åœ¨å®˜æ–¹æä¾›çš„ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡ [CommandCollapserGetValueForKey](https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-examples/src/main/java/com/netflix/hystrix/examples/basic/CommandCollapserGetValueForKey.java) ç†Ÿæ‚‰å‘½ä»¤åˆå¹¶æ‰§è¡Œçš„ä½¿ç”¨ã€‚

-------

**æ¨è Spring Cloud ä¹¦ç±**ï¼š

* è¯·æ”¯æŒæ­£ç‰ˆã€‚ä¸‹è½½ç›—ç‰ˆï¼Œ**ç­‰äºä¸»åŠ¨ç¼–å†™ä½çº§ BUG** ã€‚
* ç¨‹åºçŒ¿DD â€”â€” [ã€ŠSpring Cloudå¾®æœåŠ¡å®æˆ˜ã€‹](https://union-click.jd.com/jdc?d=505Twi)
* å‘¨ç«‹ â€”â€” [ã€ŠSpring Cloudä¸Dockerå¾®æœåŠ¡æ¶æ„å®æˆ˜ã€‹](https://union-click.jd.com/jdc?d=k3sAaK)
* ä¸¤ä¹¦é½ä¹°ï¼Œäº¬ä¸œåŒ…é‚®ã€‚



# 2. HystrixCollapser

`com.netflix.hystrix.HystrixCollapser` ï¼Œ**å‘½ä»¤**åˆå¹¶å™¨**æŠ½è±¡çˆ¶ç±»**ã€‚

> NOTE ï¼š`com.netflix.hystrix.HystrixObservableCollapser` ï¼Œ**å¦ä¸€ç§**å‘½ä»¤åˆå¹¶å™¨**æŠ½è±¡çˆ¶ç±»**ï¼Œæœ¬æ–‡æš‚ä¸è§£æã€‚

## 2.1 æ„é€ æ–¹æ³•

HystrixCollapser **æ„é€ æ–¹æ³•**ï¼Œä»£ç å¦‚ä¸‹ ï¼š

```Java
public abstract class HystrixCollapser<BatchReturnType, ResponseType, RequestArgumentType>
        implements HystrixExecutable<ResponseType>, HystrixObservable<ResponseType> {

    private final RequestCollapserFactory<BatchReturnType, ResponseType, RequestArgumentType> collapserFactory;
    private final HystrixRequestCache requestCache;
    private final HystrixCollapserBridge<BatchReturnType, ResponseType, RequestArgumentType> collapserInstanceWrapper;
    private final HystrixCollapserMetrics metrics;
    
    /* package for tests */ HystrixCollapser(HystrixCollapserKey collapserKey, Scope scope, CollapserTimer timer, HystrixCollapserProperties.Setter propertiesBuilder, HystrixCollapserMetrics metrics) {
        if (collapserKey == null || collapserKey.name().trim().equals("")) {
            String defaultKeyName = getDefaultNameFromClass(getClass());
            collapserKey = HystrixCollapserKey.Factory.asKey(defaultKeyName);
        }

        HystrixCollapserProperties properties = HystrixPropertiesFactory.getCollapserProperties(collapserKey, propertiesBuilder);
        this.collapserFactory = new RequestCollapserFactory<BatchReturnType, ResponseType, RequestArgumentType>(collapserKey, scope, timer, properties);
        this.requestCache = HystrixRequestCache.getInstance(collapserKey, HystrixPlugins.getInstance().getConcurrencyStrategy());

        if (metrics == null) {
            this.metrics = HystrixCollapserMetrics.getInstance(collapserKey, properties);
        } else {
            this.metrics = metrics;
        }

        final HystrixCollapser<BatchReturnType, ResponseType, RequestArgumentType> self = this;

         /* strategy: HystrixMetricsPublisherCollapser */
        HystrixMetricsPublisherFactory.createOrRetrievePublisherForCollapser(collapserKey, this.metrics, properties);

        /**
         * Used to pass public method invocation to the underlying implementation in a separate package while leaving the methods 'protected' in this class.
         */
        collapserInstanceWrapper = new HystrixCollapserBridge<BatchReturnType, ResponseType, RequestArgumentType>() {

            @Override
            public Collection<Collection<CollapsedRequest<ResponseType, RequestArgumentType>>> shardRequests(Collection<CollapsedRequest<ResponseType, RequestArgumentType>> requests) {
                Collection<Collection<CollapsedRequest<ResponseType, RequestArgumentType>>> shards = self.shardRequests(requests);
                self.metrics.markShards(shards.size());
                return shards;
            }

            @Override
            public Observable<BatchReturnType> createObservableCommand(Collection<CollapsedRequest<ResponseType, RequestArgumentType>> requests) {
                final HystrixCommand<BatchReturnType> command = self.createCommand(requests);

                command.markAsCollapsedCommand(this.getCollapserKey(), requests.size());
                self.metrics.markBatch(requests.size());

                return command.toObservable();
            }

            @Override
            public Observable<Void> mapResponseToRequests(Observable<BatchReturnType> batchResponse, final Collection<CollapsedRequest<ResponseType, RequestArgumentType>> requests) {
                return batchResponse.single().doOnNext(new Action1<BatchReturnType>() {
                    @Override
                    public void call(BatchReturnType batchReturnType) {
                        // this is a blocking call in HystrixCollapser
                        self.mapResponseToRequests(batchReturnType, requests);
                    }
                }).ignoreElements().cast(Void.class);
            }

            @Override
            public HystrixCollapserKey getCollapserKey() {
                return self.getCollapserKey();
            }

        };
    }
    
}
```

* BatchReturnType **æ³›å‹**ï¼Œ**å¤šä¸ª**å‘½ä»¤åˆå¹¶æ‰§è¡Œè¿”å›ç»“æœç±»å‹ã€‚
* ResponseType **æ³›å‹**ï¼Œ**å•ä¸ª**å‘½ä»¤æ‰§è¡Œè¿”å›ç»“æœç±»å‹ã€‚
* RequestArgumentType **æ³›å‹**ï¼Œ**å•ä¸ª**å‘½ä»¤å‚æ•°ç±»å‹ã€‚
* `collapserFactory` å±æ€§ï¼ŒRequestCollapser **å·¥å‚**ï¼Œåœ¨ [ã€Œ3. RequestCollapserFactoryã€](#) è¯¦ç»†è§£æã€‚
* `requestCache` å±æ€§ï¼ŒTODO ã€2012ã€‘ã€è¯·æ±‚ä¸Šä¸‹æ–‡ã€‘
* `collapserInstanceWrapper` å±æ€§ï¼Œ**å‘½ä»¤**åˆå¹¶å™¨åŒ…è£…å™¨ã€‚
    * `com.netflix.hystrix.collapser.HystrixCollapserBridge` **æ¥å£**ï¼Œç‚¹å‡» [é“¾æ¥](https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/collapser/HystrixCollapserBridge.java) æŸ¥çœ‹ä»£ç ã€‚
    * HystrixCollapserBridge ï¼Œä¸º RequestBatch **é€æ˜**è°ƒç”¨ HystrixCollapser æˆ– HystrixObservableCollapser çš„æ–¹æ³•ä¸åŒçš„å®ç°ã€‚å‚è§ [ã€Šæ¡¥æ¥æ¨¡å¼ã€‹](http://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/bridge.html) ã€‚
* `metrics` å±æ€§ï¼ŒTODO ã€2002ã€‘ã€metricsã€‘

## 2.2 æ‰§è¡Œå‘½ä»¤æ–¹å¼

åœ¨ [ã€ŠHystrix æºç è§£æ â€”â€” æ‰§è¡Œå‘½ä»¤æ–¹å¼ã€‹](http://www.iocoder.cn/Hystrix/command-execute-mode/?self) ä¸­ï¼Œæˆ‘ä»¬å·²ç»çœ‹äº† HystrixCommand æä¾›çš„**å››ç§**æ‰§è¡Œå‘½ä»¤æ–¹å¼ã€‚

HystrixCollapser ç±»ä¼¼äº HystrixCommand ï¼Œä¹Ÿæä¾›**å››ç§**ç›¸åŒçš„æ‰§è¡Œå‘½ä»¤æ–¹å¼ï¼Œå…¶ä¸­å¦‚ä¸‹ä¸‰ç§æ–¹å¼ä»£ç åŸºæœ¬**ç±»ä¼¼**ï¼Œæˆ‘ä»¬å°±ç»™ä¸‹**ä¼ é€é—¨**ï¼Œå°±ä¸é‡å¤å•°å—¦äº† ï¼š

* `#observe()` æ–¹æ³• ï¼š[ä¼ é€é—¨](https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java#L336) ã€‚
* `#queue()` æ–¹æ³• ï¼š[ä¼ é€é—¨](https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java#L456) ã€‚
* `#execute()` æ–¹æ³• ï¼š[ä¼ é€é—¨](https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java#L426) ã€‚

ä¸‹é¢ä¸€èµ·æ¥çœ‹çœ‹ `#toObservable()` æ–¹æ³•çš„å®ç°ï¼Œä»£ç å¦‚ä¸‹ ï¼š

```Java
  1: public Observable<ResponseType> toObservable() {
  2:     // when we callback with the data we want to do the work
  3:     // on a separate thread than the one giving us the callback
  4:     return toObservable(Schedulers.computation());
  5: }
  6: 
  7: public Observable<ResponseType> toObservable(Scheduler observeOn) {
  8:     return Observable.defer(new Func0<Observable<ResponseType>>() {
  9:         @Override
 10:         public Observable<ResponseType> call() {
 11:             // // ç¼“å­˜å¼€å…³ã€ç¼“å­˜KEY
 12:             final boolean isRequestCacheEnabled = getProperties().requestCacheEnabled().get();
 13:             final String cacheKey = getCacheKey();
 14: 
 15:             // ä¼˜å…ˆä»ç¼“å­˜ä¸­è·å–
 16:             /* try from cache first */
 17:             if (isRequestCacheEnabled) {
 18:                 HystrixCachedObservable<ResponseType> fromCache = requestCache.get(cacheKey);
 19:                 if (fromCache != null) {
 20:                     metrics.markResponseFromCache();
 21:                     return fromCache.toObservable();
 22:                 }
 23:             }
 24: 
 25:             // è·å¾— RequestCollapser
 26:             RequestCollapser<BatchReturnType, ResponseType, RequestArgumentType> requestCollapser = collapserFactory.getRequestCollapser(collapserInstanceWrapper);
 27: 
 28:             // æäº¤ å‘½ä»¤è¯·æ±‚
 29:             Observable<ResponseType> response = requestCollapser.submitRequest(getRequestArgument());
 30: 
 31:             // è·å¾— ç¼“å­˜Observable
 32:             if (isRequestCacheEnabled && cacheKey != null) {
 33:                 HystrixCachedObservable<ResponseType> toCache = HystrixCachedObservable.from(response);
 34:                 HystrixCachedObservable<ResponseType> fromCache = requestCache.putIfAbsent(cacheKey, toCache);
 35:                 if (fromCache == null) {
 36:                     return toCache.toObservable();
 37:                 } else {
 38:                     toCache.unsubscribe(); // å–æ¶ˆè®¢é˜…
 39:                     return fromCache.toObservable();
 40:                 }
 41:             }
 42: 
 43:             // è·å¾— éç¼“å­˜Observable
 44:             return response;
 45:         }
 46:     });
 47: }
```
* `observeOn` æ–¹æ³•å‚æ•°ï¼Œå®é™…æ–¹æ³•æš‚æœªç”¨åˆ°ï¼Œè·³è¿‡æ— è§†ã€‚
* ç¬¬ 11 è‡³ 13 è¡Œ ï¼šç¼“å­˜å­˜å¼€å…³ã€KEY ã€‚
* ã€*åå‘*ã€‘ç¬¬ 32 è‡³ 41 è¡Œ ï¼šè·å¾—ã€ç¼“å­˜ Observableã€‘ã€‚è¿™å—ä»£ç å’Œ `AbstractCommand#toObservavle(...)` ç±»ä¼¼ï¼Œåœ¨ [ã€ŠHystrix æºç è§£æ â€”â€” æ‰§è¡Œç»“æœç¼“å­˜ã€‹ã€Œ4. AbstractCommand#toObservavle(...)ã€](http://www.iocoder.cn/Hystrix/command-execute-result-cache/?self) æœ‰è¯¦ç»†è§£æã€‚
* ã€*åå‘*ã€‘ç¬¬ 44 è¡Œ ï¼šè·å¾—ã€éç¼“å­˜ Observableã€‘ã€‚
* æ³¨æ„ ï¼šè¿”å›çš„ Observable ï¼Œå¾ˆå¯èƒ½å‘½ä»¤å®é™…å¹¶æœªæ‰§è¡Œï¼Œæˆ–è€…è¯´å¹¶æœªæ‰§è¡Œå®Œæˆï¼Œæ­¤æ—¶åœ¨ `#queue()` / `#execute()` æ–¹æ³•ï¼Œé€šè¿‡ BlockingObservable **é˜»å¡**ç­‰å¾…æ‰§è¡Œå®Œæˆã€‚BlockingObservable åœ¨ [ã€ŠRxJava æºç è§£æ â€”â€” BlockingObservableã€‹](http://www.iocoder.cn/RxJava/blocking-observable/?self) æœ‰è¯¦ç»†è§£æã€‚
* ç¬¬ 26 è¡Œ ï¼šè°ƒç”¨ `RequestCollapserFactory#getRequestCollapser()` ï¼Œè·å¾— RequestCollapser ã€‚åœ¨ [ã€Œ3. RequestCollapserFactoryã€](#) è¯¦ç»†è§£æã€‚
* ç¬¬ 29 è¡Œ ï¼šæäº¤**å•ä¸ª**å‘½ä»¤è¯·æ±‚åˆ°è¯·æ±‚é˜Ÿåˆ—( RequestQueue )ï¼Œå³**å‘½ä»¤åˆå¹¶æ‰§è¡Œæ•´ä½“æµç¨‹ç¬¬ä¸€æ­¥**ã€‚åœ¨ [ã€Œ4. RequestCollapserã€](#) è¯¦ç»†è§£æã€‚

## 2.3 æ ¸å¿ƒæ–¹æ³•

* `#getRequestArgument(...)` **æŠ½è±¡**æ–¹æ³•ï¼Œè·å¾—**å•ä¸ª**å‘½ä»¤å‚æ•°ã€‚ä»£ç å¦‚ä¸‹ ï¼š

    ```Java
    public abstract RequestArgumentType getRequestArgument();
    ```

-------

* `#createCommand(...)` **æŠ½è±¡**æ–¹æ³•ï¼Œå°†**å¤šä¸ª**å‘½ä»¤è¯·æ±‚**åˆå¹¶**ï¼Œåˆ›å»º**ä¸€ä¸ª** HystrixCommand ã€‚ä»£ç å¦‚ä¸‹ ï¼š 

    ```Java
    protected abstract HystrixCommand<BatchReturnType> createCommand(Collection<CollapsedRequest<ResponseType, RequestArgumentType>> requests);
    ```

-------

* `#mapResponseToRequests(...)` **æŠ½è±¡**æ–¹æ³•ï¼Œå°†**ä¸€ä¸ª** HystrixCommand çš„æ‰§è¡Œç»“æœï¼Œ**æ˜ å°„**å›å¯¹åº”çš„å‘½ä»¤è¯·æ±‚ä»¬ã€‚

    ```Java
    protected abstract void mapResponseToRequests(BatchReturnType batchResponse, Collection<CollapsedRequest<ResponseType, RequestArgumentType>> requests);
    ```

-------

* `#shardRequests(...)` æ–¹æ³•ï¼Œå°†**å¤šä¸ª**å‘½ä»¤è¯·æ±‚**åˆ†ç‰‡**æˆ **N** ä¸ªã€**å¤šä¸ª**å‘½ä»¤è¯·æ±‚ã€‘ã€‚é»˜è®¤å®ç°ä¸‹ï¼Œä¸è¿›è¡Œåˆ†ç‰‡ã€‚ä»£ç å¦‚ä¸‹ ï¼š 

    ```Java
    protected Collection<Collection<CollapsedRequest<ResponseType, RequestArgumentType>>> shardRequests(Collection<CollapsedRequest<ResponseType, RequestArgumentType>> requests) {
        return Collections.singletonList(requests);
    }
    ```

-------

* åœ¨**æœªé‡å†™** `#shardRequests(...)` çš„æƒ…å†µä¸‹ï¼Œæ•´ä½“æ–¹æ³•æµç¨‹å¦‚ä¸‹ ï¼š

    ![](http://www.iocoder.cn/images/Hystrix/2018_11_04/02.png)

* åœ¨**é‡å†™** `#shardRequests(...)` çš„æƒ…å†µä¸‹ï¼Œæ•´ä½“æ–¹æ³•æµç¨‹å¦‚ä¸‹ ï¼š

    ![](http://www.iocoder.cn/images/Hystrix/2018_11_04/03.png)
    
    * æœ¬å›¾ä¸­å‘½ä»¤è¯·æ±‚åˆ†ç‰‡ä»…ä»…æ˜¯ä¾‹å­ï¼Œå®é™…æ ¹æ®é‡å†™çš„é€»è¾‘ä¸åŒè€Œä¸åŒã€‚

# 3. RequestCollapserFactory

`com.netflix.hystrix.collapser.RequestCollapserFactory` ï¼ŒRequestCollapser **å·¥å‚**ã€‚



```Java
public class RequestCollapserFactory<BatchReturnType, ResponseType, RequestArgumentType> {
    
    private final CollapserTimer timer;
    private final HystrixCollapserKey collapserKey;
    private final HystrixCollapserProperties properties;
    private final HystrixConcurrencyStrategy concurrencyStrategy;
    private final Scope scope;
    
    public RequestCollapserFactory(HystrixCollapserKey collapserKey, Scope scope, CollapserTimer timer, HystrixCollapserProperties properties) {
         /* strategy: ConcurrencyStrategy */
        this.concurrencyStrategy = HystrixPlugins.getInstance().getConcurrencyStrategy();
        this.timer = timer;
        this.scope = scope;
        this.collapserKey = collapserKey;
        this.properties = properties;
    }
```

* `timer` å±æ€§ï¼Œå‘½ä»¤åˆå¹¶å™¨çš„å®šæ—¶å™¨ï¼Œåœ¨ [ã€Œ5. CollapserTimerã€](#) è¯¦ç»†è§£æã€‚
* `collapserKey` å±æ€§ï¼Œå‘½ä»¤åˆå¹¶å™¨æ ‡è¯†ï¼Œå®ç°ç±»ä¼¼ HystrixThreadPoolKey ã€‚
    * HystrixCollapserKey ï¼Œç‚¹å‡» [é“¾æ¥](https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapserKey.java) æŸ¥çœ‹ä»£ç ã€‚
    * HystrixThreadPoolKey ï¼Œåœ¨ [ã€ŠHystrix æºç è§£æ â€”â€” å‘½ä»¤æ‰§è¡Œï¼ˆäºŒï¼‰ä¹‹æ‰§è¡Œéš”ç¦»ç­–ç•¥ã€‹ã€Œ3. HystrixThreadPoolKeyã€](http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/?self) æœ‰è¯¦ç»†è§£æã€‚
* `properties` å±æ€§ï¼Œå‘½ä»¤åˆå¹¶å™¨å±æ€§é…ç½®ã€‚
* `concurrencyStrategy` å±æ€§ï¼Œå¹¶å‘ç­–ç•¥ï¼Œåœ¨ [ã€ŠHystrix æºç è§£æ â€”â€” å‘½ä»¤æ‰§è¡Œï¼ˆäºŒï¼‰ä¹‹æ‰§è¡Œéš”ç¦»ç­–ç•¥ã€‹ã€Œ4. HystrixConcurrencyStrategyã€](http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/?self) æœ‰è¯¦ç»†è§£æã€‚
* `scope` å±æ€§ï¼Œå‘½ä»¤è¯·æ±‚ä½œç”¨åŸŸã€‚ç›®å‰æœ‰ä¸¤ç§ä½œç”¨åŸŸ ï¼š
    * `REQUEST` ï¼šè¯·æ±‚ä¸Šä¸‹æ–‡( HystrixRequestContext )ã€‚

        > Typically this means that requests within a single user-request (ie. HTTP request) are collapsed.   
        > No interaction with other user requests.   
        > 1 queue per user request.
    * `GLOBAL` ï¼šå…¨å±€ã€‚

        > Requests from any thread (ie. all HTTP requests) within the JVM will be collapsed.   
        > 1 queue for entire app.

-------

è°ƒç”¨ `#getRequestCollapser()` æ–¹æ³•ï¼Œè·å¾— RequestCollapser ã€‚ä»£ç å¦‚ä¸‹ ï¼š

```Java
public RequestCollapser<BatchReturnType, ResponseType, RequestArgumentType> getRequestCollapser(HystrixCollapserBridge<BatchReturnType, ResponseType, RequestArgumentType> commandCollapser) {
   if (Scopes.REQUEST == Scopes.valueOf(getScope().name())) {
       return getCollapserForUserRequest(commandCollapser);
   } else if (Scopes.GLOBAL == Scopes.valueOf(getScope().name())) {
       return getCollapserForGlobalScope(commandCollapser);
   } else {
       logger.warn("Invalid Scope: {}  Defaulting to REQUEST scope.", getScope());
       return getCollapserForUserRequest(commandCollapser);
   }
}
```

* æ ¹æ® `scope` ä¸åŒï¼Œè°ƒç”¨ä¸¤ä¸ªä¸åŒæ–¹æ³•ï¼Œè·å¾— RequestCollapser ã€‚è¿™ä¸¤ä¸ªæ–¹æ³•å¤§ä½“é€»è¾‘ç›¸åŒï¼Œä¼˜å…ˆä»**ç¼“å­˜**ä¸­æŸ¥æ‰¾æ»¡è¶³æ¡ä»¶çš„ RequestCollapser è¿”å›ï¼›è‹¥ä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºæ»¡è¶³æ¡ä»¶çš„ RequestCollapser æ·»åŠ åˆ°**ç¼“å­˜**å¹¶è¿”å›ã€‚
    * `REQUEST` ï¼šè°ƒç”¨ `#getCollapserForUserRequest()` æ–¹æ³•ï¼ŒTODO ã€2012ã€‘ã€è¯·æ±‚ä¸Šä¸‹æ–‡ã€‘ã€‚
    * `GLOBAL` ï¼šè°ƒç”¨ `#getCollapserForGlobalScope()` æ–¹æ³•ï¼Œç‚¹å‡» [é“¾æ¥](https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestCollapserFactory.java#L97) æŸ¥çœ‹**ä¸­æ–‡æ³¨é‡Š**çš„ä»£ç ã€‚

# 4. RequestCollapser

`com.netflix.hystrix.collapser.RequestCollapser` ï¼Œ**å‘½ä»¤è¯·æ±‚**åˆå¹¶å™¨ã€‚ä¸»è¦ç”¨äº ï¼š

* æäº¤**å•ä¸ª**å‘½ä»¤è¯·æ±‚åˆ°è¯·æ±‚é˜Ÿåˆ—( RequestQueue )ã€‚
* æ¥æ”¶**æ¥è‡ªå®šæ—¶ä»»åŠ¡**æäº¤çš„**å¤šä¸ª**å‘½ä»¤ï¼Œåˆå¹¶æ‰§è¡Œã€‚

## 4.1 æ„é€ æ–¹æ³•

RequestCollapser **æ„é€ æ–¹æ³•**ï¼Œä»£ç å¦‚ä¸‹ ï¼š

```Java
public class RequestCollapser<BatchReturnType, ResponseType, RequestArgumentType> {

    private final HystrixCollapserBridge<BatchReturnType, ResponseType, RequestArgumentType> commandCollapser;
    // batch can be null once shutdown
    private final AtomicReference<RequestBatch<BatchReturnType, ResponseType, RequestArgumentType>> batch = new AtomicReference<RequestBatch<BatchReturnType, ResponseType, RequestArgumentType>>();
    private final AtomicReference<Reference<TimerListener>> timerListenerReference = new AtomicReference<Reference<TimerListener>>();
    private final AtomicBoolean timerListenerRegistered = new AtomicBoolean();
    private final CollapserTimer timer;
    private final HystrixCollapserProperties properties;
    private final HystrixConcurrencyStrategy concurrencyStrategy;
    
    RequestCollapser(HystrixCollapserBridge<BatchReturnType, ResponseType, RequestArgumentType> commandCollapser, HystrixCollapserProperties properties, CollapserTimer timer, HystrixConcurrencyStrategy concurrencyStrategy) {
        this.commandCollapser = commandCollapser; // the command with implementation of abstract methods we need 
        this.concurrencyStrategy = concurrencyStrategy;
        this.properties = properties;
        this.timer = timer;
        batch.set(new RequestBatch<BatchReturnType, ResponseType, RequestArgumentType>(properties, commandCollapser, properties.maxRequestsInBatch().get()));
    }

}
```

* `commandCollapser` å±æ€§ï¼Œ**å‘½ä»¤**åˆå¹¶å™¨åŒ…è£…å™¨ã€‚
* `batch` å±æ€§ï¼ŒRequestBatchï¼Œ**å³æ˜¯æœ¬æ–‡ä¸€ç›´è¯´çš„è¯·æ±‚é˜Ÿåˆ—**ã€‚åœ¨ [ã€Œ4.2 RequestBatchã€](#) ä¹Ÿä¼šè¯¦ç»†è§£æã€‚
* `timerListenerReference` å±æ€§ï¼Œ**æ³¨å†Œ**åœ¨å‘½ä»¤åˆå¹¶å™¨çš„å®šæ—¶å™¨çš„ç›‘å¬å™¨ã€‚æ¯ä¸ª  RequestCollapser **ç‹¬æœ‰ä¸€ä¸ª**ç›‘å¬å™¨ã€‚è¯¥ç›‘å¬å™¨( å®é™…ä¸Šä¼šä½¿ç”¨è¯¥ç›‘å¬å™¨åˆ›å»ºå®šæ—¶ä»»åŠ¡ )**å›ºå®šå‘¨æœŸ**ä»è¯·æ±‚é˜Ÿåˆ—è·å–**å¤šä¸ª**å‘½ä»¤æ‰§è¡Œï¼Œæäº¤ RequestCollapser åˆå¹¶æ‰§è¡Œã€‚åœ¨ [ã€Œ5. CollapserTimerã€](#) ä¹Ÿä¼šè¯¦ç»†è§£æã€‚
* `timerListenerRegistered` å±æ€§ï¼Œ`timerListenerReference` æ˜¯å¦å·²ç»æ³¨å†Œã€‚
* `timer` å±æ€§ï¼Œå‘½ä»¤åˆå¹¶å™¨çš„å®šæ—¶å™¨ã€‚
* `properties` å±æ€§ï¼Œå‘½ä»¤åˆå¹¶å™¨å±æ€§é…ç½®ã€‚
* `concurrencyStrategy` å±æ€§ï¼Œå¹¶å‘ç­–ç•¥ã€‚

## 4.2 RequestBatch

`com.netflix.hystrix.collapser.RequestBatch` ï¼Œå‘½ä»¤è¯·æ±‚é˜Ÿåˆ—ã€‚æä¾›å¦‚ä¸‹åŠŸèƒ½ ï¼š

* å‘½ä»¤è¯·æ±‚çš„æ·»åŠ 
* å‘½ä»¤è¯·æ±‚çš„ç§»é™¤
* å‘½ä»¤è¯·æ±‚çš„**æ‰¹é‡æ‰§è¡Œ**ã€‚ç¬”è€…æŠŠ RequestBatch è§£é‡Šæˆ "å‘½ä»¤è¯·æ±‚é˜Ÿåˆ—"ï¼Œä¸»è¦æ–¹ä¾¿å¤§å®¶ç†è§£ã€‚
    * é‚£å¯èƒ½æœ‰èƒ–å‹æœ‰ç–‘é—®ï¼Œä¸ºå•¥è¯¥åŠŸèƒ½ä¸åœ¨ RequestCollapser ç›´æ¥å®ç°ï¼Œè¿™æ · RequestBatch æˆä¸ºçº¯ç²¹çš„é˜Ÿåˆ—å‘¢ï¼Ÿåœ¨ [ã€Œ4.4 #createNewBatchAndExecutePreviousIfNeeded(previousBatch)ã€](#) è¯¦ç»†è§£æã€‚

RequestBatch **æ„é€ æ–¹æ³•**ï¼Œä»£ç å¦‚ä¸‹ ï¼š

```Java
public class RequestBatch<BatchReturnType, ResponseType, RequestArgumentType> {

    private final HystrixCollapserBridge<BatchReturnType, ResponseType, RequestArgumentType> commandCollapser;
    private final int maxBatchSize;
    private final AtomicBoolean batchStarted = new AtomicBoolean();

    private final ConcurrentMap<RequestArgumentType, CollapsedRequest<ResponseType, RequestArgumentType>> argumentMap =
            new ConcurrentHashMap<RequestArgumentType, CollapsedRequest<ResponseType, RequestArgumentType>>();
    private final HystrixCollapserProperties properties;

    private ReentrantReadWriteLock batchLock = new ReentrantReadWriteLock();

    public RequestBatch(HystrixCollapserProperties properties, HystrixCollapserBridge<BatchReturnType, ResponseType, RequestArgumentType> commandCollapser, int maxBatchSize) {
        this.properties = properties;
        this.commandCollapser = commandCollapser;
        this.maxBatchSize = maxBatchSize;
    }
}
```
* `commandCollapser` å±æ€§ï¼Œ**å‘½ä»¤**åˆå¹¶å™¨åŒ…è£…å™¨ã€‚
* `maxBatchSize` å±æ€§ï¼Œé˜Ÿåˆ—æœ€å¤§é•¿åº¦ã€‚
* `batchStarted` å±æ€§ï¼Œæ‰§è¡Œæ˜¯å¦å¼€å§‹ã€‚
* `argumentMap` å±æ€§ï¼Œå‘½ä»¤è¯·æ±‚å‚æ•°æ˜ å°„( **é˜Ÿåˆ—** )ã€‚
* `properties` å±æ€§ï¼Œå‘½ä»¤åˆå¹¶å™¨å±æ€§é…ç½®ã€‚
* `batchLock` å±æ€§ï¼Œ`argumentMap` æ“ä½œçš„**è¯»å†™é”**ã€‚

RequestBatch å®ç°é˜Ÿåˆ—å…·ä½“çš„æ“ä½œæ–¹æ³•ï¼Œåœ¨ [ã€Œ4.3 #submitRequest(arg)ã€](#)/[ã€Œ4.4 #createNewBatchAndExecutePreviousIfNeeded(previousBatch)ã€](#) ä¸€èµ·è§£æã€‚

## 4.3 #submitRequest(arg)

åœ¨ `#toObservable()` æ–¹æ³•é‡Œï¼Œè°ƒç”¨ `#submitRequest(arg)` æ–¹æ³•ï¼Œæäº¤**å•ä¸ª**å‘½ä»¤è¯·æ±‚åˆ° RequestBatch ã€‚ä»£ç å¦‚ä¸‹ ï¼š

```Java
  1: public Observable<ResponseType> submitRequest(final RequestArgumentType arg) {
  2:     /*
  3:      * We only want the timer ticking if there are actually things to do so we register it the first time something is added.
  4:      */
  5:     if (!timerListenerRegistered.get() && timerListenerRegistered.compareAndSet(false, true)) {
  6:         /* schedule the collapsing task to be executed every x milliseconds (x defined inside CollapsedTask) */
  7:         timerListenerReference.set(timer.addListener(new CollapsedTask()));
  8:     }
  9: 
 10:     // loop until succeed (compare-and-set spin-loop)
 11:     while (true) {
 12:         // è·å¾— RequestBatch
 13:         final RequestBatch<BatchReturnType, ResponseType, RequestArgumentType> b = batch.get();
 14:         if (b == null) {
 15:             return Observable.error(new IllegalStateException("Submitting requests after collapser is shutdown"));
 16:         }
 17: 
 18:         // æ·»åŠ åˆ° RequestBatch
 19:         final Observable<ResponseType> response;
 20:         if (arg != null) {
 21:             response = b.offer(arg);
 22:         } else {
 23:             response = b.offer( (RequestArgumentType) NULL_SENTINEL);
 24:         }
 25: 
 26:         // æ·»åŠ æˆåŠŸï¼Œè¿”å› Observable
 27:         // it will always get an Observable unless we hit the max batch size
 28:         if (response != null) {
 29:             return response;
 30:         } else {
 31:             // æ·»åŠ å¤±è´¥ï¼Œæ‰§è¡Œ RequestBatch ï¼Œå¹¶åˆ›å»ºæ–°çš„ RequestBatch
 32:             // this batch can't accept requests so create a new one and set it if another thread doesn't beat us
 33:             createNewBatchAndExecutePreviousIfNeeded(b);
 34:         }
 35:     }
 36: }
```

* ç¬¬ 5 è‡³ 8 è¡Œ ï¼šå½“ RequestCollapser çš„ç›‘å¬ä»»åŠ¡( CollapsedTask )è¿˜æœªåˆ›å»ºï¼Œè¿›è¡Œåˆå§‹åŒ–ã€‚
* ç¬¬ 11 è‡³ 35 è¡Œ ï¼š**æ­»å¾ªç¯**ï¼Œç›´åˆ°æäº¤**å•ä¸ª**å‘½ä»¤è¯·æ±‚åˆ° RequestBatch **æˆåŠŸ**ã€‚
    * ç¬¬ 13 è‡³ 16 è¡Œ ï¼šè·å¾— RequestBatch ã€‚ä»ç›®å‰ä»£ç çœ‹ä¸‹æ¥ï¼Œé™¤é RequestCollapser è¢« `#shutdown()` åæ‰ä¼šå‡ºç°ä¸º `null` çš„æƒ…å†µã€‚
    * ç¬¬ 19 è‡³ 24 è¡Œ ï¼šè°ƒåŠ¨ `RequestBatch#offer(...)` æ–¹æ³•ï¼Œæäº¤**å•ä¸ª**å‘½ä»¤è¯·æ±‚åˆ° RequestBatch ï¼Œå¹¶è·å¾— Observable ã€‚è¿™é‡Œå¯¹ `arg == null` åšäº†ç‰¹æ®Šå¤„ç†ï¼Œå› ä¸º `RequestBatch.argumentMap` æ˜¯ ConcurrentHashMap ï¼Œä¸å…è®¸å€¼ä¸º `null` ã€‚å¦å¤–ï¼Œ`RequestBatch#offer(...)` æ–¹æ³•çš„å®ç°ä»£ç ï¼Œåœ¨ç»“æŸäº†å½“å‰æ–¹æ³•ï¼Œè¯¦ç»†è§£æã€‚
    * ç¬¬ 28 è‡³ 29 è¡Œ ï¼šæ·»åŠ æˆåŠŸï¼Œè¿”å› Observable ã€‚
    * ç¬¬ 30 è‡³ 34 è¡Œ ï¼šæ·»åŠ å¤±è´¥ï¼Œæ‰§è¡Œå½“å‰ RequestBatch çš„**å¤šä¸ª**å‘½ä»¤åˆå¹¶æ‰§è¡Œï¼Œå¹¶åˆ›å»º**æ–°çš„** RequestBatch ã€‚åœ¨ [ã€Œ4.4 #createNewBatchAndExecutePreviousIfNeeded(previousBatch)ã€](#)   è¯¦ç»†è§£æã€‚

-------

`RequestBatch#offer(...)` æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ ï¼š

```Java
  1: public Observable<ResponseType>  offer(RequestArgumentType arg) {
  2:     // æ‰§è¡Œå·²ç»å¼€å§‹ï¼Œæ·»åŠ å¤±è´¥
  3:     /* short-cut - if the batch is started we reject the offer */
  4:     if (batchStarted.get()) {
  5:         return null;
  6:     }
  7: 
  8:     /*
  9:      * The 'read' just means non-exclusive even though we are writing.
 10:      */
 11:     if (batchLock.readLock().tryLock()) {
 12:         try {
 13:             // æ‰§è¡Œå·²ç»å¼€å§‹ï¼Œæ·»åŠ å¤±è´¥
 14:             /* double-check now that we have the lock - if the batch is started we reject the offer */
 15:             if (batchStarted.get()) {
 16:                 return null;
 17:             }
 18: 
 19:             // è¶…è¿‡é˜Ÿåˆ—æœ€å¤§é•¿åº¦ï¼Œæ·»åŠ å¤±è´¥
 20:             if (argumentMap.size() >= maxBatchSize) {
 21:                 return null;
 22:             } else {
 23:                 // åˆ›å»º CollapsedRequestSubject ï¼Œå¹¶æ·»åŠ åˆ°é˜Ÿåˆ—
 24:                 CollapsedRequestSubject<ResponseType, RequestArgumentType> collapsedRequest = new CollapsedRequestSubject<ResponseType, RequestArgumentType>(arg, this);
 25:                 final CollapsedRequestSubject<ResponseType, RequestArgumentType> existing = (CollapsedRequestSubject<ResponseType, RequestArgumentType>) argumentMap.putIfAbsent(arg, collapsedRequest);
 26:                 /**
 27:                  * If the argument already exists in the batch, then there are 2 options:
 28:                  * A) If request caching is ON (the default): only keep 1 argument in the batch and let all responses
 29:                  * be hooked up to that argument
 30:                  * B) If request caching is OFF: return an error to all duplicate argument requests
 31:                  *
 32:                  * This maintains the invariant that each batch has no duplicate arguments.  This prevents the impossible
 33:                  * logic (in a user-provided mapResponseToRequests for HystrixCollapser and the internals of HystrixObservableCollapser)
 34:                  * of trying to figure out which argument of a set of duplicates should get attached to a response.
 35:                  *
 36:                  * See https://github.com/Netflix/Hystrix/pull/1176 for further discussion.
 37:                  */
 38:                 if (existing != null) {
 39:                     boolean requestCachingEnabled = properties.requestCacheEnabled().get();
 40:                     if (requestCachingEnabled) {
 41:                         return existing.toObservable();
 42:                     } else {
 43:                         return Observable.error(new IllegalArgumentException("Duplicate argument in collapser batch : [" + arg + "]  This is not supported.  Please turn request-caching on for HystrixCollapser:" + commandCollapser.getCollapserKey().name() + " or prevent duplicates from making it into the batch!"));
 44:                     }
 45:                 } else {
 46:                     return collapsedRequest.toObservable();
 47:                 }
 48: 
 49:             }
 50:         } finally {
 51:             batchLock.readLock().unlock();
 52:         }
 53:     } else {
 54:         return null;
 55:     }
 56: }
```
* ç¬¬ 4 è‡³ 6 è¡Œ ï¼šæ‰§è¡Œå·²ç»å¼€å§‹ï¼Œæ·»åŠ å¤±è´¥ã€‚åœ¨ `RequestBatch#executeBatchIfNotAlreadyStarted(...)` æ–¹æ³•çš„å¼€å¤´ï¼Œä¼˜å…ˆ **CAS** ä½¿ `batchStarted = true` ã€‚
* ç¬¬ 11 è¡Œ ï¼šè·å¾—**è¯»é”**ã€‚`The 'read' just means non-exclusive even though we are writing.` ï¼Œå³ä½¿è¯¥æ–¹æ³•å®é™…åœ¨åš**"å†™æ“ä½œ"**ï¼Œä¸æ’ä»–ï¼Œçº¿ç¨‹å®‰å…¨ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨è¯»é”ã€‚
* ç¬¬ 15 è‡³ 17 è¡Œ ï¼š`double-check`ï¼Œæ‰§è¡Œå·²ç»å¼€å§‹ï¼Œæ·»åŠ å¤±è´¥ã€‚åœ¨ `RequestBatch#executeBatchIfNotAlreadyStarted(...)` æ–¹æ³•ï¼Œä¼˜å…ˆ **CAS** ä½¿ `batchStarted = true`ï¼Œå†è·å–**å†™é”**ï¼Œæ‰€ä»¥ä¼šå‡ºç°è¯¥æƒ…å†µã€‚
* ç¬¬ 20 è‡³ 21 è¡Œ ï¼šè¶…è¿‡é˜Ÿåˆ—æœ€å¤§é•¿åº¦ï¼Œæ·»åŠ å¤±è´¥ã€‚
* ç¬¬ 24 è‡³ 25 è¡Œ ï¼šåˆ›å»º `com.netflix.hystrix.collapser.CollapsedRequestSubject` ï¼Œå¹¶å°†**å®ƒ**æ·»åŠ åˆ°é˜Ÿåˆ—( `argumentMap` ) ã€‚
    * CollapsedRequestSubject å®ç° `com.netflix.hystrix.HystrixCollapser.CollapsedRequest` **æ¥å£**ï¼Œå®šä¹‰äº†æ‰¹é‡å‘½ä»¤æ‰§è¡Œçš„**è¯·æ±‚**ï¼Œä¸ä»…é™äºè·å¾—è¯·æ±‚å‚æ•°( `#getArgument()` æ–¹æ³• )ï¼Œä¹ŸåŒ…æ‹¬å¯¹æ‰¹é‡å‘½ä»¤æ‰§è¡Œç»“æŸåï¼Œæ¯ä¸ª**è¯·æ±‚**çš„ç»“æœè®¾ç½®( `#setResponse(...)`/`#emitResponse(...)`/`#setException(...)`/`#setComplete()` æ–¹æ³• )ï¼Œç‚¹å‡» [é“¾æ¥](https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java#L512) æŸ¥çœ‹è¯¥æ¥å£çš„ä»£ç ã€‚
    * CollapsedRequestSubject **æ„é€ æ–¹æ³•**ï¼Œä»£ç å¦‚ä¸‹ï¼š

        ```Java
        /* package */class CollapsedRequestSubject<T, R> implements CollapsedRequest<T, R> {
        
            /**
             * å‚æ•°
             */
            private final R argument;
        
            /**
             * ç»“æœ( response ) æ˜¯å¦è®¾ç½®
             */
            private AtomicBoolean valueSet = new AtomicBoolean(false);
            /**
             * å¯å›æ”¾çš„ ReplaySubject
             */
            private final ReplaySubject<T> subject = ReplaySubject.create();
            /**
             * å¸¦è®¢é˜…æ•°é‡çš„ ReplaySubject
             */
            private final Observable<T> subjectWithAccounting;
        
            /**
             * è®¢é˜…æ•°é‡
             */
            private volatile int outstandingSubscriptions = 0;
        
            public CollapsedRequestSubject(final R arg, final RequestBatch<?, T, R> containingBatch) {
                // è®¾ç½® argument
                if (arg == RequestCollapser.NULL_SENTINEL) {
                    this.argument = null;
                } else {
                    this.argument = arg;
                }
                // è®¾ç½® å¸¦è®¢é˜…æ•°é‡çš„ ReplaySubject
                this.subjectWithAccounting = subject
                        .doOnSubscribe(new Action0() {
                            @Override
                            public void call() {
                                outstandingSubscriptions++;
                            }
                        })
                        .doOnUnsubscribe(new Action0() {
                            @Override
                            public void call() {
                                outstandingSubscriptions--;
                                if (outstandingSubscriptions == 0) {
                                    containingBatch.remove(arg);
                                }
                            }
                        });
            }
        }
        ```
        * `argument` å±æ€§ï¼Œ**å•ä¸ª**å‘½ä»¤è¯·æ±‚å‚æ•°ã€‚
        * `valueSet` å±æ€§ï¼Œç»“æœ( Response ) æ˜¯å¦è®¾ç½®ï¼Œé€šè¿‡ `#setResponse()`/`#emitResponse()` æ–¹æ³•è®¾ç½®ã€‚
        * `subject` å±æ€§ï¼Œ**å¯å›æ”¾æ‰§è¡Œç»“æœ**çš„ Subject ã€‚æ­¤å¤„ä½¿ç”¨ ReplaySubject çš„ä¸»è¦ç›®çš„ï¼Œå½“ HystrixCollapser å¼€å¯**ç¼“å­˜**åŠŸèƒ½æ—¶ï¼Œé€šè¿‡å›æ”¾æ‰§è¡Œç»“æœï¼Œåœ¨ [ã€ŠHystrix æºç è§£æ â€”â€” æ‰§è¡Œç»“æœç¼“å­˜ã€‹ã€Œ5. HystrixCachedObservableã€](http://www.iocoder.cn/Hystrix/command-execute-result-cache/?self) ä¹Ÿæœ‰ç›¸åŒçš„å®ç°ã€‚å¦å¤–ï¼Œè¿™é‡Œæœ‰ä¸€ç‚¹è¦æ³¨æ„ä¸‹ï¼ŒReplaySubject å¹¶**æ²¡æœ‰**å‘ä»»ä½• Observable è®¢é˜…ç»“æœï¼Œ**è€Œæ˜¯é€šè¿‡ `#setResponse()`/`#emitResponse()` æ–¹æ³•è®¾ç½®ç»“æœ**ã€‚
        * `outstandingSubscriptions` å±æ€§ï¼Œè®¢é˜…æ•°é‡ã€‚ 
        * `subjectWithAccounting` å±æ€§ï¼Œå¸¦è®¢é˜…æ•°é‡çš„ ReplaySubject ã€‚å½“å–æ¶ˆè®¢é˜…æ—¶ï¼Œè°ƒç”¨ `RequestBatch#remove(arg)` æ–¹æ³•ï¼Œç§»é™¤**å•ä¸ª**å‘½ä»¤è¯·æ±‚ã€‚

* ç¬¬ 38 è‡³ 47 è¡Œ ï¼šè¿”å› Observable ã€‚
    * å½“ `argumentMap` å·²ç»å­˜åœ¨ `arg` å¯¹åº”çš„ Observable æ—¶ï¼Œå¿…é¡»å¼€å¯ç¼“å­˜ ( `HystrixCollapserProperties.requestCachingEnabled = true` ) åŠŸèƒ½ã€‚åŸå› æ˜¯ï¼Œå¦‚æœåœ¨**ç›¸åŒçš„** `arg` ï¼Œå¹¶ä¸”æœªå¼€å¯ç¼“å­˜ï¼ŒåŒæ—¶**ç¬¬ 43 è¡Œ**å®ç°çš„æ˜¯ `collapsedRequest.toObservable()` ï¼Œé‚£ä¹ˆ**ç›¸åŒçš„** `arg` å°†æœ‰**å¤šä¸ª** Observable æ‰§è¡Œå‘½ä»¤ï¼Œæ­¤æ—¶ `HystrixCollapserBridge#mapResponseToRequests(...)` æ–¹æ³•æ— æ³•å°†æ‰§è¡Œ( Response )èµ‹å€¼åˆ° `arg` å¯¹åº”çš„å‘½ä»¤è¯·æ±‚( CollapsedRequestSubject ) ã€‚æ›´å¤šè®¨è®ºï¼Œè§ [https://github.com/Netflix/Hystrix/pull/1176](https://github.com/Netflix/Hystrix/pull/1176) ã€‚
    * å›è¿‡å¤´çœ‹ `HystrixCollapser#toObservable()` æ–¹æ³•çš„**ç¬¬ 32 è‡³ 41 è¡Œçš„ä»£ç **ï¼Œè¿™é‡Œä¹Ÿæœ‰å¯¹**ç¼“å­˜**åŠŸèƒ½ï¼Œæ˜¯ä¸æ˜¯**é‡å¤**äº†å‘¢ï¼Ÿ`argumentMap` é’ˆå¯¹çš„æ˜¯ RequestBatch çº§çš„ç¼“å­˜ï¼ŒHystrixCollapser : RequestCollapser : RequestBatch æ˜¯ `1 : 1 : N` çš„å…³ç³»ï¼Œé€šè¿‡ `HystrixCollapser#toObservable()` å¯¹ç¼“å­˜çš„å¤„ç†é€»è¾‘ï¼Œä¿è¯ RequestBatch åˆ‡æ¢åï¼Œ**ä¾ç„¶æœ‰ç¼“å­˜**ã€‚

-------

`RequestBatch#remove()` æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ ï¼š

```Java
/* package-private */ void remove(RequestArgumentType arg) {
    if (batchStarted.get()) {
        //nothing we can do
        return;
    }

    if (batchLock.readLock().tryLock()) {
        try {
            /* double-check now that we have the lock - if the batch is started, deleting is useless */
            if (batchStarted.get()) {
                return;
            }

            argumentMap.remove(arg);
        } finally {
            batchLock.readLock().unlock();
        }
    }
}
```
* å½“ RequestBatch å¼€å§‹æ‰§è¡Œï¼Œä¸å…è®¸ç§»é™¤**å•ä¸ª**å‘½ä»¤è¯·æ±‚ã€‚

## 4.4 #createNewBatchAndExecutePreviousIfNeeded(previousBatch)

æœ¬å°èŠ‚å»ºè®®åœ¨ [ã€Œ5. CollapserTimerã€](#) åï¼Œå†å›è¿‡å¤´çœ‹ã€‚

`#createNewBatchAndExecutePreviousIfNeeded(previousBatch)` æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ ï¼š

```Java
  1: private void createNewBatchAndExecutePreviousIfNeeded(RequestBatch<BatchReturnType, ResponseType, RequestArgumentType> previousBatch) {
  2:     if (previousBatch == null) {
  3:         throw new IllegalStateException("Trying to start null batch which means it was shutdown already.");
  4:     }
  5:     if (batch.compareAndSet(previousBatch, new RequestBatch<BatchReturnType, ResponseType, RequestArgumentType>(properties, commandCollapser, properties.maxRequestsInBatch().get()))) {
  6:         // this thread won so trigger the previous batch
  7:         previousBatch.executeBatchIfNotAlreadyStarted();
  8:     }
  9: }
```

* ç¬¬ 5 è¡Œ ï¼šé€šè¿‡ **CAS** ä¿®æ”¹ `batch` ï¼Œä¿è¯å¹¶å‘æƒ…å†µä¸‹çš„çº¿ç¨‹å®‰å…¨ã€‚åŒæ—¶æ³¨æ„ï¼Œæ­¤å¤„ä¹Ÿè¿›è¡Œäº†**æ–°çš„** RequestBatch ï¼Œåˆ‡æ¢æ‰**è€çš„** RequestBatch ã€‚
* ç¬¬ 6 è¡Œ ï¼šä½¿ç”¨**è€çš„** RequestBatch ï¼Œè°ƒç”¨ `RequestBatch#executeBatchIfNotAlreadyStarted()` æ–¹æ³•ï¼Œå‘½ä»¤åˆå¹¶æ‰§è¡Œã€‚

-------

`RequestBatch#executeBatchIfNotAlreadyStarted()` æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ ï¼š

```Java
  1: public void executeBatchIfNotAlreadyStarted() {
  2:     /*
  3:      * - check that we only execute once since there's multiple paths to do so (timer, waiting thread or max batch size hit)
  4:      * - close the gate so 'offer' can no longer be invoked and we turn those threads away so they create a new batch
  5:      */
  6:     // è®¾ç½® æ‰§è¡Œå·²ç»å¼€å§‹
  7:     if (batchStarted.compareAndSet(false, true)) {
  8:         // è·å¾— å†™é”
  9:         /* wait for 'offer'/'remove' threads to finish before executing the batch so 'requests' is complete */
 10:         batchLock.writeLock().lock();
 11: 
 12:         try {
 13:             // å°†å¤šä¸ªå‘½ä»¤è¯·æ±‚åˆ†ç‰‡æˆ N ä¸ªã€å¤šä¸ªå‘½ä»¤è¯·æ±‚ã€‘ã€‚
 14:             // shard batches
 15:             Collection<Collection<CollapsedRequest<ResponseType, RequestArgumentType>>> shards = commandCollapser.shardRequests(argumentMap.values());
 16:             // for each shard execute its requests 
 17:             for (final Collection<CollapsedRequest<ResponseType, RequestArgumentType>> shardRequests : shards) {
 18:                 try {
 19:                     // å°†å¤šä¸ªå‘½ä»¤è¯·æ±‚åˆå¹¶ï¼Œåˆ›å»ºä¸€ä¸ª HystrixCommand
 20:                     // create a new command to handle this batch of requests
 21:                     Observable<BatchReturnType> o = commandCollapser.createObservableCommand(shardRequests);
 22: 
 23:                     // å°†ä¸€ä¸ª HystrixCommand çš„æ‰§è¡Œç»“æœï¼Œæ˜ å°„å›å¯¹åº”çš„å‘½ä»¤è¯·æ±‚ä»¬
 24:                     commandCollapser.mapResponseToRequests(o, shardRequests).doOnError(new Action1<Throwable>() {
 25: 
 26:                         /**
 27:                          * This handles failed completions
 28:                          */
 29:                         @Override
 30:                         public void call(Throwable e) {
 31:                             // handle Throwable in case anything is thrown so we don't block Observers waiting for onError/onCompleted
 32:                             Exception ee;
 33:                             if (e instanceof Exception) {
 34:                                 ee = (Exception) e;
 35:                             } else {
 36:                                 ee = new RuntimeException("Throwable caught while executing batch and mapping responses.", e);
 37:                             }
 38:                             logger.debug("Exception mapping responses to requests.", e);
 39:                             // if a failure occurs we want to pass that exception to all of the Futures that we've returned
 40:                             for (CollapsedRequest<ResponseType, RequestArgumentType> request : argumentMap.values()) {
 41:                                 try {
 42:                                     ((CollapsedRequestSubject<ResponseType, RequestArgumentType>) request).setExceptionIfResponseNotReceived(ee);
 43:                                 } catch (IllegalStateException e2) {
 44:                                     // if we have partial responses set in mapResponseToRequests
 45:                                     // then we may get IllegalStateException as we loop over them
 46:                                     // so we'll log but continue to the rest
 47:                                     logger.error("Partial success of 'mapResponseToRequests' resulted in IllegalStateException while setting Exception. Continuing ... ", e2);
 48:                                 }
 49:                             }
 50:                         }
 51: 
 52:                     }).doOnCompleted(new Action0() {
 53: 
 54:                         /**
 55:                          * This handles successful completions
 56:                          */
 57:                         @Override
 58:                         public void call() {
 59:                             // check that all requests had setResponse or setException invoked in case 'mapResponseToRequests' was implemented poorly
 60:                             Exception e = null;
 61:                             for (CollapsedRequest<ResponseType, RequestArgumentType> request : shardRequests) {
 62:                                 try {
 63:                                    e = ((CollapsedRequestSubject<ResponseType, RequestArgumentType>) request).setExceptionIfResponseNotReceived(e,"No response set by " + commandCollapser.getCollapserKey().name() + " 'mapResponseToRequests' implementation.");
 64:                                 } catch (IllegalStateException e2) {
 65:                                     logger.debug("Partial success of 'mapResponseToRequests' resulted in IllegalStateException while setting 'No response set' Exception. Continuing ... ", e2);
 66:                                 }
 67:                             }
 68:                         }
 69: 
 70:                     }).subscribe();
 71:                     
 72:                 } catch (Exception e) {
 73:                     // å¼‚å¸¸
 74:                     logger.error("Exception while creating and queueing command with batch.", e);
 75:                     // if a failure occurs we want to pass that exception to all of the Futures that we've returned
 76:                     for (CollapsedRequest<ResponseType, RequestArgumentType> request : shardRequests) {
 77:                         try {
 78:                             request.setException(e);
 79:                         } catch (IllegalStateException e2) {
 80:                             logger.debug("Failed trying to setException on CollapsedRequest", e2);
 81:                         }
 82:                     }
 83:                 }
 84:             }
 85: 
 86:         } catch (Exception e) {
 87:             // å¼‚å¸¸
 88:             logger.error("Exception while sharding requests.", e);
 89:             // same error handling as we do around the shards, but this is a wider net in case the shardRequest method fails
 90:             for (CollapsedRequest<ResponseType, RequestArgumentType> request : argumentMap.values()) {
 91:                 try {
 92:                     request.setException(e);
 93:                 } catch (IllegalStateException e2) {
 94:                     logger.debug("Failed trying to setException on CollapsedRequest", e2);
 95:                 }
 96:             }
 97:         } finally {
 98:             batchLock.writeLock().unlock();
 99:         }
100:     }
101: }
```
* ä»£ç çœ‹èµ·æ¥æ˜¯æœ‰ç‚¹é•¿å“ˆï¼Œè¯·å¯¹ç…§ç€å®˜æ–¹ç¤ºä¾‹ [CommandCollapserGetValueForKey](https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-examples/src/main/java/com/netflix/hystrix/examples/basic/CommandCollapserGetValueForKey.java) ä¸€èµ·çœ‹ï¼Œä¸´é—¨ä¸€è„šäº†ï¼Œèƒ–å‹ï¼
* ç¬¬ 7 è¡Œ ï¼šé€šè¿‡ **CAS** ä¿®æ”¹ `batchStarted` ï¼Œä¿è¯å¹¶å‘æƒ…å†µä¸‹çš„çº¿ç¨‹å®‰å…¨ã€‚
* ç¬¬ 10 è¡Œ ï¼šè·å¾—**å†™é”**ã€‚ç­‰å¾…è°ƒç”¨ `#offer(...)`/`#remove(...)` æ–¹æ³•çš„çº¿ç¨‹æ‰§è¡Œå®Œæˆï¼Œä»¥ä¿è¯å‘½ä»¤åˆå¹¶æ‰§è¡Œæ—¶ï¼Œä¸å†æœ‰æ–°çš„è¯·æ±‚æ·»åŠ æˆ–ç§»é™¤ã€‚
* ç¬¬ 15 è¡Œ ï¼šè°ƒç”¨ `HystrixCollapserBridge#shardRequests(...)` æ–¹æ³•ï¼Œå°†**å¤šä¸ª**å‘½ä»¤è¯·æ±‚**åˆ†ç‰‡**æˆ **N** ä¸ªã€**å¤šä¸ª**å‘½ä»¤è¯·æ±‚ã€‘ã€‚é»˜è®¤å®ç°ä¸‹ï¼Œä¸è¿›è¡Œåˆ†ç‰‡ã€‚ç‚¹å‡» [é“¾æ¥](https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java#L146) æŸ¥çœ‹ä»£ç ã€‚
* ç¬¬ 17 è¡Œ ï¼šå¾ªç¯ **N** ä¸ªã€**å¤šä¸ª**å‘½ä»¤è¯·æ±‚ã€‘ã€‚
* ç¬¬ 21 è¡Œ ï¼šè°ƒç”¨ `HystrixCollapserBridge#createObservableCommand(...)` æ–¹æ³•ï¼Œå°†**å¤šä¸ª**å‘½ä»¤è¯·æ±‚**åˆå¹¶**ï¼Œåˆ›å»º**ä¸€ä¸ª** HystrixCommand ã€‚ç‚¹å‡» [é“¾æ¥](https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java#L156) æŸ¥çœ‹ä»£ç ã€‚
* ç¬¬ 24 è¡Œ ï¼šè°ƒç”¨ `HystrixCollapserBridge#mapResponseToRequests(...)` æ–¹æ³•ï¼Œå°†**ä¸€ä¸ª** HystrixCommand çš„æ‰§è¡Œç»“æœï¼Œ**æ˜ å°„**å›å¯¹åº”çš„å‘½ä»¤è¯·æ±‚ä»¬ã€‚ç‚¹å‡» [é“¾æ¥](https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java#L166) æŸ¥çœ‹ä»£ç ã€‚
    * `Observable#single()` æ–¹æ³•ï¼Œå¦‚æœ Observable ç»ˆæ­¢æ—¶åªå‘å°„äº†ä¸€ä¸ªå€¼ï¼Œè¿”å›é‚£ä¸ªå€¼ï¼Œå¦åˆ™æŠ›å‡ºå¼‚å¸¸ã€‚åœ¨ [ã€ŠReactiveXæ–‡æ¡£ä¸­æ–‡ç¿»è¯‘ã€‹ã€Œsingleã€](https://mcxiaoke.gitbooks.io/rxdocs/content/operators/First.html#single) æœ‰ç›¸å…³åˆ†äº«ã€‚
    * `Observable#ignoreElements()` æ–¹æ³•ï¼ŒæŠ‘åˆ¶åŸå§‹ Observable å‘å°„çš„æ‰€æœ‰æ•°æ®ï¼Œåªå…è®¸å®ƒçš„ç»ˆæ­¢é€šçŸ¥ï¼ˆ`#onError()` æˆ– `#onCompleted()`ï¼‰é€šè¿‡ã€‚åœ¨ [ã€ŠReactiveXæ–‡æ¡£ä¸­æ–‡ç¿»è¯‘ã€‹ã€ŒIgnoreElementsã€](https://mcxiaoke.gitbooks.io/rxdocs/content/operators/IgnoreElements.html) æœ‰ç›¸å…³åˆ†äº«ã€‚ä¹Ÿæ¨èç‚¹å‡» [`rx.internal.operators.OperatorIgnoreElements`](https://github.com/ReactiveX/RxJava/blob/6db98f8750f580995657f83b5620b579c97e6a06/src/main/java/rx/internal/operators/OperatorIgnoreElements.java) çœ‹ä¸‹æºç ï¼Œå¯èƒ½æ›´åŠ æ˜“æ‡‚ã€‚
    * `Observable#cast()` æ–¹æ³•ï¼Œå°†åŸå§‹ Observable å‘å°„çš„æ¯ä¸€é¡¹æ•°æ®éƒ½å¼ºåˆ¶è½¬æ¢ä¸ºä¸€ä¸ªæŒ‡å®šçš„ç±»å‹ï¼Œç„¶åå†å‘å°„æ•°æ®ï¼Œå®ƒæ˜¯ `map` çš„ä¸€ä¸ªç‰¹æ®Šç‰ˆæœ¬ã€‚åœ¨ [ã€ŠReactiveXæ–‡æ¡£ä¸­æ–‡ç¿»è¯‘ã€‹ã€Œcastã€](https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Map.html#cast) æœ‰ç›¸å…³åˆ†äº«ã€‚ä¹Ÿæ¨èç‚¹å‡» [`rx.internal.operators.OperatorCast`](https://github.com/ReactiveX/RxJava/blob/6db98f8750f580995657f83b5620b579c97e6a06/src/main/java/rx/internal/operators/OperatorCast.java) çœ‹ä¸‹æºç ï¼Œå¯èƒ½æ›´åŠ æ˜“æ‡‚ã€‚
    * ä½¿ç”¨ `Observable#ignoreElements()`/`Observable#cast()` æ–¹æ³•ï¼Œç”¨äºå°† Observable å˜æˆä¸å†ç»§ç»­å‘ä¸‹å‘å°„æ•°æ®é¡¹ï¼Œåªç»™ç°æœ‰æ–¹æ³•é‡Œ `Observable#doNext()` å¤„ç†æ•°æ®é¡¹ï¼Œè°ƒç”¨ `HystrixCollapser#mapResponseToRequests(...)` æ–¹æ³•ã€‚
    * ç‚¹å‡» [é“¾æ¥](https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/collapser/CollapsedRequestSubject.java#L101) ï¼ŒæŸ¥çœ‹ `CollapsedRequestSubject#setResponse(response)` æ–¹æ³•çš„ä»£ç ã€‚
* ç¬¬ 24 è‡³ 50 è¡Œ ï¼šè°ƒç”¨ `Observable#doError(Action1)` æ–¹æ³•ï¼Œå½“å‘½ä»¤åˆå¹¶æ‰§è¡Œå‘ç”Ÿå¼‚å¸¸æ—¶ï¼Œè®¾ç½®**æ¯ä¸ª** CollapsedRequestSubject çš„æ‰§è¡Œç»“æœä¸ºå¼‚å¸¸ã€‚
    * ç‚¹å‡» [é“¾æ¥](https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/collapser/CollapsedRequestSubject.java#L137)ï¼ŒæŸ¥çœ‹ `CollapsedRequestSubject#setResponse(response)` æ–¹æ³•çš„ä»£ç ã€‚
* ç¬¬ 52 è‡³ 68 è¡Œ ï¼šè°ƒç”¨ `Observable#doOnCompleted(Action0)` æ–¹æ³•ï¼Œå½“å‘½ä»¤åˆå¹¶æ‰§è¡Œå®Œæˆæ—¶ï¼Œæ£€æŸ¥**æ¯ä¸ª** CollapsedRequestSubject æ˜¯å¦éƒ½æœ‰è¿”å›ç»“æœã€‚è®¾ç½®æ²¡æœ‰è¿”å›ç»“æœçš„ CollapsedRequestSubject çš„æ‰§è¡Œç»“æœä¸ºå¼‚å¸¸ã€‚ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œæ˜¯ç”¨æˆ·å®ç° `HystrixCollapser#mapResponseToRequests(...)` æ–¹æ³•å­˜åœ¨ BUG ã€‚å¦å¤–ï¼Œå¦‚æœä¸è®¾ç½®ï¼Œå°†å¯¼è‡´æ— ç»“æœçš„**å•ä¸ª**å‘½ä»¤è¯·æ±‚**æ— é™é˜»å¡**ã€‚
* ç¬¬ 70 è¡Œ ï¼šè°ƒç”¨ `Observable#subscribe()` æ–¹æ³•ï¼Œ**è§¦å‘** HystrixCommand æ‰§è¡Œã€‚
* ç¬¬ 72 è‡³ 96 è¡Œ ï¼šå‘ç”Ÿå¼‚å¸¸ï¼Œè®¾ç½®**æ¯ä¸ª** CollapsedRequestSubject çš„æ‰§è¡Œç»“æœä¸ºå¼‚å¸¸ã€‚
     * ç‚¹å‡» [é“¾æ¥](https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/collapser/CollapsedRequestSubject.java#L170)ï¼ŒæŸ¥çœ‹ `CollapsedRequestSubject#setException(response)` æ–¹æ³•çš„ä»£ç ã€‚
* ç¬¬ 97 è‡³ 99 è¡Œ ï¼šé‡Šæ”¾**å†™é”**ã€‚

# 5. CollapserTimer

`com.netflix.hystrix.collapser.CollapserTimer` ï¼Œå‘½ä»¤åˆå¹¶å™¨çš„å®šæ—¶å™¨**æ¥å£**ï¼Œå®šä¹‰äº†**æäº¤å®šæ—¶ç›‘å¬å™¨ï¼Œç”Ÿæˆå®šæ—¶ä»»åŠ¡**çš„æ¥å£æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ ï¼š

```Java
public interface CollapserTimer {

    Reference<TimerListener> addListener(TimerListener collapseTask);
}
```

## 5.1 RealCollapserTimer

`com.netflix.hystrix.collapser.RealCollapserTimer` ï¼Œå‘½ä»¤åˆå¹¶å™¨çš„å®šæ—¶å™¨**å®ç°ç±»**ï¼Œä»£ç å¦‚ä¸‹ ï¼š

```Java
public class RealCollapserTimer implements CollapserTimer {
    /* single global timer that all collapsers will schedule their tasks on */
    private final static HystrixTimer timer = HystrixTimer.getInstance();

    @Override
    public Reference<TimerListener> addListener(TimerListener collapseTask) {
        return timer.addTimerListener(collapseTask);
    }

}
```

* å®é™…ä¸Šï¼Œä½¿ç”¨çš„æ˜¯ HystrixTimer æä¾›çš„å•ä¾‹ã€‚åœ¨ [ã€ŠHystrix æºç è§£æ â€”â€” æ‰§è¡Œç»“æœç¼“å­˜ã€‹ã€Œ3. HystrixTimer
ã€](http://www.iocoder.cn/Hystrix/command-execute-third-timeout/?self) æœ‰è¯¦ç»†è§£æã€‚

## 5.2 CollapsedTask

`com.netflix.hystrix.collapser.RequestCollapser.CollapsedTask` ï¼Œå®šæ—¶ä»»åŠ¡ï¼Œå›ºå®šå‘¨æœŸ( å¯é…ï¼Œé»˜è®¤ `HystrixCollapserProperties.timerDelayInMilliseconds = 10ms` ) è½®è¯¢å…¶å¯¹åº”çš„**ä¸€ä¸ª** RequestCollapser **å½“å‰** RequestBatch ã€‚è‹¥æœ‰å‘½ä»¤éœ€è¦æ‰§è¡Œï¼Œåˆ™æäº¤ RequestCollapser åˆå¹¶æ‰§è¡Œã€‚

ä»£ç æ¯”è¾ƒç®€å•ï¼Œç‚¹å‡» [é“¾æ¥](https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestCollapser.java#L138) ç›´æ¥çœ‹ä»£ç ã€‚

# 666. å½©è›‹

![çŸ¥è¯†æ˜Ÿçƒ](http://www.iocoder.cn/images/Architecture/2017_12_29/01.png)

T T ä¸€å¼€å§‹æŠŠå‘½ä»¤åˆå¹¶æ‰§è¡Œï¼Œç†è§£æˆç±»ä¼¼çº¿ç¨‹æ± æ‰¹é‡æ‰§è¡Œä»»åŠ¡ï¼Œæ€ä¹ˆçœ‹å®˜æ–¹ç¤ºä¾‹ï¼Œæ€ä¹ˆå¥‡æ€ªã€‚æœ‰ä¸€æ ·çš„åŒå­¦ï¼Œä¸€èµ·æ³ªç›® + æ¡çˆªä¸‹ã€‚

æœ¬æ–‡æœ‰ç‚¹ç‚¹é•¿ï¼Œå®åœ¨ä¸æƒ³æ‹†åˆ†æˆå¤šç¯‡ã€‚

æ©ï¼Œå¦å¤–éƒ¨åˆ†åœ°æ–¹å†™çš„ä¸å¤Ÿæ¸…æ™°ï¼Œæ¬¢è¿ä¸€èµ·è®¨è®ºå’Œä¼˜åŒ–ã€‚

èƒ–å‹ï¼Œåˆ†äº«ä¸€æ³¢æœ‹å‹åœˆå¯å¥½ï¼


