title: Fescar æºç èµ°è¯»ï¼ˆ3ï¼‰ä¹‹åˆ†æ”¯äº‹åŠ¡æµç¨‹
date: 2019-03-07
tags:
categories: Fescar
permalink: Fescar/yuanxiang/3-branch-transaction
author: yuanxiang
from_url: https://zhuanlan.zhihu.com/p/54815876
wechat_url:

-------

æ‘˜è¦: åŸåˆ›å‡ºå¤„ https://zhuanlan.zhihu.com/p/54815876 ã€Œyuanxiangã€æ¬¢è¿è½¬è½½ï¼Œä¿ç•™æ‘˜è¦ï¼Œè°¢è°¢ï¼


-------

![](http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg)

> ğŸ™‚ğŸ™‚ğŸ™‚å…³æ³¨**å¾®ä¿¡å…¬ä¼—å·ï¼šã€èŠ‹é“æºç ã€‘**æœ‰ç¦åˆ©ï¼š
> 1. RocketMQ / MyCAT / Sharding-JDBC **æ‰€æœ‰**æºç åˆ†ææ–‡ç« åˆ—è¡¨
> 2. RocketMQ / MyCAT / Sharding-JDBC **ä¸­æ–‡æ³¨é‡Šæºç  GitHub åœ°å€**
> 3. æ‚¨å¯¹äºæºç çš„ç–‘é—®æ¯æ¡ç•™è¨€**éƒ½**å°†å¾—åˆ°**è®¤çœŸ**å›å¤ã€‚**ç”šè‡³ä¸çŸ¥é“å¦‚ä½•è¯»æºç ä¹Ÿå¯ä»¥è¯·æ•™å™¢**ã€‚
> 4. **æ–°çš„**æºç è§£ææ–‡ç« **å®æ—¶**æ”¶åˆ°é€šçŸ¥ã€‚**æ¯å‘¨æ›´æ–°ä¸€ç¯‡å·¦å³**ã€‚
> 5. **è®¤çœŸçš„**æºç äº¤æµå¾®ä¿¡ç¾¤ã€‚

-------


AsyncWorkerç›®å‰åªå®ç°äº†branchCommitï¼Œç”¨äºåœ¨åˆ†æ”¯äº‹åŠ¡æäº¤åå¼‚æ­¥åˆ é™¤undo sqlè®°å½•ï¼Œç›®å‰branchrollbackæ¥å£è¿˜æ²¡æœ‰å®ç°

```java
    private void doBranchCommits() {
        if (ASYNC_COMMIT_BUFFER.size() == 0) {
            return;
        }
        Map<String, List<Phase2Conjava>> mappedConjavas = new HashMap<>();
        Iterator<Phase2Conjava> iterator = ASYNC_COMMIT_BUFFER.iterator();
        while (iterator.hasNext()) {
            Phase2Conjava commitConjava = iterator.next();
            List<Phase2Conjava> conjavasGroupedByResourceId = mappedConjavas.get(commitConjava.resourceId);
            if (conjavasGroupedByResourceId == null) {
                conjavasGroupedByResourceId = new ArrayList<>();
                mappedConjavas.put(commitConjava.resourceId, conjavasGroupedByResourceId);
            }
            conjavasGroupedByResourceId.add(commitConjava);

            iterator.remove();

        }

        for (String resourceId : mappedConjavas.keySet()) {
            Connection conn = null;
            try {
                try {
                    DataSourceProxy dataSourceProxy = DataSourceManager.get().get(resourceId);
                    conn = dataSourceProxy.getPlainConnection();
                } catch (SQLException sqle) {
                    LOGGER.warn("Failed to get connection for async committing on " + resourceId, sqle);
                    continue;
                }

                List<Phase2Conjava> conjavasGroupedByResourceId = mappedConjavas.get(resourceId);
                for (Phase2Conjava commitConjava : conjavasGroupedByResourceId) {
                    try {
                        UndoLogManager.deleteUndoLog(commitConjava.xid, commitConjava.branchId, conn);
                    } catch (Exception ex) {
                        LOGGER.warn("Failed to delete undo log [" + commitConjava.branchId + "/" + commitConjava.xid + "]", ex);
                    }
                }

            } finally {
                if (conn != null) {
                    try {
                        conn.close();
                    } catch (SQLException closeEx) {
                        LOGGER.warn("Failed to close JDBC resource while deleting undo_log ", closeEx);
                    }
                }
            }


        }


    }
```

ConnectionProxy.commitåœ¨æäº¤æ˜¯ä¼šè°ƒç”¨branchRegiesterã€‚åœ¨å¦‚ä¸‹æ–¹æ³•register()é‡Œ

```java
    public void commit() throws SQLException {
        if (conjava.inGlobalTransaction()) {
            try {
                register();
            } catch (TransactionException e) {
                recognizeLockKeyConflictException(e);
            }

            try {
                if (conjava.hasUndoLog()) {
                    UndoLogManager.flushUndoLogs(this);
                }
                targetConnection.commit();
            } catch (Throwable ex) {
                report(false);
                if (ex instanceof SQLException) {
                    throw (SQLException) ex;
                } else {
                    throw new SQLException(ex);
                }

            }
            report(true);
            conjava.reset();

        } else {
            targetConnection.commit();
        }
    }
```



DataSourceManageræ˜¯rmçš„å®ç°ï¼š

branchRegisteré€šè¿‡rpcclientåˆ°æœåŠ¡ç«¯æ³¨å†Œåˆ†æ”¯äº‹åŠ¡

DefaultCoordinatoræ¥æ³¨å†Œåˆ†æ”¯äº‹åŠ¡

```java
    @Override
    protected void doBranchRegister(BranchRegisterRequest request, BranchRegisterResponse response, RpcConjava rpcConjava) throws TransactionException {
        response.setTransactionId(request.getTransactionId());
        response.setBranchId(core.branchRegister(request.getBranchType(), request.getResourceId(), rpcConjava.getClientId(),
                XID.generateXID(request.getTransactionId()), request.getLockKey()));

    }
```

DefaultCore.branchRegister

```java
    public Long branchRegister(BranchType branchType, String resourceId, String clientId, String xid, String lockKeys) throws TransactionException {
        GlobalSession globalSession = assertGlobalSession(XID.getTransactionId(xid), GlobalStatus.Begin);

        BranchSession branchSession = new BranchSession();
        branchSession.setTransactionId(XID.getTransactionId(xid));
        branchSession.setBranchId(UUIDGenerator.generateUUID());
        branchSession.setApplicationId(globalSession.getApplicationId());
        branchSession.setTxServiceGroup(globalSession.getTransactionServiceGroup());
        branchSession.setBranchType(branchType);
        branchSession.setResourceId(resourceId);
        branchSession.setLockKey(lockKeys);
        branchSession.setClientId(clientId);

        if (!branchSession.lock()) {
            throw new TransactionException(LockKeyConflict);
        }
        try {
            globalSession.addBranch(branchSession);
        } catch (RuntimeException ex) {
            throw new TransactionException(FailedToAddBranch);

        }
        return branchSession.getBranchId();
    }
```

åˆ†æ”¯branchæ³¨å†Œåˆ°å…¨å±€äº‹åŠ¡åˆ†æ”¯ä¸Š

commitè¿‡ç¨‹ï¼š

ç¬¬ä¸€é˜¶æ®µæäº¤ä»¥executeUpdateä¸ºä¾‹ï¼Œå…¥å£åœ°å€å¦‚ä¸‹ï¼š

```java
    public int executeUpdate() throws SQLException {
        return ExecuteTemplate.execute(this, new StatementCallback<Integer, PreparedStatement>() {
            @Override
            public Integer execute(PreparedStatement statement, Object... args) throws SQLException {
                return statement.executeUpdate();
            }
        });
    }
```

ExecuteTemplate.executeæ ¹æ®ä¸åŒçš„è¯­å¥ç”Ÿæˆä¸åŒçš„æ‰§è¡Œå™¨

```java
    public static <T, S extends Statement> T execute(SQLRecognizer sqlRecognizer,
                                                     StatementProxy<S> statementProxy,
                                                     StatementCallback<T, S> statementCallback,
                                                     Object... args) throws SQLException {

        if (!RootConjava.inGlobalTransaction()) {
            // Just work as original statement
            return statementCallback.execute(statementProxy.getTargetStatement(), args);
        }

        if (sqlRecognizer == null) {
            sqlRecognizer = SQLVisitorFactory.get(
                    statementProxy.getTargetSQL(),
                    statementProxy.getConnectionProxy().getDbType());
        }
        Executor<T> executor = null;
        switch (sqlRecognizer.getSQLType()) {
            case INSERT:
                executor = new InsertExecutor<T, S>(statementProxy, statementCallback, sqlRecognizer);
                break;
            case UPDATE:
                executor = new UpdateExecutor<T, S>(statementProxy, statementCallback, sqlRecognizer);
                break;
            case DELETE:
                executor = new DeleteExecutor<T, S>(statementProxy, statementCallback, sqlRecognizer);
                break;
            case SELECT_FOR_UPDATE:
                executor = new SelectForUpdateExecutor(statementProxy, statementCallback, sqlRecognizer);
                break;
            default:
                executor = new PlainExecutor<T, S>(statementProxy, statementCallback, sqlRecognizer);
                break;
        }
        T rs = null;
        try {
            rs = executor.execute(args);

        } catch (Throwable ex) {
            if (ex instanceof SQLException) {
                throw (SQLException) ex;
            } else {
                // Turn everything into SQLException
                new SQLException(ex);
            }
        }
        return rs;
    }
```

ä»¥UpdateExecutorä¸ºä¾‹ï¼ŒUpdateExecutor.executeé€šè¿‡æ¨¡æ¿ç±»ä¼šè°ƒç”¨å¦‚ä¸‹æ–¹æ³•ï¼š

```java
    public T doExecute(Object... args) throws Throwable {
        AbstractConnectionProxy connectionProxy = statementProxy.getConnectionProxy();
        if (connectionProxy.getAutoCommit()) {
            return executeAutoCommitTrue(args);
        } else {
            return executeAutoCommitFalse(args);
        }
    }
```

å…·ä½“å®ç°ä¼šä¿å­˜æ›´æ”¹å‰åçš„æ•°æ®é•œåƒå¹¶æ’å…¥åˆ°undo logé‡Œå¹¶commitã€‚åªæœ‰å›æ»šç”¨undo logé‡Œçš„æ•°æ®ç”Ÿæˆsqlè¯­å¥å›æ»š

```java
    protected T executeAutoCommitFalse(Object[] args) throws Throwable {
        TableRecords beforeImage = beforeImage();
        T result = statementCallback.execute(statementProxy.getTargetStatement(), args);
        TableRecords afterImage = afterImage(beforeImage);
        statementProxy.getConnectionProxy().prepareUndoLog(sqlRecognizer.getSQLType(), sqlRecognizer.getTableName(), beforeImage, afterImage);
        return result;
    }
```

å›æ»šåœ¨ä¸Šä¸€ç¯‡å·²ç»è¯´äº†ï¼Œå°±ä¸å¤šè¯´äº†



ç”±äºATäº‹åŠ¡åœ¨ç¬¬ä¸€é˜¶æ®µå·²æäº¤ï¼Œæ‰€ä»¥commitè¿‡ç¨‹æ˜¯ç”±Asyncworkerå¼‚æ­¥åˆ é™¤undo logï¼ŒçœŸæ­£çš„commitæ˜¯åœ¨ç¬¬ä¸€é˜¶æ®µå®Œæˆçš„

```java
    public BranchStatus branchCommit(String xid, long branchId, String resourceId, String applicationData) throws TransactionException {
        return asyncWorker.branchCommit(xid, branchId, resourceId, applicationData);
    }
```



TableMetaCacheï¼š

è¿™ä¸ªç±»é‡Œå­˜å‚¨äº†ç¼“å­˜çš„TableMetaï¼ˆä¸€ä¸ªå°é—®é¢˜ï¼Œå¦‚æœtablemetaå‘ç”Ÿå˜æ›´å¦‚æœåº”ç”¨æœåŠ¡æ²¡æœ‰é‡å¯çš„è¯ï¼Œé»˜è®¤15åˆ†é’Ÿç¼“å­˜æ‰è¿‡æœŸã€‚è¿™ç§æƒ…å†µåº”è¯¥å¾ˆå°‘ï¼Œæ­£å¸¸æƒ…å†µä¸‹å¦‚æœtablemetaæœ‰å˜æ›´çš„è¯ï¼Œç›¸åº”çš„ä¸šåŠ¡åº”ç”¨åº”è¯¥éƒ½æœ‰ä»£ç å˜æ›´éœ€è¦é‡æ–°éƒ¨ç½²ï¼Œæˆ–è€…è€ƒè™‘æ•°æ®åº“æ›´æ”¹å¯¹åº”çš„ä¸šåŠ¡å…¼å®¹æ€§çš„é—®é¢˜ï¼‰