title: Tomcat 7 ä¸­ NIO å¤„ç†åˆ†æ
date: 2018-01-20
tag: 
categories: Tomcat
permalink: Tomcat/yuliu/NIO-process
author: é¢„æµ
from_url: https://juejin.im/post/5ab381a26fb9a028b410f9be
wechat_url: 

-------

æ‘˜è¦: åŸåˆ›å‡ºå¤„ https://juejin.im/post/5ab381a26fb9a028b410f9be ã€Œé¢„æµã€æ¬¢è¿è½¬è½½ï¼Œä¿ç•™æ‘˜è¦ï¼Œè°¢è°¢ï¼

  - [1.NioEndpoint ç±»æ ¸å¿ƒç»„ä»¶çš„åˆå§‹åŒ–](http://www.iocoder.cn/Tomcat/yuliu/NIO-process/)
  - [2.è¯·æ±‚æ¥æ”¶](http://www.iocoder.cn/Tomcat/yuliu/NIO-process/)
  - [3.Socket å‚æ•°è®¾ç½®](http://www.iocoder.cn/Tomcat/yuliu/NIO-process/)
  - [4.è¯»å–äº‹ä»¶æ³¨å†Œ](http://www.iocoder.cn/Tomcat/yuliu/NIO-process/)
  - [5.Poller å¤„ç†æµç¨‹](http://www.iocoder.cn/Tomcat/yuliu/NIO-process/)
  - [6.PollerEvent å¤„ç†æµç¨‹](http://www.iocoder.cn/Tomcat/yuliu/NIO-process/)
  - [7.å°† socket äº¤ç»™ Worker æ‰§è¡Œ](http://www.iocoder.cn/Tomcat/yuliu/NIO-process/)
  - [8.ä» socket ä¸­å¤„ç†è¯·æ±‚](http://www.iocoder.cn/Tomcat/yuliu/NIO-process/)

-------

![](http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg)

> ğŸ™‚ğŸ™‚ğŸ™‚å…³æ³¨**å¾®ä¿¡å…¬ä¼—å·ï¼šã€èŠ‹é“æºç ã€‘**æœ‰ç¦åˆ©ï¼š
> 1. RocketMQ / MyCAT / Sharding-JDBC **æ‰€æœ‰**æºç åˆ†ææ–‡ç« åˆ—è¡¨
> 2. RocketMQ / MyCAT / Sharding-JDBC **ä¸­æ–‡æ³¨é‡Šæºç  GitHub åœ°å€**
> 3. æ‚¨å¯¹äºæºç çš„ç–‘é—®æ¯æ¡ç•™è¨€**éƒ½**å°†å¾—åˆ°**è®¤çœŸ**å›å¤ã€‚**ç”šè‡³ä¸çŸ¥é“å¦‚ä½•è¯»æºç ä¹Ÿå¯ä»¥è¯·æ•™å™¢**ã€‚
> 4. **æ–°çš„**æºç è§£ææ–‡ç« **å®æ—¶**æ”¶åˆ°é€šçŸ¥ã€‚**æ¯å‘¨æ›´æ–°ä¸€ç¯‡å·¦å³**ã€‚
> 5. **è®¤çœŸçš„**æºç äº¤æµå¾®ä¿¡ç¾¤ã€‚

-------

Tomcat çš„ Connector æœ‰ä¸‰ç§è¿è¡Œæ¨¡å¼ bioã€nioã€apr ï¼Œå…ˆäº†è§£ä¸€ä¸‹è¿™ä¸‰ç§çš„åŒºåˆ«ã€‚

1. bio(blocking I/O)ï¼Œé¡¾åæ€ä¹‰å³é˜»å¡å¼ I/O æ“ä½œï¼Œè¡¨ç¤º Tomcat ä½¿ç”¨çš„æ˜¯ä¼ ç»Ÿçš„ Java  I/O æ“ä½œ(å³`java.io`åŒ…åŠå…¶å­åŒ…)ã€‚Tomcat åœ¨é»˜è®¤æƒ…å†µä¸‹ï¼Œå°±æ˜¯ä»¥ bio æ¨¡å¼è¿è¡Œçš„ã€‚ä¸€èˆ¬è€Œè¨€ bio æ¨¡å¼æ˜¯ä¸‰ç§è¿è¡Œæ¨¡å¼ä¸­æ€§èƒ½æœ€ä½çš„ä¸€ç§ã€‚
2. nio(new I/O)ï¼Œæ˜¯ Java SE 1.4 åŠåç»­ç‰ˆæœ¬æä¾›çš„ä¸€ç§æ–°çš„ I/O æ“ä½œæ–¹å¼(å³`java.nio`åŒ…åŠå…¶å­åŒ…)ã€‚Java  nio æ˜¯ä¸€ä¸ªåŸºäºç¼“å†²åŒºå¹¶èƒ½æä¾›éé˜»å¡ I/O æ“ä½œçš„ Java API ï¼Œå› æ­¤ nio ä¹Ÿè¢«çœ‹æˆæ˜¯ non-blocking I/O çš„ç¼©å†™ã€‚å®ƒæ‹¥æœ‰æ¯”ä¼ ç»Ÿ I/O æ“ä½œ( bio )æ›´å¥½çš„å¹¶å‘è¿è¡Œæ€§èƒ½ã€‚è¦è®© Tomcat ä»¥ nio æ¨¡å¼æ¥è¿è¡Œåªéœ€è¦åœ¨ Tomcat å®‰è£…ç›®å½•`/conf/server.xml`æ–‡ä»¶ä¸­å°† Connector èŠ‚ç‚¹çš„ protocol é…ç½®æˆ`org.apache.coyote.http11.Http11NioProtocol`å³å¯ã€‚
3. apr( Apache Portable Runtime/Apache å¯ç§»æ¤è¿è¡Œæ—¶)ï¼Œæ˜¯ Apache HTTP æœåŠ¡å™¨çš„æ”¯æŒåº“ã€‚å¯ä»¥ç®€å•åœ°ç†è§£ä¸º Tomcat å°†ä»¥ JNI çš„å½¢å¼è°ƒ ç”¨Apache HTTP æœåŠ¡å™¨çš„æ ¸å¿ƒåŠ¨æ€é“¾æ¥åº“æ¥å¤„ç†æ–‡ä»¶è¯»å–æˆ–ç½‘ç»œä¼ è¾“æ“ä½œï¼Œä»è€Œå¤§å¤§æé«˜ Tomcat å¯¹é™æ€æ–‡ä»¶çš„å¤„ç†æ€§èƒ½ã€‚ Tomcat apr ä¹Ÿæ˜¯åœ¨ Tomcat ä¸Šè¿è¡Œé«˜å¹¶å‘åº”ç”¨çš„é¦–é€‰æ¨¡å¼ã€‚

å†™ä¸ª BIO çš„ Socket æœåŠ¡å™¨è¿˜æ˜¯æ¯”è¾ƒå®¹æ˜“çš„ï¼Œæ— éæ˜¯æ¯ accept ä¸€ä¸ª socket ä¹‹åå°±æ‰”åˆ°ä¸€ä¸ªçº¿ç¨‹ä¸­å¤„ç†è¯·æ±‚ç”Ÿæˆå“åº”ï¼Œè¿™ç§æ–¹å¼å¯ä»¥æ”¹è¿›çš„ç‚¹å°±æ˜¯å¢åŠ çº¿ç¨‹æ± çš„æ”¯æŒï¼Œæœ¬æ–‡ä¸»è¦åˆ†æä¸€ä¸‹ Tomcat ä¸­ NIO å¤„ç†æ–¹å¼çš„ç›¸å…³ä»£ç é€»è¾‘ã€‚

å…³é”®ä»£ç éƒ½æ˜¯åœ¨`org.apache.tomcat.util.net.NioEndpoint`è¿™ä¸ªç±»é‡Œé¢ï¼Œå®ƒæ˜¯ Http11NioProtocol ä¸­è´Ÿè´£æ¥æ”¶å¤„ç† socket çš„ä¸»è¦ç»„ä»¶ï¼Œåˆ«çœ‹ä»£ç å¾ˆé•¿ï¼Œä»”ç»†é˜…è¯»ä¼šå‘ç°æœ‰å¾ˆå¤šå…±é€šçš„åœ°æ–¹ï¼Œå¦‚ï¼š

1. éƒ½ä¼šå¯¹JDKä¸­åŸæœ‰çš„APIåšä¸€ä¸‹æ‰©å±•æˆ–è€…åŒ…è£…ï¼Œå¦‚ ThreadPoolExecutor æ˜¯å¯¹`java.util.concurrent.ThreadPoolExecutor`çš„æ‰©å±•ï¼ŒNioChannel æ˜¯å¯¹ ByteChannel çš„æ‰©å±•ï¼ŒKeyAttachment åˆ™æ˜¯å¯¹ NioChannel çš„åŒ…è£…
2. å¾ˆå¤šç±»è®¾è®¡æˆé GC çš„ï¼Œæ–¹ä¾¿ç¼“å­˜å’Œé‡å¤ä½¿ç”¨ï¼Œå®ç°æ–¹å¼éƒ½æ˜¯é€šè¿‡ ConcurrentLinkedQueue ç±»æ„é€ ä¸€ä¸ªé˜Ÿåˆ—ã€‚æ¯”å¦‚ NioEndpoint ç±»é‡Œé¢çš„ ConcurrentLinkedQueue processorCacheã€ConcurrentLinkedQueue keyCacheã€ConcurrentLinkedQueue eventCacheã€ConcurrentLinkedQueue nioChannels ã€‚Poller ç±»é‡Œé¢çš„ ConcurrentLinkedQueue events

å…ˆçœ‹ä¸‹æ•´ä¸ª Connector ç»„ä»¶ç»“æ„å›¾ï¼š

![img](https://user-gold-cdn.xitu.io/2018/3/22/1624d3774929919d?imageView2/0/w/1280/h/960/format/jpeg/ignore-error/1)



çœ‹è¿‡ä¹‹å‰ Tomcat å¯åŠ¨æ–‡ç« çš„åº”è¯¥éƒ½çŸ¥é“ï¼ŒConnector çš„å¯åŠ¨ä¼šè°ƒç”¨ Connector ç±»çš„ startInternal æ–¹æ³•ï¼Œé‡Œé¢è°ƒç”¨äº† protocolHandler çš„ start() ï¼Œè¯¥æ–¹æ³•ä¸­å°†è°ƒç”¨æŠ½è±¡çš„ endpoint çš„ start() æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•ä¼šè°ƒç”¨åˆ°å…·ä½“ Endpoint ç±»çš„ startInternal() ï¼Œæ‰€ä»¥ä»£ç åˆ†æå…ˆä» NioEndpoint ç±»çš„ startInternal çœ‹èµ·ã€‚

## 1.NioEndpoint ç±»æ ¸å¿ƒç»„ä»¶çš„åˆå§‹åŒ–

```Java
/**
 * Start the NIO endpoint, creating acceptor, poller threads.
 */
@Override
public void startInternal() throws Exception {

    if (!running) {
        running = true;
        paused = false;

        // Create worker collection
        if ( getExecutor() == null ) {
            // æ„é€ çº¿ç¨‹æ± ï¼Œç”¨äºåç»­æ‰§è¡ŒSocketProcessorçº¿ç¨‹ï¼Œè¿™å°±æ˜¯ä¸Šå›¾ä¸­çš„Workerã€‚
            createExecutor();
        }

        initializeConnectionLatch();

        // Start poller threads
        // æ ¹æ®å¤„ç†å™¨æ•°é‡æ„é€ ä¸€å®šæ•°ç›®çš„è½®è¯¢å™¨ï¼Œå³ä¸Šå›¾ä¸­çš„Poller
        pollers = new Poller[getPollerThreadCount()];
        for (int i=0; i<pollers.length; i++) {
            pollers[i] = new Poller();
            Thread pollerThread = new Thread(pollers[i], getName() + "-ClientPoller-"+i);
            pollerThread.setPriority(threadPriority);
            pollerThread.setDaemon(true);
            pollerThread.start();
        }

        // åˆ›å»ºæ¥æ”¶è€…çº¿ç¨‹ï¼Œå³ä¸Šå›¾ä¸­çš„Acceptor
        startAcceptorThreads();
    }
}

```

startAcceptorThreads è°ƒç”¨çš„æ˜¯çˆ¶ç±»`org.apache.tomcat.util.net.AbstractEndpoint`ä¸­çš„å®ç°ï¼š

```Java
protected final void startAcceptorThreads() {
    int count = getAcceptorThreadCount();
    acceptors = new Acceptor[count];

    for (int i = 0; i < count; i++) {
        // è°ƒç”¨å­ç±»çš„createAcceptoræ–¹æ³•ï¼Œæœ¬ä¾‹ä¸­å³NioEndpointç±»çš„createAcceptoræ–¹æ³•
        acceptors[i] = createAcceptor();
        String threadName = getName() + "-Acceptor-" + i;
        acceptors[i].setThreadName(threadName);
        Thread t = new Thread(acceptors[i], threadName);
        t.setPriority(getAcceptorThreadPriority());
        t.setDaemon(getDaemon());
        t.start();
    }
}

```

ä»¥ä¸Šå°±æ˜¯ Acceptorã€Pollerã€Worker ç­‰æ ¸å¿ƒç»„ä»¶çš„åˆå§‹åŒ–è¿‡ç¨‹ã€‚

## 2.è¯·æ±‚æ¥æ”¶

æ ¸å¿ƒç»„ä»¶åˆå§‹åŒ–ä¹‹åæ¥ç€å°±æ˜¯ Acceptor çº¿ç¨‹æ¥æ”¶ socket è¿æ¥ï¼Œçœ‹ä¸‹ Acceptor çš„æºç ï¼š

```Java
// --------------------------------------------------- Acceptor Inner Class
/**
 * åå°çº¿ç¨‹ï¼Œç”¨äºç›‘å¬TCP/IPè¿æ¥ä»¥åŠå°†å®ƒä»¬åˆ†å‘ç»™ç›¸åº”çš„è°ƒåº¦å™¨å¤„ç†ã€‚
 * The background thread that listens for incoming TCP/IP connections and
 * hands them off to an appropriate processor.
 */
protected class Acceptor extends AbstractEndpoint.Acceptor {

    @Override
    public void run() {

        int errorDelay = 0;

        // å¾ªç¯éå†ç›´åˆ°æ¥æ”¶åˆ°å…³é—­å‘½ä»¤
        // Loop until we receive a shutdown command
        while (running) {

            // Loop if endpoint is paused
            while (paused && running) {
                state = AcceptorState.PAUSED;
                try {
                    Thread.sleep(50);
                } catch (InterruptedException e) {
                    // Ignore
                }
            }

            if (!running) {
                break;
            }
            state = AcceptorState.RUNNING;

            try {
                // å¦‚æœå·²ç»è¾¾åˆ°æœ€å¤§è¿æ¥æ•°åˆ™è®©çº¿ç¨‹ç­‰å¾…
                //if we have reached max connections, wait
                countUpOrAwaitConnection();

                SocketChannel socket = null;
                try {
                    // æ¥æ”¶è¿æ¥ï¼Œè¿™é‡Œç”¨çš„é˜»å¡æ¨¡å¼ã€‚
                    // Accept the next incoming connection from the server
                    // socket
                    socket = serverSock.accept();
                } catch (IOException ioe) {
                    //we didn't get a socket
                    countDownConnection();
                    // Introduce delay if necessary
                    errorDelay = handleExceptionWithDelay(errorDelay);
                    // re-throw
                    throw ioe;
                }
                // Successful accept, reset the error delay
                errorDelay = 0;

                // æ³¨æ„è¿™ä¸ªsetSocketOptionsæ–¹æ³•
                // å®ƒå°†æŠŠä¸Šé¢æ¥æ”¶åˆ°çš„socketæ·»åŠ åˆ°è½®è¯¢å™¨Pollerä¸­
                // setSocketOptions() will add channel to the poller
                // if successful
                if (running && !paused) {
                    if (!setSocketOptions(socket)) {
                        countDownConnection();
                        closeSocket(socket);
                    }
                } else {
                    countDownConnection();
                    closeSocket(socket);
                }
            } catch (SocketTimeoutException sx) {
                // Ignore: Normal condition
            } catch (IOException x) {
                if (running) {
                    log.error(sm.getString("endpoint.accept.fail"), x);
                }
            } catch (OutOfMemoryError oom) {
                try {
                    oomParachuteData = null;
                    releaseCaches();
                    log.error("", oom);
                }catch ( Throwable oomt ) {
                    try {
                        try {
                            System.err.println(oomParachuteMsg);
                            oomt.printStackTrace();
                        }catch (Throwable letsHopeWeDontGetHere){
                            ExceptionUtils.handleThrowable(letsHopeWeDontGetHere);
                        }
                    }catch (Throwable letsHopeWeDontGetHere){
                        ExceptionUtils.handleThrowable(letsHopeWeDontGetHere);
                    }
                }
            } catch (Throwable t) {
                ExceptionUtils.handleThrowable(t);
                log.error(sm.getString("endpoint.accept.fail"), t);
            }
        }
        state = AcceptorState.ENDED;
    }
}

```

## 3.Socket å‚æ•°è®¾ç½®

åœ¨ Acceptor é‡Œæ¥æ”¶åˆ°ä¸€ä¸ªè¿æ¥ä¹‹åè°ƒç”¨ setSocketOptions æ–¹æ³•è®¾ç½® SocketChannel çš„ä¸€äº›å‚æ•°ï¼Œç„¶åå°† SocketChannel æ³¨å†Œåˆ° Poller ä¸­ã€‚çœ‹ä¸‹ setSocketOptions çš„å®ç°ï¼š

```Java
/**
 * Process the specified connection.
 */
protected boolean setSocketOptions(SocketChannel socket) {
    // Process the connection
    try {
        // å°†SocketChannelé…ç½®ä¸ºéé˜»å¡æ¨¡å¼
        //disable blocking, APR style, we are gonna be polling it
        socket.configureBlocking(false);
        Socket sock = socket.socket();
        // è®¾ç½®Socketå‚æ•°å€¼ï¼ˆä»server.xmlçš„ConnectorèŠ‚ç‚¹ä¸Šè·å–å‚æ•°å€¼ï¼‰
        // æ¯”å¦‚Socketå‘é€ã€æ¥æ”¶çš„ç¼“å­˜å¤§å°ã€å¿ƒè·³æ£€æµ‹ç­‰
        socketProperties.setProperties(sock);

        // ä»NioChannelçš„ç¼“å­˜é˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªNioChannel
        // NioChannelæ˜¯SocketChannelçš„ä¸€ä¸ªçš„åŒ…è£…ç±»
        // è¿™é‡Œå¯¹ä¸Šå±‚å±è”½SSLå’Œä¸€èˆ¬TCPè¿æ¥çš„å·®å¼‚
        NioChannel channel = nioChannels.poll();

        // ç¼“å­˜é˜Ÿåˆ—ä¸­æ²¡æœ‰åˆ™æ–°å»ºä¸€ä¸ªNioChannel
        if ( channel == null ) {
            // SSL setup
            if (sslContext != null) {
                SSLEngine engine = createSSLEngine();
                int appbufsize = engine.getSession().getApplicationBufferSize();
                NioBufferHandler bufhandler = new NioBufferHandler(Math.max(appbufsize,socketProperties.getAppReadBufSize()),
                                                                   Math.max(appbufsize,socketProperties.getAppWriteBufSize()),
                                                                   socketProperties.getDirectBuffer());
                channel = new SecureNioChannel(socket, engine, bufhandler, selectorPool);
            } else {
                // normal tcp setup
                NioBufferHandler bufhandler = new NioBufferHandler(socketProperties.getAppReadBufSize(),
                                                                   socketProperties.getAppWriteBufSize(),
                                                                   socketProperties.getDirectBuffer());

                channel = new NioChannel(socket, bufhandler);
            }
        } else {
            // å°†SocketChannelå…³è”åˆ°ä»ç¼“å­˜é˜Ÿåˆ—ä¸­è·å–çš„NioChannelä¸Šæ¥
            channel.setIOChannel(socket);
            if ( channel instanceof SecureNioChannel ) {
                SSLEngine engine = createSSLEngine();
                ((SecureNioChannel)channel).reset(engine);
            } else {
                channel.reset();
            }
        }
        // å°†æ–°æ¥æ”¶åˆ°çš„SocketChannelæ³¨å†Œåˆ°Pollerä¸­
        getPoller0().register(channel);
    } catch (Throwable t) {
        ExceptionUtils.handleThrowable(t);
        try {
            log.error("",t);
        } catch (Throwable tt) {
            ExceptionUtils.handleThrowable(t);
        }
        // Tell to close the socket
        return false;
    }
    return true;
}

```

æ ¸å¿ƒè°ƒç”¨æ˜¯æœ€åçš„`getPoller0().register(channel);`å®ƒå°†é…ç½®å¥½çš„ SocketChannel åŒ…è£…æˆä¸€ä¸ª PollerEvent ï¼Œç„¶ååŠ å…¥åˆ° Poller çš„ events ç¼“å­˜é˜Ÿåˆ—ä¸­ã€‚

## 4.è¯»å–äº‹ä»¶æ³¨å†Œ

getPoller0 æ–¹æ³•å°†è½®è¯¢å½“å‰çš„ Poller æ•°ç»„ï¼Œä»ä¸­å–å‡ºä¸€ä¸ª Poller è¿”å›ã€‚ï¼ˆ Poller çš„åˆå§‹åŒ–å‚è§ä¸Šè¿°ç¬¬1æ­¥ï¼šNioEndpoint ç±»æ ¸å¿ƒç»„ä»¶çš„åˆå§‹åŒ–ï¼‰

```Java
/**
 * Return an available poller in true round robin fashion
 */
public Poller getPoller0() {
    // æœ€ç®€å•çš„è½®è¯¢è°ƒåº¦ç®—æ³•ï¼Œpollerçš„è®¡æ•°å™¨ä¸æ–­åŠ 1å†å¯¹polleræ•°ç»„å–ä½™æ•°
    int idx = Math.abs(pollerRotater.incrementAndGet()) % pollers.length;
    return pollers[idx];
}

```

ä¹‹åè°ƒç”¨ Poller å¯¹è±¡çš„ register æ–¹æ³•ï¼š

```Java
        public void register(final NioChannel socket) {
            // è®¾ç½®socketçš„Pollerå¼•ç”¨ï¼Œä¾¿äºåç»­å¤„ç†
            socket.setPoller(this);
            // ä»NioEndpointçš„keyCacheç¼“å­˜é˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªKeyAttachment
            KeyAttachment key = keyCache.poll();
            // KeyAttachmentå®é™…æ˜¯NioChannelçš„åŒ…è£…ç±»
            final KeyAttachment ka = key!=null?key:new KeyAttachment(socket);
            // é‡ç½®KeyAttachmentå¯¹è±¡ä¸­Pollerã€NioChannelç­‰æˆå‘˜å˜é‡çš„å¼•ç”¨
            ka.reset(this,socket,getSocketProperties().getSoTimeout());
            ka.setKeepAliveLeft(NioEndpoint.this.getMaxKeepAliveRequests());
            ka.setSecure(isSSLEnabled());

            // ä»Pollerçš„äº‹ä»¶å¯¹è±¡ç¼“å­˜ä¸­å–å‡ºä¸€ä¸ªPollerEventï¼Œå¹¶ç”¨socketåˆå§‹åŒ–äº‹ä»¶å¯¹è±¡
            PollerEvent r = eventCache.poll();
            // è®¾ç½®è¯»æ“ä½œä¸ºæ„Ÿå…´è¶£çš„æ“ä½œ
            ka.interestOps(SelectionKey.OP_READ);//this is what OP_REGISTER turns into.
            if ( r==null) r = new PollerEvent(socket,ka,OP_REGISTER);
            else r.reset(socket,ka,OP_REGISTER);

            // åŠ å…¥åˆ°Pollerå¯¹è±¡é‡Œçš„äº‹ä»¶é˜Ÿåˆ—
            addEvent(r);
        }

```

çœ‹ä¸‹ Poller ç±»é‡Œ addEvent çš„ä»£ç ï¼š

```Java
        /**
         * Only used in this class. Will be made private in Tomcat 8.0.x
         * @deprecated
         */
        @Deprecated
        public void addEvent(Runnable event) {
            events.offer(event);
            if ( wakeupCounter.incrementAndGet() == 0 ) selector.wakeup();
        }

```

å°±ä¸¤è¡Œï¼Œç¬¬ä¸€è¡Œä» event å¯¹è±¡æ·»åŠ åˆ°ç¼“å­˜é˜Ÿåˆ—ä¸­ï¼Œç¬¬äºŒè¡Œå¦‚æœå½“å‰äº‹ä»¶é˜Ÿåˆ—ä¸­æ²¡æœ‰äº‹ä»¶ï¼Œåˆ™å”¤é†’å¤„äºé˜»å¡çŠ¶æ€çš„ selector ã€‚

## 5.Poller å¤„ç†æµç¨‹

ä¸Šé¢è®²çš„æ˜¯ä» Acceptor ä¸­æ¥æ”¶åˆ°çš„ Socket ä»¥ PollerEvent çš„å½¢å¼åŒ…è£…å¹¶æ·»åŠ åˆ° Poller çš„äº‹ä»¶ç¼“å­˜é˜Ÿåˆ—ä¸­ï¼Œæ¥ä¸‹æ¥çœ‹çœ‹å¦å¤–ä¸€ä¸ªæ ¸å¿ƒç»„ä»¶ Poller çš„å¤„ç†è¿‡ç¨‹ï¼š

```Java
    /**
     * Poller class.
     */
    public class Poller implements Runnable {

        // è¿™å°±æ˜¯NIOä¸­ç”¨åˆ°çš„é€‰æ‹©å™¨ï¼Œå¯ä»¥çœ‹å‡ºæ¯ä¸€ä¸ªPolleréƒ½ä¼šå…³è”ä¸€ä¸ªSelector
        protected Selector selector;
        // å¾…å¤„ç†çš„äº‹ä»¶é˜Ÿåˆ—
        protected ConcurrentLinkedQueue events = new ConcurrentLinkedQueue();

        // å”¤é†’å¤šè·¯å¤ç”¨å™¨çš„æ¡ä»¶é˜ˆå€¼
        protected AtomicLong wakeupCounter = new AtomicLong(0l);

        public Poller() throws IOException {
            // å¯¹Selectorçš„åŒæ­¥è®¿é—®ï¼Œé€šè¿‡è°ƒç”¨Selector.open()æ–¹æ³•åˆ›å»ºä¸€ä¸ªSelector
            synchronized (Selector.class) {
                // Selector.open() isn't thread safe
                // http://bugs.sun.com/view_bug.do?bug_id=6427854
                // Affects 1.6.0_29, fixed in 1.7.0_01
                this.selector = Selector.open();
            }
        }

        // é€šè¿‡addEventæ–¹æ³•å°†äº‹ä»¶æ·»åŠ åˆ°Pollerçš„äº‹ä»¶é˜Ÿåˆ—ä¸­
        /**
         * Only used in this class. Will be made private in Tomcat 8.0.x
         * @deprecated
         */
        @Deprecated
        public void addEvent(Runnable event) {
            events.offer(event);
            // å¦‚æœé˜Ÿåˆ—ä¸­æ²¡æœ‰å¾…å¤„ç†çš„äº‹ä»¶åˆ™å”¤é†’å¤„äºé˜»å¡çŠ¶æ€çš„selector
            if ( wakeupCounter.incrementAndGet() == 0 ) selector.wakeup();
        }

        // å¤„ç†äº‹ä»¶é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰äº‹ä»¶ï¼Œå¦‚æœäº‹ä»¶é˜Ÿåˆ—æ˜¯ç©ºçš„åˆ™è¿”å›false
        /**
         * Processes events in the event queue of the Poller.
         *
         * @return true if some events were processed,
         *   false if queue was empty
         */
        public boolean events() {
            boolean result = false;

            Runnable r = null;
            // å°†Pollerçš„äº‹ä»¶é˜Ÿåˆ—ä¸­çš„äº‹ä»¶é€ä¸ªå–å‡ºå¹¶æ‰§è¡Œç›¸åº”çš„äº‹ä»¶çº¿ç¨‹
            while ( (r = events.poll()) != null ) {
                result = true;
                try {
                    // æ‰§è¡Œäº‹ä»¶å¤„ç†é€»è¾‘
                    // è¿™é‡Œå°†äº‹ä»¶è®¾è®¡æˆçº¿ç¨‹æ˜¯å°†å…·ä½“çš„äº‹ä»¶å¤„ç†é€»è¾‘å’Œäº‹ä»¶æ¡†æ¶åˆ†å¼€
                    r.run();
                    if ( r instanceof PollerEvent ) {
                        ((PollerEvent)r).reset();
                        // äº‹ä»¶å¤„ç†å®Œä¹‹åï¼Œå°†äº‹ä»¶å¯¹è±¡è¿”å›NIOEndpointçš„äº‹ä»¶å¯¹è±¡ç¼“å­˜ä¸­
                        eventCache.offer((PollerEvent)r);
                    }
                } catch ( Throwable x ) {
                    log.error("",x);
                }
            }

            return result;
        }

        // å°†socketåŒ…è£…æˆç»Ÿä¸€çš„äº‹ä»¶å¯¹è±¡PollerEventï¼ŒåŠ å…¥åˆ°å¾…å¤„ç†äº‹ä»¶é˜Ÿåˆ—ä¸­
        public void register(final NioChannel socket) {
            socket.setPoller(this);
            KeyAttachment key = keyCache.poll();
            final KeyAttachment ka = key!=null?key:new KeyAttachment(socket);
            ka.reset(this,socket,getSocketProperties().getSoTimeout());
            ka.setKeepAliveLeft(NioEndpoint.this.getMaxKeepAliveRequests());
            ka.setSecure(isSSLEnabled());
            // ä»NIOEndpointçš„äº‹ä»¶å¯¹è±¡ç¼“å­˜ä¸­å–å‡ºä¸€ä¸ªäº‹ä»¶å¯¹è±¡
            PollerEvent r = eventCache.poll();
            ka.interestOps(SelectionKey.OP_READ);//this is what OP_REGISTER turns into.
            if ( r==null) r = new PollerEvent(socket,ka,OP_REGISTER);
            else r.reset(socket,ka,OP_REGISTER);
            // å°†äº‹ä»¶æ·»åŠ æ‰“Pollerçš„äº‹ä»¶é˜Ÿåˆ—ä¸­
            addEvent(r);
        }

        // Polleræ˜¯ä¸€ä¸ªçº¿ç¨‹ï¼Œè¯¥çº¿ç¨‹åŒAcceptorä¸€æ ·ä¼šç›‘å¬TCP/IPè¿æ¥å¹¶å°†å®ƒä»¬äº¤ç»™åˆé€‚çš„å¤„ç†å™¨å¤„ç†
        /**
         * The background thread that listens for incoming TCP/IP connections and
         * hands them off to an appropriate processor.
         */
        @Override
        public void run() {
            // Loop until destroy() is called
            while (true) {
                try {
                    // Loop if endpoint is paused
                    while (paused && (!close) ) {
                        try {
                            Thread.sleep(100);
                        } catch (InterruptedException e) {
                            // Ignore
                        }
                    }

                    boolean hasEvents = false;

                    // Time to terminate?
                    if (close) {
                        events();
                        timeout(0, false);
                        try {
                            selector.close();
                        } catch (IOException ioe) {
                            log.error(sm.getString(
                                    "endpoint.nio.selectorCloseFail"), ioe);
                        }
                        break;
                    } else {
                        // æ‰§è¡Œäº‹ä»¶é˜Ÿåˆ—ä¸­çš„äº‹ä»¶çº¿ç¨‹
                        hasEvents = events();
                    }
                    try {
                        if ( !close ) {
                            if (wakeupCounter.getAndSet(-1) > 0) {
                                // æŠŠwakeupCounterè®¾æˆ-1ï¼Œè¿™æ˜¯ä¸addEventé‡Œçš„ä»£ç å‘¼åº”ï¼Œè¿™æ ·ä¼šå”¤é†’selector
                                //if we are here, means we have other stuff to do
                                //do a non blocking select
                                // ä»¥éé˜»å¡æ–¹å¼æŸ¥çœ‹selectoræ˜¯å¦æœ‰äº‹ä»¶å‘ç”Ÿ
                                keyCount = selector.selectNow();
                            } else {
                                // æŸ¥çœ‹selectoræ˜¯å¦æœ‰äº‹ä»¶å‘ç”Ÿï¼Œè¶…è¿‡æŒ‡å®šæ—¶é—´åˆ™ç«‹å³è¿”å›
                                keyCount = selector.select(selectorTimeout);
                            }
                            wakeupCounter.set(0);
                        }
                        if (close) {
                            // æ‰§è¡Œäº‹ä»¶é˜Ÿåˆ—ä¸­çš„äº‹ä»¶çº¿ç¨‹
                            events();
                            timeout(0, false);
                            try {
                                selector.close();
                            } catch (IOException ioe) {
                                log.error(sm.getString(
                                        "endpoint.nio.selectorCloseFail"), ioe);
                            }
                            break;
                        }
                    } catch ( NullPointerException x ) {
                        //sun bug 5076772 on windows JDK 1.5
                        if ( log.isDebugEnabled() ) log.debug("Possibly encountered sun bug 5076772 on windows JDK 1.5",x);
                        if ( wakeupCounter == null || selector == null ) throw x;
                        continue;
                    } catch ( CancelledKeyException x ) {
                        //sun bug 5076772 on windows JDK 1.5
                        if ( log.isDebugEnabled() ) log.debug("Possibly encountered sun bug 5076772 on windows JDK 1.5",x);
                        if ( wakeupCounter == null || selector == null ) throw x;
                        continue;
                    } catch (Throwable x) {
                        ExceptionUtils.handleThrowable(x);
                        log.error("",x);
                        continue;
                    }
                    //either we timed out or we woke up, process events first
                    if ( keyCount == 0 ) hasEvents = (hasEvents | events());

                    Iterator iterator =
                        keyCount > 0 ? selector.selectedKeys().iterator() : null;
                    // æ ¹æ®å‘selectorä¸­æ³¨å†Œçš„keyéå†channelä¸­å·²ç»å°±ç»ªçš„keysï¼Œå¹¶å¤„ç†è¿™äº›key
                    // Walk through the collection of ready keys and dispatch
                    // any active event.
                    while (iterator != null && iterator.hasNext()) {
                        SelectionKey sk = iterator.next();
                        // è¿™é‡Œçš„attachmentæ–¹æ³•è¿”å›çš„å°±æ˜¯åœ¨register()æ–¹æ³•ä¸­æ³¨å†Œçš„
                        // è€ŒKeyAttachmentå¯¹è±¡æ˜¯å¯¹socketçš„åŒ…è£…
                        KeyAttachment attachment = (KeyAttachment)sk.attachment();
                        // Attachment may be null if another thread has called
                        // cancelledKey()
                        if (attachment == null) {
                            iterator.remove();
                        } else {
                            // æ›´æ–°é€šé“æœ€è¿‘ä¸€æ¬¡å‘ç”Ÿäº‹ä»¶çš„æ—¶é—´
                            // é˜²æ­¢å› è¶…æ—¶æ²¡æœ‰äº‹ä»¶å‘ç”Ÿè€Œè¢«å‰”é™¤å‡ºselector
                            attachment.access();
                            iterator.remove();
                            // å…·ä½“å¤„ç†é€šé“çš„é€»è¾‘
                            processKey(sk, attachment);
                        }
                    }//while

                    //process timeouts
                    // å¤šè·¯å¤ç”¨å™¨æ¯æ‰§è¡Œä¸€éå®Œæ•´çš„è½®è¯¢ä¾¿æŸ¥çœ‹æ‰€æœ‰é€šé“æ˜¯å¦è¶…æ—¶
                    // å¯¹è¶…æ—¶çš„é€šé“å°†ä¼šè¢«å‰”é™¤å‡ºå¤šè·¯å¤ç”¨å™¨
                    timeout(keyCount,hasEvents);
                    if ( oomParachute > 0 && oomParachuteData == null ) checkParachute();
                } catch (OutOfMemoryError oom) {
                    try {
                        oomParachuteData = null;
                        releaseCaches();
                        log.error("", oom);
                    }catch ( Throwable oomt ) {
                        try {
                            System.err.println(oomParachuteMsg);
                            oomt.printStackTrace();
                        }catch (Throwable letsHopeWeDontGetHere){
                            ExceptionUtils.handleThrowable(letsHopeWeDontGetHere);
                        }
                    }
                }
            }//while
            synchronized (this) {
                this.notifyAll();
            }
            stopLatch.countDown();

        }

        // å¤„ç†selectoræ£€æµ‹åˆ°çš„é€šé“äº‹ä»¶
        protected boolean processKey(SelectionKey sk, KeyAttachment attachment) {
            boolean result = true;
            try {
                if ( close ) {
                    cancelledKey(sk, SocketStatus.STOP, attachment.comet);
                } else if ( sk.isValid() && attachment != null ) {
                    // ç¡®ä¿é€šé“ä¸ä¼šå› è¶…æ—¶è€Œè¢«å‰”é™¤
                    attachment.access();//make sure we don't time out valid sockets
                    sk.attach(attachment);//cant remember why this is here
                    NioChannel channel = attachment.getChannel();
                    // å¤„ç†é€šé“å‘ç”Ÿçš„è¯»å†™äº‹ä»¶
                    if (sk.isReadable() || sk.isWritable() ) {
                        if ( attachment.getSendfileData() != null ) {
                            processSendfile(sk,attachment, false);
                        } else {
                            if ( isWorkerAvailable() ) {
                                // åœ¨é€šé“ä¸Šæ³¨é”€å¯¹å·²ç»å‘ç”Ÿäº‹ä»¶çš„å…³æ³¨
                                unreg(sk, attachment, sk.readyOps());
                                boolean closeSocket = false;
                                // Read goes before write
                                if (sk.isReadable()) {
                                    // å…·ä½“çš„é€šé“å¤„ç†é€»è¾‘
                                    if (!processSocket(channel, SocketStatus.OPEN_READ, true)) {
                                        closeSocket = true;
                                    }
                                }
                                if (!closeSocket && sk.isWritable()) {
                                    if (!processSocket(channel, SocketStatus.OPEN_WRITE, true)) {
                                        closeSocket = true;
                                    }
                                }
                                if (closeSocket) {
                                    // è§£é™¤æ— æ•ˆé€šé“
                                    cancelledKey(sk,SocketStatus.DISCONNECT,false);
                                }
                            } else {
                                result = false;
                            }
                        }
                    }
                } else {
                    //invalid key
                    cancelledKey(sk, SocketStatus.ERROR,false);
                }
            } catch ( CancelledKeyException ckx ) {
                cancelledKey(sk, SocketStatus.ERROR,false);
            } catch (Throwable t) {
                ExceptionUtils.handleThrowable(t);
                log.error("",t);
            }
            return result;
        }

        // è¿™ä¸ªunreg()å¾ˆå·§å¦™ï¼Œé˜²æ­¢äº†é€šé“å¯¹åŒä¸€ä¸ªäº‹ä»¶ä¸æ–­selectçš„é—®é¢˜
        protected void unreg(SelectionKey sk, KeyAttachment attachment, int readyOps) {
            //this is a must, so that we don't have multiple threads messing with the socket
            reg(sk,attachment,sk.interestOps()& (~readyOps));
        }

        // å‘NioChannelæ³¨å†Œæ„Ÿå…´è¶£çš„äº‹ä»¶ï¼Œå…·ä½“ä»£ç çœ‹ä¸‹é¢çš„PollerEventç±»çš„è¯´æ˜
        protected void reg(SelectionKey sk, KeyAttachment attachment, int intops) {
            sk.interestOps(intops);
            attachment.interestOps(intops);
            attachment.setCometOps(intops);
        }

    }

```

## 6.PollerEvent å¤„ç†æµç¨‹

Poller å¤„ç†çš„æ ¸å¿ƒæ˜¯å¯åŠ¨æ‰§è¡Œäº‹ä»¶é˜Ÿåˆ—ä¸­çš„ PollerEventï¼Œæ¥ç€ä» selector ä¸­éå†å·²ç»å°±ç»ªçš„ key ï¼Œä¸€æ—¦å‘ç”Ÿäº†æ„Ÿå…´è¶£çš„äº‹ä»¶ï¼Œåˆ™äº¤ç”± processSocket æ–¹æ³•å¤„ç†ã€‚PollerEvent çš„ä½œç”¨æ˜¯å‘ socket æ³¨å†Œæˆ–æ›´æ–°æ„Ÿå…´è¶£çš„äº‹ä»¶ï¼š

```Java
    /**
     *
     * PollerEvent, cacheable object for poller events to avoid GC
     */
    public static class PollerEvent implements Runnable {

	// æ¯ä¸ªPollerEventéƒ½ä¼šä¿å­˜NioChannelçš„å¼•ç”¨
        protected NioChannel socket;
        protected int interestOps;
        protected KeyAttachment key;
        public PollerEvent(NioChannel ch, KeyAttachment k, int intOps) {
            reset(ch, k, intOps);
        }

        public void reset(NioChannel ch, KeyAttachment k, int intOps) {
            socket = ch;
            interestOps = intOps;
            key = k;
        }

        public void reset() {
            reset(null, null, 0);
        }

        @Override
        public void run() {
            //socketç¬¬ä¸€æ¬¡æ³¨å†Œåˆ°selectorä¸­ï¼Œå®Œæˆå¯¹socketè¯»äº‹ä»¶çš„æ³¨å†Œ
            if ( interestOps == OP_REGISTER ) {
                try {
                    socket.getIOChannel().register(socket.getPoller().getSelector(), SelectionKey.OP_READ, key);
                } catch (Exception x) {
                    log.error("", x);
                }
            } else {
                // socketä¹‹å‰å·²ç»æ³¨å†Œåˆ°äº†selectorä¸­ï¼Œæ›´æ–°socketæ‰€æ„Ÿå…´è¶£çš„äº‹ä»¶
                final SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());
                try {
                    boolean cancel = false;
                    if (key != null) {
                        final KeyAttachment att = (KeyAttachment) key.attachment();
                        if ( att!=null ) {
                            //handle callback flag
                            if (att.isComet() && (interestOps & OP_CALLBACK) == OP_CALLBACK ) {
                                att.setCometNotify(true);
                            } else {
                                att.setCometNotify(false);
                            }
                            interestOps = (interestOps & (~OP_CALLBACK));//remove the callback flag
                            // åˆ·æ–°äº‹ä»¶çš„æœ€åè®¿é—®æ—¶é—´ï¼Œé˜²æ­¢äº‹ä»¶è¶…æ—¶
                            att.access();//to prevent timeout
                            //we are registering the key to start with, reset the fairness counter.
                            int ops = key.interestOps() | interestOps;
                            att.interestOps(ops);
                            key.interestOps(ops);
                        } else {
                            cancel = true;
                        }
                    } else {
                        cancel = true;
                    }
                    if ( cancel ) socket.getPoller().cancelledKey(key,SocketStatus.ERROR,false);
                }catch (CancelledKeyException ckx) {
                    try {
                        socket.getPoller().cancelledKey(key,SocketStatus.DISCONNECT,true);
                    }catch (Exception ignore) {}
                }
            }//end if
        }//run

        @Override
        public String toString() {
            return super.toString()+"[intOps="+this.interestOps+"]";
        }
    }

```

## 7.å°† socket äº¤ç»™ Worker æ‰§è¡Œ

åœ¨ç¬¬5æ­¥çš„ Poller å¤„ç†æµç¨‹çš„åˆ†æä¸­çœ‹åˆ°å®ƒçš„ run æ–¹æ³•æœ€åä¼šè°ƒç”¨ processKey() å¤„ç† selector æ£€æµ‹åˆ°çš„é€šé“äº‹ä»¶ï¼Œè€Œåœ¨è¿™ä¸ªæ–¹æ³•æœ€åä¼šè°ƒç”¨ processSocket æ¥è°ƒç”¨å…·ä½“çš„é€šé“å¤„ç†é€»è¾‘ï¼Œçœ‹ä¸‹ processSocket æ–¹æ³•çš„å®ç°ï¼š

```Java
    public boolean processSocket(NioChannel socket, SocketStatus status, boolean dispatch) {
        try {
            KeyAttachment attachment = (KeyAttachment)socket.getAttachment();
            if (attachment == null) {
                return false;
            }
            attachment.setCometNotify(false); //will get reset upon next reg
            // ä»SocketProcessorçš„ç¼“å­˜é˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªæ¥å¤„ç†socket
            SocketProcessor sc = processorCache.poll();
            if ( sc == null ) sc = new SocketProcessor(socket,status);
            else sc.reset(socket,status);
            // å°†æœ‰äº‹ä»¶å‘ç”Ÿçš„socketäº¤ç»™Workerå¤„ç†
            if ( dispatch && getExecutor()!=null ) getExecutor().execute(sc);
            else sc.run();
        } catch (RejectedExecutionException rx) {
            log.warn("Socket processing request was rejected for:"+socket,rx);
            return false;
        } catch (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            // This means we got an OOM or similar creating a thread, or that
            // the pool and its queue are full
            log.error(sm.getString("endpoint.process.fail"), t);
            return false;
        }
        return true;
    }

```

Poller é€šè¿‡ NioEndpoint çš„åè°ƒï¼Œå°†å‘ç”Ÿäº‹ä»¶çš„ socket äº¤ç»™å·¥ä½œè€…çº¿ç¨‹ Worker æ¥è¿›ä¸€æ­¥å¤„ç†ã€‚æ•´ä¸ªäº‹ä»¶æ¡†æ¶çš„å·¥ä½œå°±åˆ°æ­¤ç»“æŸï¼Œä¸‹é¢å°±æ˜¯ Worker çš„å¤„ç†ã€‚

## 8.ä» socket ä¸­å¤„ç†è¯·æ±‚

åœ¨ Tomcat 6 ç‰ˆæœ¬çš„ NIO å¤„ç†å®ç°ä¸­æœ‰ä¸€ä¸ª Worker ç±»ï¼Œåœ¨ Tomcat 7 ä¸­æŠŠå®ƒå»æ‰äº†ï¼Œä½†å·¥ä½œè€…çš„èŒè´£è¿˜åœ¨ï¼Œåªæ˜¯äº¤ç”±äº†ä¸Šé¢çœ‹åˆ°çš„ SocketProcessor è¿™ä¸ªç±»æ¥æ‹…å½“ï¼Œçœ‹ä¸‹è¿™ä¸ªç±»çš„å®ç°ä»£ç ï¼š

```Java
    // ---------------------------------------------- SocketProcessor Inner Class
    // è¿™ä¸ªç±»ç›¸å½“äºä¸€ä¸ªå·¥ä½œè€…ï¼Œä½†åªä¼šåœ¨ä¸€ä¸ªå¤–éƒ¨çº¿ç¨‹æ± ä¸­ç®€å•ä½¿ç”¨ã€‚
    /**
     * This class is the equivalent of the Worker, but will simply use in an
     * external Executor thread pool.
     */
    protected class SocketProcessor implements Runnable {

        // æ¯ä¸ªSocketProcessorä¿å­˜ä¸€ä¸ªNioChannelçš„å¼•ç”¨
        protected NioChannel socket = null;
        protected SocketStatus status = null;

        public SocketProcessor(NioChannel socket, SocketStatus status) {
            reset(socket,status);
        }

        public void reset(NioChannel socket, SocketStatus status) {
            this.socket = socket;
            this.status = status;
        }

        @Override
        public void run() {
            // ä»socketä¸­è·å–SelectionKey
            SelectionKey key = socket.getIOChannel().keyFor(
                    socket.getPoller().getSelector());
            KeyAttachment ka = null;

            if (key != null) {
                ka = (KeyAttachment)key.attachment();
            }

            // Upgraded connections need to allow multiple threads to access the
            // connection at the same time to enable blocking IO to be used when
            // NIO has been configured
            if (ka != null && ka.isUpgraded() &&
                    SocketStatus.OPEN_WRITE == status) {
                synchronized (ka.getWriteThreadLock()) {
                    doRun(key, ka);
                }
            } else {
                synchronized (socket) {
                    doRun(key, ka);
                }
            }
        }

        private void doRun(SelectionKey key, KeyAttachment ka) {
            try {
                int handshake = -1;

                try {
                    if (key != null) {
                        // For STOP there is no point trying to handshake as the
                        // Poller has been stopped.
                        if (socket.isHandshakeComplete() ||
                                status == SocketStatus.STOP) {
                            handshake = 0;
                        } else {
                            handshake = socket.handshake(
                                    key.isReadable(), key.isWritable());
                            // The handshake process reads/writes from/to the
                            // socket. status may therefore be OPEN_WRITE once
                            // the handshake completes. However, the handshake
                            // happens when the socket is opened so the status
                            // must always be OPEN_READ after it completes. It
                            // is OK to always set this as it is only used if
                            // the handshake completes.
                            status = SocketStatus.OPEN_READ;
                        }
                    }
                }catch ( IOException x ) {
                    handshake = -1;
                    if ( log.isDebugEnabled() ) log.debug("Error during SSL handshake",x);
                }catch ( CancelledKeyException ckx ) {
                    handshake = -1;
                }
                if ( handshake == 0 ) {
                    SocketState state = SocketState.OPEN;
                    // Process the request from this socket
                    if (status == null) {
                        // æœ€å…³é”®çš„ä»£ç ï¼Œè¿™é‡Œå°†KeyAttachment(å®é™…å°±æ˜¯socket)äº¤ç»™Handlerå¤„ç†è¯·æ±‚
                        state = handler.process(ka, SocketStatus.OPEN_READ);
                    } else {
                        state = handler.process(ka, status);
                    }
                    if (state == SocketState.CLOSED) {
                        // Close socket and pool
                        try {
                            close(ka, socket, key, SocketStatus.ERROR);
                        } catch ( Exception x ) {
                            log.error("",x);
                        }
                    }
                } else if (handshake == -1 ) {
                    close(ka, socket, key, SocketStatus.DISCONNECT);
                } else {
                    ka.getPoller().add(socket, handshake);
                }
            } catch (CancelledKeyException cx) {
                socket.getPoller().cancelledKey(key, null, false);
            } catch (OutOfMemoryError oom) {
                try {
                    oomParachuteData = null;
                    log.error("", oom);
                    if (socket != null) {
                        socket.getPoller().cancelledKey(key,SocketStatus.ERROR, false);
                    }
                    releaseCaches();
                }catch ( Throwable oomt ) {
                    try {
                        System.err.println(oomParachuteMsg);
                        oomt.printStackTrace();
                    }catch (Throwable letsHopeWeDontGetHere){
                        ExceptionUtils.handleThrowable(letsHopeWeDontGetHere);
                    }
                }
            } catch (VirtualMachineError vme) {
                ExceptionUtils.handleThrowable(vme);
            }catch ( Throwable t ) {
                log.error("",t);
                if (socket != null) {
                    socket.getPoller().cancelledKey(key,SocketStatus.ERROR,false);
                }
            } finally {
                socket = null;
                status = null;
                //return to cache
                if (running && !paused) {
                    processorCache.offer(this);
                }
            }
        }

        private void close(KeyAttachment ka, NioChannel socket, SelectionKey key,
                SocketStatus socketStatus) {
		...
        }
    }

```

å¯ä»¥çœ‹åˆ°ç”± SocketProcessor å¯»æ‰¾åˆé€‚çš„ Handler å¤„ç†å™¨åšæœ€ç»ˆ socket è½¬æ¢å¤„ç†ã€‚

å¯ä»¥ç”¨ä¸‹é¢è¿™å¹…å›¾æ€»ç»“ä¸€ä¸‹ NioEndpoint çš„ä¸»è¦æµç¨‹ï¼š



![img](https://user-gold-cdn.xitu.io/2018/3/23/1625180ebec27d6c?imageView2/0/w/1280/h/960/format/jpeg/ignore-error/1)



Acceptor å’Œ Poller æ˜¯çº¿ç¨‹æ•°ç»„ï¼ŒWorker æ˜¯ä¸€ä¸ªçº¿ç¨‹æ± ï¼ˆ Executor ï¼‰