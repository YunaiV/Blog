title: Tomcat 7 çš„ä¸€æ¬¡è¯·æ±‚åˆ†æï¼ˆä¸‰ï¼‰è¯·æ±‚ä¸å®¹å™¨ä¸­å…·ä½“ç»„ä»¶çš„åŒ¹é…
date: 2018-01-12
tag: 
categories: Tomcat
permalink: Tomcat/yuliu/A-request-analysis-3-The-request-matches-specific-components-in-the-container
author: é¢„æµ
from_url: https://juejin.im/post/5a72c192518825732a6dd5c3
wechat_url: 

-------

æ‘˜è¦: åŸåˆ›å‡ºå¤„ https://juejin.im/post/5a72c192518825732a6dd5c3 ã€Œé¢„æµã€æ¬¢è¿è½¬è½½ï¼Œä¿ç•™æ‘˜è¦ï¼Œè°¢è°¢ï¼


-------

![](http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg)

> ğŸ™‚ğŸ™‚ğŸ™‚å…³æ³¨**å¾®ä¿¡å…¬ä¼—å·ï¼šã€èŠ‹é“æºç ã€‘**æœ‰ç¦åˆ©ï¼š
> 1. RocketMQ / MyCAT / Sharding-JDBC **æ‰€æœ‰**æºç åˆ†ææ–‡ç« åˆ—è¡¨
> 2. RocketMQ / MyCAT / Sharding-JDBC **ä¸­æ–‡æ³¨é‡Šæºç  GitHub åœ°å€**
> 3. æ‚¨å¯¹äºæºç çš„ç–‘é—®æ¯æ¡ç•™è¨€**éƒ½**å°†å¾—åˆ°**è®¤çœŸ**å›å¤ã€‚**ç”šè‡³ä¸çŸ¥é“å¦‚ä½•è¯»æºç ä¹Ÿå¯ä»¥è¯·æ•™å™¢**ã€‚
> 4. **æ–°çš„**æºç è§£ææ–‡ç« **å®æ—¶**æ”¶åˆ°é€šçŸ¥ã€‚**æ¯å‘¨æ›´æ–°ä¸€ç¯‡å·¦å³**ã€‚
> 5. **è®¤çœŸçš„**æºç äº¤æµå¾®ä¿¡ç¾¤ã€‚

-------

[ä¸Šæ–‡](http://www.iocoder.cn/Tomcat/yuliu/A-request-analysis-2-Socket-is-converted-to-an-internal-request-object)åˆ†æåˆ°äº†`org.apache.coyote.http11.AbstractHttp11Processor`ç±» process æ–¹æ³•ï¼Œä»¥è§£æè¯·æ±‚å¤´çš„ getInputBuffer().parseRequestLine æ–¹æ³•è°ƒç”¨ä¸ºä¾‹ï¼Œçœ‹åˆ°å¦‚ä½•ä» Socket çš„ IO æµä¸­å–å‡ºå­—èŠ‚æµæ•°æ®ï¼Œæ ¹æ® Http åè®®å°†å­—èŠ‚æµç»„è£…åˆ° Tomcat å†…éƒ¨çš„`org.apache.coyote.Request`å¯¹è±¡çš„ç›¸å…³å±æ€§ä¸­ã€‚

æ¥ä¸‹æ¥å°†ä¼šè§£é‡Šæ„é€ å¥½çš„ Tomcat çš„å†…éƒ¨è¯·æ±‚å¯¹è±¡ä» Connector åˆ° Engine åˆ° Host åˆ° Context æœ€ååˆ° Servlet çš„è¿‡ç¨‹ã€‚ å›åˆ°`org.apache.coyote.http11.AbstractHttp11Processor`ç±» process æ–¹æ³•çš„æºç ï¼š

```Java
     1	    public SocketState process(SocketWrapper<S> socketWrapper)
     2	        throws IOException {
     3	        RequestInfo rp = request.getRequestProcessor();
     4	        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);
     5
     6	        // Setting up the I/O
     7	        setSocketWrapper(socketWrapper);
     8	        getInputBuffer().init(socketWrapper, endpoint);
     9	        getOutputBuffer().init(socketWrapper, endpoint);
    10
    11	        // Flags
    12	        error = false;
    13	        keepAlive = true;
    14	        comet = false;
    15	        openSocket = false;
    16	        sendfileInProgress = false;
    17	        readComplete = true;
    18	        if (endpoint.getUsePolling()) {
    19	            keptAlive = false;
    20	        } else {
    21	            keptAlive = socketWrapper.isKeptAlive();
    22	        }
    23
    24	        if (disableKeepAlive()) {
    25	            socketWrapper.setKeepAliveLeft(0);
    26	        }
    27
    28	        while (!error && keepAlive && !comet && !isAsync() &&
    29	                upgradeInbound == null && !endpoint.isPaused()) {
    30
    31	            // Parsing the request header
    32	            try {
    33	                setRequestLineReadTimeout();
    34
    35	                if (!getInputBuffer().parseRequestLine(keptAlive)) {
    36	                    if (handleIncompleteRequestLineRead()) {
    37	                        break;
    38	                    }
    39	                }
    40
    41	                if (endpoint.isPaused()) {
    42	                    // 503 - Service unavailable
    43	                    response.setStatus(503);
    44	                    error = true;
    45	                } else {
    46	                    // Make sure that connectors that are non-blocking during
    47	                    // header processing (NIO) only set the start time the first
    48	                    // time a request is processed.
    49	                    if (request.getStartTime() < 0) {
    50	                        request.setStartTime(System.currentTimeMillis());
    51	                    }
    52	                    keptAlive = true;
    53	                    // Set this every time in case limit has been changed via JMX
    54	                    request.getMimeHeaders().setLimit(endpoint.getMaxHeaderCount());
    55	                    // Currently only NIO will ever return false here
    56	                    if (!getInputBuffer().parseHeaders()) {
    57	                        // We've read part of the request, don't recycle it
    58	                        // instead associate it with the socket
    59	                        openSocket = true;
    60	                        readComplete = false;
    61	                        break;
    62	                    }
    63	                    if (!disableUploadTimeout) {
    64	                        setSocketTimeout(connectionUploadTimeout);
    65	                    }
    66	                }
    67	            } catch (IOException e) {
    68	                if (getLog().isDebugEnabled()) {
    69	                    getLog().debug(
    70	                            sm.getString("http11processor.header.parse"), e);
    71	                }
    72	                error = true;
    73	                break;
    74	            } catch (Throwable t) {
    75	                ExceptionUtils.handleThrowable(t);
    76	                UserDataHelper.Mode logMode = userDataHelper.getNextMode();
    77	                if (logMode != null) {
    78	                    String message = sm.getString(
    79	                            "http11processor.header.parse");
    80	                    switch (logMode) {
    81	                        case INFO_THEN_DEBUG:
    82	                            message += sm.getString(
    83	                                    "http11processor.fallToDebug");
    84	                            //$FALL-THROUGH$
    85	                        case INFO:
    86	                            getLog().info(message);
    87	                            break;
    88	                        case DEBUG:
    89	                            getLog().debug(message);
    90	                    }
    91	                }
    92	                // 400 - Bad Request
    93	                response.setStatus(400);
    94	                adapter.log(request, response, 0);
    95	                error = true;
    96	            }
    97
    98	            if (!error) {
    99	                // Setting up filters, and parse some request headers
   100	                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);
   101	                try {
   102	                    prepareRequest();
   103	                } catch (Throwable t) {
   104	                    ExceptionUtils.handleThrowable(t);
   105	                    if (getLog().isDebugEnabled()) {
   106	                        getLog().debug(sm.getString(
   107	                                "http11processor.request.prepare"), t);
   108	                    }
   109	                    // 400 - Internal Server Error
   110	                    response.setStatus(400);
   111	                    adapter.log(request, response, 0);
   112	                    error = true;
   113	                }
   114	            }
   115
   116	            if (maxKeepAliveRequests == 1) {
   117	                keepAlive = false;
   118	            } else if (maxKeepAliveRequests > 0 &&
   119	                    socketWrapper.decrementKeepAlive() <= 0) {
   120	                keepAlive = false;
   121	            }
   122
   123	            // Process the request in the adapter
   124	            if (!error) {
   125	                try {
   126	                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
   127	                    adapter.service(request, response);
   128	                    // Handle when the response was committed before a serious
   129	                    // error occurred.  Throwing a ServletException should both
   130	                    // set the status to 500 and set the errorException.
   131	                    // If we fail here, then the response is likely already
   132	                    // committed, so we can't try and set headers.
   133	                    if(keepAlive && !error) { // Avoid checking twice.
   134	                        error = response.getErrorException() != null ||
   135	                                (!isAsync() &&
   136	                                statusDropsConnection(response.getStatus()));
   137	                    }
   138	                    setCometTimeouts(socketWrapper);
   139	                } catch (InterruptedIOException e) {
   140	                    error = true;
   141	                } catch (HeadersTooLargeException e) {
   142	                    error = true;
   143	                    // The response should not have been committed but check it
   144	                    // anyway to be safe
   145	                    if (!response.isCommitted()) {
   146	                        response.reset();
   147	                        response.setStatus(500);
   148	                        response.setHeader("Connection", "close");
   149	                    }
   150	                } catch (Throwable t) {
   151	                    ExceptionUtils.handleThrowable(t);
   152	                    getLog().error(sm.getString(
   153	                            "http11processor.request.process"), t);
   154	                    // 500 - Internal Server Error
   155	                    response.setStatus(500);
   156	                    adapter.log(request, response, 0);
   157	                    error = true;
   158	                }
   159	            }
   160
   161	            // Finish the handling of the request
   162	            rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);
   163
   164	            if (!isAsync() && !comet) {
   165	                if (error) {
   166	                    // If we know we are closing the connection, don't drain
   167	                    // input. This way uploading a 100GB file doesn't tie up the
   168	                    // thread if the servlet has rejected it.
   169	                    getInputBuffer().setSwallowInput(false);
   170	                }
   171	                endRequest();
   172	            }
   173
   174	            rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);
   175
   176	            // If there was an error, make sure the request is counted as
   177	            // and error, and update the statistics counter
   178	            if (error) {
   179	                response.setStatus(500);
   180	            }
   181	            request.updateCounters();
   182
   183	            if (!isAsync() && !comet || error) {
   184	                getInputBuffer().nextRequest();
   185	                getOutputBuffer().nextRequest();
   186	            }
   187
   188	            if (!disableUploadTimeout) {
   189	                if(endpoint.getSoTimeout() > 0) {
   190	                    setSocketTimeout(endpoint.getSoTimeout());
   191	                } else {
   192	                    setSocketTimeout(0);
   193	                }
   194	            }
   195
   196	            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);
   197
   198	            if (breakKeepAliveLoop(socketWrapper)) {
   199	                break;
   200	            }
   201	        }
   202
   203	        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
   204
   205	        if (error || endpoint.isPaused()) {
   206	            return SocketState.CLOSED;
   207	        } else if (isAsync() || comet) {
   208	            return SocketState.LONG;
   209	        } else if (isUpgrade()) {
   210	            return SocketState.UPGRADING;
   211	        } else {
   212	            if (sendfileInProgress) {
   213	                return SocketState.SENDFILE;
   214	            } else {
   215	                if (openSocket) {
   216	                    if (readComplete) {
   217	                        return SocketState.OPEN;
   218	                    } else {
   219	                        return SocketState.LONG;
   220	                    }
   221	                } else {
   222	                    return SocketState.CLOSED;
   223	                }
   224	            }
   225	        }
   226	    }

```

æ¦‚è¿°ä¸€ä¸‹è¿™ä¸ªæ–¹æ³•åšçš„äº‹æƒ…ï¼šç¬¬ 3 åˆ° 26 è¡Œä¸»è¦æ˜¯åœ¨åˆå§‹åŒ–å˜é‡ã€‚å…³æ³¨æ¥ä¸‹æ¥ä¸€å¤§æ®µçš„ while å¾ªç¯é‡Œé¢çš„ä»£ç ï¼Œç¬¬ 31 åˆ° 121 è¡Œåœ¨è§£æè¯·æ±‚å¤´ï¼Œç¬¬ 123 åˆ° 159 è¡Œå°†è¯·æ±‚äº¤ç”±é€‚é…å™¨ï¼ˆ adapter ï¼‰å¤„ç†ï¼Œç¬¬ 161 åˆ° 200 è¡Œç»“æŸè¯·æ±‚çš„å¤„ç†ï¼ˆåšä¸€äº›æ”¶å°¾å·¥ä½œï¼Œæ¯”å¦‚åºŸå¼ƒå‰©ä¸‹çš„æ— æ„ä¹‰å­—èŠ‚æµæ•°æ®ï¼Œè®¾ç½®ç›¸åº”çŠ¶æ€ç ç­‰ï¼‰ã€‚

è¯·æ±‚å¯¹è±¡åœ¨å®¹å™¨ä¸­çš„æµè½¬åœ¨ç¬¬ 127 è¡Œï¼š

```Java
adapter.service(request, response);

```

è¿™é‡Œçš„ adapter å¯¹è±¡æ˜¯åœ¨ Http11Processor å¯¹è±¡åˆ›å»ºçš„æ—¶å€™è®¾ç½®çš„ï¼Œè§`org.apache.coyote.http11.Http11Protocol.Http11ConnectionHandler`ç±»çš„ createProcessor æ–¹æ³•ï¼š

```Java
     1	        protected Http11Processor createProcessor() {
     2	            Http11Processor processor = new Http11Processor(
     3	                    proto.getMaxHttpHeaderSize(), (JIoEndpoint)proto.endpoint,
     4	                    proto.getMaxTrailerSize());
     5	            processor.setAdapter(proto.adapter);
     6	            processor.setMaxKeepAliveRequests(proto.getMaxKeepAliveRequests());
     7	            processor.setKeepAliveTimeout(proto.getKeepAliveTimeout());
     8	            processor.setConnectionUploadTimeout(
     9	                    proto.getConnectionUploadTimeout());
    10	            processor.setDisableUploadTimeout(proto.getDisableUploadTimeout());
    11	            processor.setCompressionMinSize(proto.getCompressionMinSize());
    12	            processor.setCompression(proto.getCompression());
    13	            processor.setNoCompressionUserAgents(proto.getNoCompressionUserAgents());
    14	            processor.setCompressableMimeTypes(proto.getCompressableMimeTypes());
    15	            processor.setRestrictedUserAgents(proto.getRestrictedUserAgents());
    16	            processor.setSocketBuffer(proto.getSocketBuffer());
    17	            processor.setMaxSavePostSize(proto.getMaxSavePostSize());
    18	            processor.setServer(proto.getServer());
    19	            processor.setDisableKeepAlivePercentage(
    20	                    proto.getDisableKeepAlivePercentage());
    21	            register(processor);
    22	            return processor;
    23	        }    }

```

å¯ä»¥çœ‹åˆ° adapter å¯¹è±¡è®¾ç½®çš„æ˜¯`org.apache.coyote.http11.Http11Protocol`çš„ adapter å˜é‡ï¼Œè€Œè¯¥å˜é‡æ˜¯åœ¨ Connector ç±»çš„ initInternal æ–¹æ³•ä¸­è®¾å€¼çš„ï¼š

```Java
     1	    protected void initInternal() throws LifecycleException {
     2
     3	        super.initInternal();
     4
     5	        // Initialize adapter
     6	        adapter = new CoyoteAdapter(this);
     7	        protocolHandler.setAdapter(adapter);
     8
     9	        // Make sure parseBodyMethodsSet has a default
    10	        if( null == parseBodyMethodsSet ) {
    11	            setParseBodyMethods(getParseBodyMethods());
    12	        }
    13
    14	        if (protocolHandler.isAprRequired() &&
    15	                !AprLifecycleListener.isAprAvailable()) {
    16	            throw new LifecycleException(
    17	                    sm.getString("coyoteConnector.protocolHandlerNoApr",
    18	                            getProtocolHandlerClassName()));
    19	        }
    20
    21	        try {
    22	            protocolHandler.init();
    23	        } catch (Exception e) {
    24	            throw new LifecycleException
    25	                (sm.getString
    26	                 ("coyoteConnector.protocolHandlerInitializationFailed"), e);
    27	        }
    28
    29	        // Initialize mapper listener
    30	        mapperListener.init();
    31	    }

```

ç¬¬ 6ã€7 è¡Œå°±æ˜¯åˆå§‹åŒ– adapter å¯¹è±¡å¹¶è®¾å€¼åˆ° Http11Protocol å¯¹è±¡ä¸­çš„ã€‚

æ‰€ä»¥ä¸Šé¢çœ‹åˆ°çš„`adapter.service(request, response)`æ–¹æ³•å®é™…æ‰§è¡Œçš„æ˜¯`org.apache.catalina.connector.CoyoteAdapter`ç±»çš„ service æ–¹æ³•ï¼š

```Java
     1	    public void service(org.apache.coyote.Request req,
     2	                        org.apache.coyote.Response res)
     3	        throws Exception {
     4
     5	        Request request = (Request) req.getNote(ADAPTER_NOTES);
     6	        Response response = (Response) res.getNote(ADAPTER_NOTES);
     7
     8	        if (request == null) {
     9
    10	            // Create objects
    11	            request = connector.createRequest();
    12	            request.setCoyoteRequest(req);
    13	            response = connector.createResponse();
    14	            response.setCoyoteResponse(res);
    15
    16	            // Link objects
    17	            request.setResponse(response);
    18	            response.setRequest(request);
    19
    20	            // Set as notes
    21	            req.setNote(ADAPTER_NOTES, request);
    22	            res.setNote(ADAPTER_NOTES, response);
    23
    24	            // Set query string encoding
    25	            req.getParameters().setQueryStringEncoding
    26	                (connector.getURIEncoding());
    27
    28	        }
    29
    30	        if (connector.getXpoweredBy()) {
    31	            response.addHeader("X-Powered-By", POWERED_BY);
    32	        }
    33
    34	        boolean comet = false;
    35	        boolean async = false;
    36
    37	        try {
    38
    39	            // Parse and set Catalina and configuration specific
    40	            // request parameters
    41	            req.getRequestProcessor().setWorkerThreadName(Thread.currentThread().getName());
    42	            boolean postParseSuccess = postParseRequest(req, request, res, response);
    43	            if (postParseSuccess) {
    44	                //check valves if we support async
    45	                request.setAsyncSupported(connector.getService().getContainer().getPipeline().isAsyncSupported());
    46	                // Calling the container
    47	                connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);
    48
    49	                if (request.isComet()) {
    50	                    if (!response.isClosed() && !response.isError()) {
    51	                        if (request.getAvailable() || (request.getContentLength() > 0 && (!request.isParametersParsed()))) {
    52	                            // Invoke a read event right away if there are available bytes
    53	                            if (event(req, res, SocketStatus.OPEN)) {
    54	                                comet = true;
    55	                                res.action(ActionCode.COMET_BEGIN, null);
    56	                            }
    57	                        } else {
    58	                            comet = true;
    59	                            res.action(ActionCode.COMET_BEGIN, null);
    60	                        }
    61	                    } else {
    62	                        // Clear the filter chain, as otherwise it will not be reset elsewhere
    63	                        // since this is a Comet request
    64	                        request.setFilterChain(null);
    65	                    }
    66	                }
    67
    68	            }
    69	            AsyncContextImpl asyncConImpl = (AsyncContextImpl)request.getAsyncContext();
    70	            if (asyncConImpl != null) {
    71	                async = true;
    72	            } else if (!comet) {
    73	                request.finishRequest();
    74	                response.finishResponse();
    75	                if (postParseSuccess &&
    76	                        request.getMappingData().context != null) {
    77	                    // Log only if processing was invoked.
    78	                    // If postParseRequest() failed, it has already logged it.
    79	                    // If context is null this was the start of a comet request
    80	                    // that failed and has already been logged.
    81	                    ((Context) request.getMappingData().context).logAccess(
    82	                            request, response,
    83	                            System.currentTimeMillis() - req.getStartTime(),
    84	                            false);
    85	                }
    86	                req.action(ActionCode.POST_REQUEST , null);
    87	            }
    88
    89	        } catch (IOException e) {
    90	            // Ignore
    91	        } finally {
    92	            req.getRequestProcessor().setWorkerThreadName(null);
    93	            // Recycle the wrapper request and response
    94	            if (!comet && !async) {
    95	                request.recycle();
    96	                response.recycle();
    97	            } else {
    98	                // Clear converters so that the minimum amount of memory
    99	                // is used by this processor
   100	                request.clearEncoders();
   101	                response.clearEncoders();
   102	            }
   103	        }
   104
   105	    }

```

è¿™æ®µä»£ç ä¸­å¯ä»¥çœ‹åˆ°å…¥å‚`org.apache.coyote.Request`å¯¹è±¡è¢«è½¬æˆäº†`org.apache.catalina.connector.Request`å¯¹è±¡ï¼Œåä¸€ç±»å‹çš„å¯¹è±¡æ‰æ˜¯åœ¨ Tomcat å®¹å™¨æµè½¬æ—¶çœŸæ­£ä¼ é€’çš„å¯¹è±¡ã€‚é‡ç‚¹å…³æ³¨ç¬¬ 42 è¡Œå’Œç¬¬ 47 è¡Œã€‚

åœ¨ç¬¬ 42 è¡Œè°ƒç”¨äº† postParseRequest æ–¹æ³•ï¼š

```Java
     1	    /**
     2	     * Parse additional request parameters.
     3	     */
     4	    protected boolean postParseRequest(org.apache.coyote.Request req,
     5	                                       Request request,
     6	                                       org.apache.coyote.Response res,
     7	                                       Response response)
     8	            throws Exception {
     9
    10	        // XXX the processor may have set a correct scheme and port prior to this point,
    11	        // in ajp13 protocols dont make sense to get the port from the connector...
    12	        // otherwise, use connector configuration
    13	        if (! req.scheme().isNull()) {
    14	            // use processor specified scheme to determine secure state
    15	            request.setSecure(req.scheme().equals("https"));
    16	        } else {
    17	            // use connector scheme and secure configuration, (defaults to
    18	            // "http" and false respectively)
    19	            req.scheme().setString(connector.getScheme());
    20	            request.setSecure(connector.getSecure());
    21	        }
    22
    23	        // FIXME: the code below doesnt belongs to here,
    24	        // this is only have sense
    25	        // in Http11, not in ajp13..
    26	        // At this point the Host header has been processed.
    27	        // Override if the proxyPort/proxyHost are set
    28	        String proxyName = connector.getProxyName();
    29	        int proxyPort = connector.getProxyPort();
    30	        if (proxyPort != 0) {
    31	            req.setServerPort(proxyPort);
    32	        }
    33	        if (proxyName != null) {
    34	            req.serverName().setString(proxyName);
    35	        }
    36
    37	        // Copy the raw URI to the decodedURI
    38	        MessageBytes decodedURI = req.decodedURI();
    39	        decodedURI.duplicate(req.requestURI());
    40
    41	        // Parse the path parameters. This will:
    42	        //   - strip out the path parameters
    43	        //   - convert the decodedURI to bytes
    44	        parsePathParameters(req, request);
    45
    46	        // URI decoding
    47	        // %xx decoding of the URL
    48	        try {
    49	            req.getURLDecoder().convert(decodedURI, false);
    50	        } catch (IOException ioe) {
    51	            res.setStatus(400);
    52	            res.setMessage("Invalid URI: " + ioe.getMessage());
    53	            connector.getService().getContainer().logAccess(
    54	                    request, response, 0, true);
    55	            return false;
    56	        }
    57	        // Normalization
    58	        if (!normalize(req.decodedURI())) {
    59	            res.setStatus(400);
    60	            res.setMessage("Invalid URI");
    61	            connector.getService().getContainer().logAccess(
    62	                    request, response, 0, true);
    63	            return false;
    64	        }
    65	        // Character decoding
    66	        convertURI(decodedURI, request);
    67	        // Check that the URI is still normalized
    68	        if (!checkNormalize(req.decodedURI())) {
    69	            res.setStatus(400);
    70	            res.setMessage("Invalid URI character encoding");
    71	            connector.getService().getContainer().logAccess(
    72	                    request, response, 0, true);
    73	            return false;
    74	        }
    75
    76	        // Set the remote principal
    77	        String principal = req.getRemoteUser().toString();
    78	        if (principal != null) {
    79	            request.setUserPrincipal(new CoyotePrincipal(principal));
    80	        }
    81
    82	        // Set the authorization type
    83	        String authtype = req.getAuthType().toString();
    84	        if (authtype != null) {
    85	            request.setAuthType(authtype);
    86	        }
    87
    88	        // Request mapping.
    89	        MessageBytes serverName;
    90	        if (connector.getUseIPVHosts()) {
    91	            serverName = req.localName();
    92	            if (serverName.isNull()) {
    93	                // well, they did ask for it
    94	                res.action(ActionCode.REQ_LOCAL_NAME_ATTRIBUTE, null);
    95	            }
    96	        } else {
    97	            serverName = req.serverName();
    98	        }
    99	        if (request.isAsyncStarted()) {
   100	            //TODO SERVLET3 - async
   101	            //reset mapping data, should prolly be done elsewhere
   102	            request.getMappingData().recycle();
   103	        }
   104
   105	        boolean mapRequired = true;
   106	        String version = null;
   107
   108	        while (mapRequired) {
   109	            if (version != null) {
   110	                // Once we have a version - that is it
   111	                mapRequired = false;
   112	            }
   113	            // This will map the the latest version by default
   114	            connector.getMapper().map(serverName, decodedURI, version,
   115	                                      request.getMappingData());
   116	            request.setContext((Context) request.getMappingData().context);
   117	            request.setWrapper((Wrapper) request.getMappingData().wrapper);
   118
   119	            // Single contextVersion therefore no possibility of remap
   120	            if (request.getMappingData().contexts == null) {
   121	                mapRequired = false;
   122	            }
   123
   124	            // If there is no context at this point, it is likely no ROOT context
   125	            // has been deployed
   126	            if (request.getContext() == null) {
   127	                res.setStatus(404);
   128	                res.setMessage("Not found");
   129	                // No context, so use host
   130	                Host host = request.getHost();
   131	                // Make sure there is a host (might not be during shutdown)
   132	                if (host != null) {
   133	                    host.logAccess(request, response, 0, true);
   134	                }
   135	                return false;
   136	            }
   137
   138	            // Now we have the context, we can parse the session ID from the URL
   139	            // (if any). Need to do this before we redirect in case we need to
   140	            // include the session id in the redirect
   141	            String sessionID = null;
   142	            if (request.getServletContext().getEffectiveSessionTrackingModes()
   143	                    .contains(SessionTrackingMode.URL)) {
   144
   145	                // Get the session ID if there was one
   146	                sessionID = request.getPathParameter(
   147	                        SessionConfig.getSessionUriParamName(
   148	                                request.getContext()));
   149	                if (sessionID != null) {
   150	                    request.setRequestedSessionId(sessionID);
   151	                    request.setRequestedSessionURL(true);
   152	                }
   153	            }
   154
   155	            // Look for session ID in cookies and SSL session
   156	            parseSessionCookiesId(req, request);
   157	            parseSessionSslId(request);
   158
   159	            sessionID = request.getRequestedSessionId();
   160
   161	            if (mapRequired) {
   162	                if (sessionID == null) {
   163	                    // No session means no possibility of needing to remap
   164	                    mapRequired = false;
   165	                } else {
   166	                    // Find the context associated with the session
   167	                    Object[] objs = request.getMappingData().contexts;
   168	                    for (int i = (objs.length); i > 0; i--) {
   169	                        Context ctxt = (Context) objs[i - 1];
   170	                        if (ctxt.getManager().findSession(sessionID) != null) {
   171	                            // Was the correct context already mapped?
   172	                            if (ctxt.equals(request.getMappingData().context)) {
   173	                                mapRequired = false;
   174	                            } else {
   175	                                // Set version so second time through mapping the
   176	                                // correct context is found
   177	                                version = ctxt.getWebappVersion();
   178	                                // Reset mapping
   179	                                request.getMappingData().recycle();
   180	                                break;
   181	                            }
   182	                        }
   183	                    }
   184	                    if (version == null) {
   185	                        // No matching context found. No need to re-map
   186	                        mapRequired = false;
   187	                    }
   188	                }
   189	            }
   190	            if (!mapRequired && request.getContext().getPaused()) {
   191	                // Found a matching context but it is paused. Mapping data will
   192	                // be wrong since some Wrappers may not be registered at this
   193	                // point.
   194	                try {
   195	                    Thread.sleep(1000);
   196	                } catch (InterruptedException e) {
   197	                    // Should never happen
   198	                }
   199	                // Reset mapping
   200	                request.getMappingData().recycle();
   201	                mapRequired = true;
   202	            }
   203	        }
   204
   205	        // Possible redirect
   206	        MessageBytes redirectPathMB = request.getMappingData().redirectPath;
   207	        if (!redirectPathMB.isNull()) {
   208	            String redirectPath = urlEncoder.encode(redirectPathMB.toString());
   209	            String query = request.getQueryString();
   210	            if (request.isRequestedSessionIdFromURL()) {
   211	                // This is not optimal, but as this is not very common, it
   212	                // shouldn't matter
   213	                redirectPath = redirectPath + ";" +
   214	                        SessionConfig.getSessionUriParamName(
   215	                            request.getContext()) +
   216	                    "=" + request.getRequestedSessionId();
   217	            }
   218	            if (query != null) {
   219	                // This is not optimal, but as this is not very common, it
   220	                // shouldn't matter
   221	                redirectPath = redirectPath + "?" + query;
   222	            }
   223	            response.sendRedirect(redirectPath);
   224	            request.getContext().logAccess(request, response, 0, true);
   225	            return false;
   226	        }
   227
   228	        // Filter trace method
   229	        if (!connector.getAllowTrace()
   230	                && req.method().equalsIgnoreCase("TRACE")) {
   231	            Wrapper wrapper = request.getWrapper();
   232	            String header = null;
   233	            if (wrapper != null) {
   234	                String[] methods = wrapper.getServletMethods();
   235	                if (methods != null) {
   236	                    for (int i=0; i<methods.length; i++) {
   237	                        if ("TRACE".equals(methods[i])) {
   238	                            continue;
   239	                        }
   240	                        if (header == null) {
   241	                            header = methods[i];
   242	                        } else {
   243	                            header += ", " + methods[i];
   244	                        }
   245	                    }
   246	                }
   247	            }
   248	            res.setStatus(405);
   249	            res.addHeader("Allow", header);
   250	            res.setMessage("TRACE method is not allowed");
   251	            request.getContext().logAccess(request, response, 0, true);
   252	            return false;
   253	        }
   254
   255	        return true;
   256	    }

```

è¿™æ®µä»£ç çš„ä¸»è¦ä½œç”¨æ˜¯ç»™`org.apache.catalina.connector.Request`å¯¹è±¡è®¾å€¼ï¼Œå…¶ä¸­ç¬¬ 113 åˆ° 117 è¡Œï¼š

```Java
            // This will map the the latest version by default
            connector.getMapper().map(serverName, decodedURI, version,
                                      request.getMappingData());
            request.setContext((Context) request.getMappingData().context);
            request.setWrapper((Wrapper) request.getMappingData().wrapper);

```

çœ‹ä¸‹ map æ–¹æ³•çš„ä»£ç ï¼Œæ³¨æ„è¯¥æ–¹æ³•çš„æœ€åä¸€ä¸ªå…¥å‚æ˜¯ request.getMappingData() ï¼š

```Java
    public void map(MessageBytes host, MessageBytes uri, String version,
                    MappingData mappingData)
        throws Exception {

        if (host.isNull()) {
            host.getCharChunk().append(defaultHostName);
        }
        host.toChars();
        uri.toChars();
        internalMap(host.getCharChunk(), uri.getCharChunk(), version,
                mappingData);

    }

```

å¯ä»¥çœ‹åˆ°è¿™é‡Œæœ€åè°ƒç”¨äº†`org.apache.tomcat.util.http.mapper.Mapper`ç±»çš„ internalMap æ–¹æ³•ï¼Œå¹¶ä¸”è¯¥æ–¹æ³•æœ€åä¸€ä¸ªå…¥å‚å®é™…ä¸Šæ˜¯ä¸Šä¸€æ®µä»£ç æåˆ°çš„ request.getMappingData() ã€‚çœ‹ä¸‹ internalMap æ–¹æ³•é‡Œé¢åšäº†äº›ä»€ä¹ˆï¼š

```Java
     1	    /**
     2	     * Map the specified URI.
     3	     */
     4	    private final void internalMap(CharChunk host, CharChunk uri,
     5	            String version, MappingData mappingData) throws Exception {
     6
     7	        uri.setLimit(-1);
     8
     9	        Context[] contexts = null;
    10	        Context context = null;
    11	        ContextVersion contextVersion = null;
    12
    13	        int nesting = 0;
    14
    15	        // Virtual host mapping
    16	        if (mappingData.host == null) {
    17	            Host[] hosts = this.hosts;
    18	            int pos = findIgnoreCase(hosts, host);
    19	            if ((pos != -1) && (host.equalsIgnoreCase(hosts[pos].name))) {
    20	                mappingData.host = hosts[pos].object;
    21	                contexts = hosts[pos].contextList.contexts;
    22	                nesting = hosts[pos].contextList.nesting;
    23	            } else {
    24	                if (defaultHostName == null) {
    25	                    return;
    26	                }
    27	                pos = find(hosts, defaultHostName);
    28	                if ((pos != -1) && (defaultHostName.equals(hosts[pos].name))) {
    29	                    mappingData.host = hosts[pos].object;
    30	                    contexts = hosts[pos].contextList.contexts;
    31	                    nesting = hosts[pos].contextList.nesting;
    32	                } else {
    33	                    return;
    34	                }
    35	            }
    36	        }
    37
    38	        // Context mapping
    39	        if (mappingData.context == null) {
    40	            int pos = find(contexts, uri);
    41	            if (pos == -1) {
    42	                return;
    43	            }
    44
    45	            int lastSlash = -1;
    46	            int uriEnd = uri.getEnd();
    47	            int length = -1;
    48	            boolean found = false;
    49	            while (pos >= 0) {
    50	                if (uri.startsWith(contexts[pos].name)) {
    51	                    length = contexts[pos].name.length();
    52	                    if (uri.getLength() == length) {
    53	                        found = true;
    54	                        break;
    55	                    } else if (uri.startsWithIgnoreCase("/", length)) {
    56	                        found = true;
    57	                        break;
    58	                    }
    59	                }
    60	                if (lastSlash == -1) {
    61	                    lastSlash = nthSlash(uri, nesting + 1);
    62	                } else {
    63	                    lastSlash = lastSlash(uri);
    64	                }
    65	                uri.setEnd(lastSlash);
    66	                pos = find(contexts, uri);
    67	            }
    68	            uri.setEnd(uriEnd);
    69
    70	            if (!found) {
    71	                if (contexts[0].name.equals("")) {
    72	                    context = contexts[0];
    73	                }
    74	            } else {
    75	                context = contexts[pos];
    76	            }
    77	            if (context != null) {
    78	                mappingData.contextPath.setString(context.name);
    79	            }
    80	        }
    81
    82	        if (context != null) {
    83	            ContextVersion[] contextVersions = context.versions;
    84	            int versionCount = contextVersions.length;
    85	            if (versionCount > 1) {
    86	                Object[] contextObjects = new Object[contextVersions.length];
    87	                for (int i = 0; i < contextObjects.length; i++) {
    88	                    contextObjects[i] = contextVersions[i].object;
    89	                }
    90	                mappingData.contexts = contextObjects;
    91	            }
    92
    93	            if (version == null) {
    94	                // Return the latest version
    95	                contextVersion = contextVersions[versionCount - 1];
    96	            } else {
    97	                int pos = find(contextVersions, version);
    98	                if (pos < 0 || !contextVersions[pos].name.equals(version)) {
    99	                    // Return the latest version
   100	                    contextVersion = contextVersions[versionCount - 1];
   101	                } else {
   102	                    contextVersion = contextVersions[pos];
   103	                }
   104	            }
   105	            mappingData.context = contextVersion.object;
   106	        }
   107
   108	        // Wrapper mapping
   109	        if ((contextVersion != null) && (mappingData.wrapper == null)) {
   110	            internalMapWrapper(contextVersion, uri, mappingData);
   111	        }
   112
   113	    }

```

è¯´ç™½äº†å°±æ˜¯ç»™è¯¥æ–¹æ³•çš„å…¥å‚ mappingData çš„å‡ ä¸ªå®ä¾‹å˜é‡è®¾ç½®å€¼ï¼Œæ¯”å¦‚ mappingData.hostã€mappingData.contextPathã€mappingData.contextsã€mappingData.wrapper ï¼Œå›åˆ°ä¸Šä¸€æ®µæåˆ°çš„ mappingData å˜é‡å®é™…ä¸Šæ˜¯`org.apache.catalina.connector.Request`å¯¹è±¡å†…ç½®å˜é‡ mappingData ã€‚å›åˆ°ä¸Šé¢æåˆ°çš„è¦é‡ç‚¹å…³æ³¨çš„`org.apache.catalina.connector.CoyoteAdapter`çš„postParseRequest æ–¹æ³•çš„ 114 åˆ° 117è¡Œï¼š

```Java
            connector.getMapper().map(serverName, decodedURI, version,
                                      request.getMappingData());
            request.setContext((Context) request.getMappingData().context);
            request.setWrapper((Wrapper) request.getMappingData().wrapper);

```

ä¸Šé¢ä¹‹æ‰€ä»¥ä¸åŒå…¶çƒ¦çš„æŠŠå®ç°ä»£ç è´´å‡ºæ¥å°±æ˜¯ä¸ºäº†èƒ½å¤Ÿçœ‹æ¸…æ¥šè¿™ä¸‰è¡Œä»£ç çš„å…·ä½“å«ä¹‰ï¼Œå³é€šè¿‡ map æ–¹æ³•çš„è°ƒç”¨è®¾ç½® request çš„æˆå‘˜å˜é‡ mappingData çš„æˆå‘˜å˜é‡ hostã€contextã€warp ä¿¡æ¯ï¼Œæ¥ç€ä» mappingData ä¸­å–å‡º context å’Œ wrapper ï¼Œç›´æ¥è®¾ç½®åˆ° request å¯¹è±¡çš„æˆå‘˜å˜é‡ contextã€wrapper ä¸­ã€‚ä¸‹å›¾æ˜¯ä¸Šé¢æ‰€æè¿°çš„å…³é”®ä»£ç è°ƒç”¨è¿‡ç¨‹çš„æ—¶åºå›¾ï¼š

![img]https://user-gold-cdn.xitu.io/2018/1/31/1614b9087ade3e55?imageView2/0/w/1280/h/960/format/jpeg/ignore-error/1)

 æœ¬æ–‡ä¸å†ä»”ç»†åˆ†æ hostã€contextã€warp çš„åŒ¹é…è¿‡ç¨‹ï¼Œè¯·è¯»è€…è‡ªå·±é˜…è¯»

```Java
org.apache.tomcat.util.http.mapper.Mapper
```

ç±»æºç ï¼Œè¿™é‡Œå¤§è‡´è¯´ä¸‹å…¶åŒ¹é…åŸç†ï¼Œåœ¨

```Java
org.apache.tomcat.util.http.mapper.Mapper
```

ç±»ä¸­æœ‰å‡ ä¸ªå†…éƒ¨ç±» Hostã€Contextã€Wrapperï¼ŒMapper ç±»å†…éƒ¨åˆ†åˆ«æœ‰è¿™å‡ ç§ç±»å‹çš„æˆå‘˜å˜é‡ï¼Œåœ¨ Tomcat å®¹å™¨å¯åŠ¨çš„æ—¶å€™ä¼šè°ƒç”¨

```Java
org.apache.catalina.connector.Connector
```

ç±»çš„ startInternal æ–¹æ³•ï¼ˆå…·ä½“å¯åŠ¨è¿‡ç¨‹åˆ†æ[å‚è§å‰æ–‡](#)ï¼‰ï¼Œè¯¥æ–¹æ³•æœ€åä¸€è¡Œï¼š



```Java
mapperListener.start();

```

è¿™é‡Œå°†ä¼šè°ƒç”¨`org.apache.catalina.connector.MapperListener`ç±»çš„ startInternal æ–¹æ³•ï¼š

```Java
     1	    public void startInternal() throws LifecycleException {
     2
     3	        setState(LifecycleState.STARTING);
     4
     5	        // Find any components that have already been initialized since the
     6	        // MBean listener won't be notified as those components will have
     7	        // already registered their MBeans
     8	        findDefaultHost();
     9
    10	        Engine engine = (Engine) connector.getService().getContainer();
    11	        addListeners(engine);
    12
    13	        Container[] conHosts = engine.findChildren();
    14	        for (Container conHost : conHosts) {
    15	            Host host = (Host) conHost;
    16	            if (!LifecycleState.NEW.equals(host.getState())) {
    17	                // Registering the host will register the context and wrappers
    18	                registerHost(host);
    19	            }
    20	        }
    21	    }

```

åœ¨ç¬¬ 18 è¡Œè°ƒç”¨å½“å‰ç±»çš„ registerHost æ–¹æ³•ï¼š

```Java
     1	    private void registerHost(Host host) {
     2
     3	        String[] aliases = host.findAliases();
     4	        mapper.addHost(host.getName(), aliases, host);
     5
     6	        for (Container container : host.findChildren()) {
     7	            if (container.getState().isAvailable()) {
     8	                registerContext((Context) container);
     9	            }
    10	        }
    11	        if(log.isDebugEnabled()) {
    12	            log.debug(sm.getString("mapperListener.registerHost",
    13	                    host.getName(), domain, connector));
    14	        }
    15	    }

```

ç¬¬ 8 è¡Œåœ¨ registerHost æ–¹æ³•ä¸­ä¼šè°ƒç”¨ registerContext æ–¹æ³•ï¼Œåœ¨ registerContext æ–¹æ³•ä¸­ä¼šè°ƒç”¨ registerWrapper æ–¹æ³•ã€‚ç¬¬4è¡Œçœ‹åˆ°è°ƒç”¨äº†ä¸Šè¿° mapper å¯¹è±¡çš„ addHost æ–¹æ³•ï¼Œåœ¨ registerContext æ–¹æ³•ä¸­ä¼šè°ƒç”¨ mapper å¯¹è±¡çš„ mapper.addContextVersion æ–¹æ³•ï¼Œåœ¨ registerWrapper æ–¹æ³•ä¸­ä¼šè°ƒç”¨ mapper å¯¹è±¡çš„ mapper.addWrapper æ–¹æ³•ã€‚

æ‰€ä»¥åœ¨ Tomcat å®¹å™¨å¯åŠ¨è¿‡ç¨‹ä¸­ä¼šå°†åœ¨ç”¨çš„ Hostã€Contextã€Wrapper ç»„ä»¶åŒæ—¶ç»´æŠ¤åˆ°ä¸ä¸€ä¸ª Connector ç›¸å…³çš„ Mapper å¯¹è±¡é‡Œï¼Œè¿™æ ·æ‰ä¼šåœ¨å®¹å™¨æ¥æ”¶åˆ°ä¸€æ¬¡è¯·æ±‚çš„æ—¶å€™å¯ä»¥æ ¹æ®è¯·æ±‚çš„URLç­‰ä¿¡æ¯åŒ¹é…åˆ°å…·ä½“çš„ hostã€contextã€wrapper ã€‚

æœ¬æ–‡ä¸­æåˆ°çš„ wrapper å®é™…ä¸Šæ˜¯ Tomcat å®¹å™¨å†…éƒ¨å¯¹äº Servlet çš„å°è£…ï¼Œå¯ä»¥è®¤ä¸ºæ˜¯ä¸€å¯¹ä¸€çš„å…³ç³»ã€‚çœ‹ä¸‹ Tomcat å®¹å™¨çš„ç»„ä»¶ç»“æ„å›¾ï¼š

![img](https://user-gold-cdn.xitu.io/2018/1/31/1614b9577d59283e?imageView2/0/w/1280/h/960/format/jpeg/ignore-error/1)

 åœ¨ Service å†…åªæœ‰ä¸€ä¸ª Engine ï¼Œä½†å¯èƒ½æœ‰å¤šä¸ª Connector ï¼Œåœ¨ Engine å†…éƒ¨ Engine å’Œ Host ï¼ŒHost å’Œ Contextï¼ŒContext å’Œ Wrapper éƒ½æ˜¯ä¸€å¯¹å¤šçš„å…³ç³»ã€‚ä½†æµè§ˆå™¨å‘å‡ºä¸€æ¬¡è¯·æ±‚è¿æ¥å¹¶ä¸éœ€è¦ä¹Ÿä¸å¯èƒ½è®©éƒ¨ç½²åœ¨ Tomcat ä¸­çš„æ‰€æœ‰ Web åº”ç”¨çš„æ‰€æœ‰ Servlet ç±»éƒ½æ‰§è¡Œä¸€éï¼Œæœ¬æ–‡æ‰€è¯´çš„ Map æœºåˆ¶å°±æ˜¯ä¸ºäº† Connector åœ¨æ¥æ”¶åˆ°ä¸€æ¬¡ Socket è¿æ¥æ—¶è½¬åŒ–æˆè¯·æ±‚åï¼Œèƒ½å¤Ÿæ‰¾åˆ° Engine ä¸‹å…·ä½“å“ªä¸ª Hostã€å“ªä¸ª Contextã€å“ªä¸ª Wrapperæ¥æ‰§è¡Œè¿™ä¸ªè¯·æ±‚ã€‚